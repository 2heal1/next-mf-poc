/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.federation/entry.2d88cb90db7ff84f05925b07a55b0f71.js":
/*!****************************************************************************!*\
  !*** ./node_modules/.federation/entry.2d88cb90db7ff84f05925b07a55b0f71.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js */ \"./node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js\");\n/* harmony import */ var _home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js */ \"./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js\");\n\n\n\nvar prevFederation = __webpack_require__.federation;\n__webpack_require__.federation = {}\nfor(var key in (_home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())){\n\t__webpack_require__.federation[key] = (_home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_webpack_bundler_runtime_dist_index_cjs_js__WEBPACK_IMPORTED_MODULE_0___default())[key];\n}\nfor(var key in prevFederation){\n\t__webpack_require__.federation[key] = prevFederation[key];\n}\nif(!__webpack_require__.federation.instance){\n\tconst pluginsToAdd = [\n\t\t_home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] ? (0,_home_autkarsh_projects_next_mf_poc_remote_node_modules_module_federation_nextjs_mf_dist_src_plugins_container_runtimePlugin_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])() : false,\n\t].filter(Boolean);\n\t__webpack_require__.federation.initOptions.plugins = __webpack_require__.federation.initOptions.plugins ? \n\t__webpack_require__.federation.initOptions.plugins.concat(pluginsToAdd) : pluginsToAdd;\n\t__webpack_require__.federation.instance = __webpack_require__.federation.runtime.init(__webpack_require__.federation.initOptions);\n\tif(__webpack_require__.federation.attachShareScopeMap){\n\t\t__webpack_require__.federation.attachShareScopeMap(__webpack_require__)\n\t}\n\tif(__webpack_require__.federation.installInitialConsumes){\n\t\t__webpack_require__.federation.installInitialConsumes()\n\t}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLmZlZGVyYXRpb24vZW50cnkuMmQ4OGNiOTBkYjdmZjg0ZjA1OTI1YjA3YTU1YjBmNzEuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUE4STtBQUNVOztBQUV4SixxQkFBcUIsbUJBQW1CO0FBQ3hDLG1CQUFtQjtBQUNuQixlQUFlLDRKQUFVO0FBQ3pCLENBQUMsbUJBQW1CLG1CQUFtQiw0SkFBVTtBQUNqRDtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUI7QUFDcEI7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBLEVBQUUsdUtBQVEsR0FBRywyS0FBUTtBQUNyQjtBQUNBLENBQUMsbUJBQW1CLGtDQUFrQyxtQkFBbUI7QUFDekUsQ0FBQyxtQkFBbUI7QUFDcEIsQ0FBQyxtQkFBbUIsdUJBQXVCLG1CQUFtQix5QkFBeUIsbUJBQW1CO0FBQzFHLElBQUksbUJBQW1CO0FBQ3ZCLEVBQUUsbUJBQW1CLGdDQUFnQyxtQkFBbUI7QUFDeEU7QUFDQSxJQUFJLG1CQUFtQjtBQUN2QixFQUFFLG1CQUFtQjtBQUNyQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVtb3RlLy4vbm9kZV9tb2R1bGVzLy5mZWRlcmF0aW9uL2VudHJ5LjJkODhjYjkwZGI3ZmY4NGYwNTkyNWIwN2E1NWIwZjcxLmpzP2MxMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZlZGVyYXRpb24gZnJvbSAnL2hvbWUvYXV0a2Fyc2gvcHJvamVjdHMvbmV4dC1tZi1wb2MvcmVtb3RlL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vd2VicGFjay1idW5kbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5janMuanMnO1xuaW1wb3J0IHBsdWdpbl8wIGZyb20gJy9ob21lL2F1dGthcnNoL3Byb2plY3RzL25leHQtbWYtcG9jL3JlbW90ZS9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmpzJztcblxudmFyIHByZXZGZWRlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uID0ge31cbmZvcih2YXIga2V5IGluIGZlZGVyYXRpb24pe1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmZlZGVyYXRpb25ba2V5XSA9IGZlZGVyYXRpb25ba2V5XTtcbn1cbmZvcih2YXIga2V5IGluIHByZXZGZWRlcmF0aW9uKXtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uW2tleV0gPSBwcmV2RmVkZXJhdGlvbltrZXldO1xufVxuaWYoIV9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YW5jZSl7XG5cdGNvbnN0IHBsdWdpbnNUb0FkZCA9IFtcblx0XHRwbHVnaW5fMCA/IHBsdWdpbl8wKCkgOiBmYWxzZSxcblx0XS5maWx0ZXIoQm9vbGVhbik7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbml0T3B0aW9ucy5wbHVnaW5zID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zLnBsdWdpbnMgPyBcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zLnBsdWdpbnMuY29uY2F0KHBsdWdpbnNUb0FkZCkgOiBwbHVnaW5zVG9BZGQ7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5ydW50aW1lLmluaXQoX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluaXRPcHRpb25zKTtcblx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmF0dGFjaFNoYXJlU2NvcGVNYXApe1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5hdHRhY2hTaGFyZVNjb3BlTWFwKF9fd2VicGFja19yZXF1aXJlX18pXG5cdH1cblx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbGxJbml0aWFsQ29uc3VtZXMpe1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YWxsSW5pdGlhbENvbnN1bWVzKClcblx0fVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.federation/entry.2d88cb90db7ff84f05925b07a55b0f71.js\n"));

/***/ }),

/***/ "./node_modules/@module-federation/runtime/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@module-federation/runtime/dist/index.esm.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FederationHost: function() { return /* binding */ FederationHost; },\n/* harmony export */   getInstance: function() { return /* binding */ getInstance; },\n/* harmony export */   getRemoteEntry: function() { return /* binding */ getRemoteEntry; },\n/* harmony export */   getRemoteInfo: function() { return /* binding */ getRemoteInfo; },\n/* harmony export */   init: function() { return /* binding */ init; },\n/* harmony export */   loadRemote: function() { return /* binding */ loadRemote; },\n/* harmony export */   loadScript: function() { return /* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript; },\n/* harmony export */   loadScriptNode: function() { return /* reexport safe */ _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode; },\n/* harmony export */   loadShare: function() { return /* binding */ loadShare; },\n/* harmony export */   loadShareSync: function() { return /* binding */ loadShareSync; },\n/* harmony export */   preloadRemote: function() { return /* binding */ preloadRemote; },\n/* harmony export */   registerGlobalPlugins: function() { return /* reexport safe */ _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.J; },\n/* harmony export */   registerPlugins: function() { return /* binding */ registerPlugins; },\n/* harmony export */   registerRemotes: function() { return /* binding */ registerRemotes; }\n/* harmony export */ });\n/* harmony import */ var _share_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./share.esm.js */ \"./node_modules/@module-federation/runtime/dist/share.esm.js\");\n/* harmony import */ var _module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @module-federation/sdk */ \"./node_modules/@module-federation/sdk/dist/index.esm.js\");\n\n\n\n\n\n// Function to match a remote with its name and expose\n// id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n// id: alias(app1) + expose(button) = app1/button\n// id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\nfunction matchRemoteWithNameAndExpose(remotes, id) {\n    for (const remote of remotes){\n        // match pkgName\n        const isNameMatched = id.startsWith(remote.name);\n        let expose = id.replace(remote.name, '');\n        if (isNameMatched) {\n            if (expose.startsWith('/')) {\n                const pkgNameOrAlias = remote.name;\n                expose = `.${expose}`;\n                return {\n                    pkgNameOrAlias,\n                    expose,\n                    remote\n                };\n            } else if (expose === '') {\n                return {\n                    pkgNameOrAlias: remote.name,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n        // match alias\n        const isAliasMatched = remote.alias && id.startsWith(remote.alias);\n        let exposeWithAlias = remote.alias && id.replace(remote.alias, '');\n        if (remote.alias && isAliasMatched) {\n            if (exposeWithAlias && exposeWithAlias.startsWith('/')) {\n                const pkgNameOrAlias = remote.alias;\n                exposeWithAlias = `.${exposeWithAlias}`;\n                return {\n                    pkgNameOrAlias,\n                    expose: exposeWithAlias,\n                    remote\n                };\n            } else if (exposeWithAlias === '') {\n                return {\n                    pkgNameOrAlias: remote.alias,\n                    expose: '.',\n                    remote\n                };\n            }\n        }\n    }\n    return;\n}\n// Function to match a remote with its name or alias\nfunction matchRemote(remotes, nameOrAlias) {\n    for (const remote of remotes){\n        const isNameMatched = nameOrAlias === remote.name;\n        if (isNameMatched) {\n            return remote;\n        }\n        const isAliasMatched = remote.alias && nameOrAlias === remote.alias;\n        if (isAliasMatched) {\n            return remote;\n        }\n    }\n    return;\n}\n\nfunction registerPlugins$1(plugins, hookInstances) {\n    const globalPlugins = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.g)();\n    // Incorporate global plugins\n    if (globalPlugins.length > 0) {\n        globalPlugins.forEach((plugin)=>{\n            if (plugins == null ? void 0 : plugins.find((item)=>item.name !== plugin.name)) {\n                plugins.push(plugin);\n            }\n        });\n    }\n    if (plugins && plugins.length > 0) {\n        plugins.forEach((plugin)=>{\n            hookInstances.forEach((hookInstance)=>{\n                hookInstance.applyPlugin(plugin);\n            });\n        });\n    }\n    return plugins;\n}\n\nfunction _extends$7() {\n    _extends$7 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$7.apply(this, arguments);\n}\nasync function loadEsmEntry({ entry, remoteEntryExports }) {\n    return new Promise((resolve, reject)=>{\n        try {\n            if (!remoteEntryExports) {\n                // eslint-disable-next-line no-eval\n                new Function('callbacks', `import(\"${entry}\").then(callbacks[0]).catch(callbacks[1])`)([\n                    resolve,\n                    reject\n                ]);\n            } else {\n                resolve(remoteEntryExports);\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\nasync function loadSystemJsEntry({ entry, remoteEntryExports }) {\n    return new Promise((resolve, reject)=>{\n        try {\n            if (!remoteEntryExports) {\n                // eslint-disable-next-line no-eval\n                new Function('callbacks', `System.import(\"${entry}\").then(callbacks[0]).catch(callbacks[1])`)([\n                    resolve,\n                    reject\n                ]);\n            } else {\n                resolve(remoteEntryExports);\n            }\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\nasync function loadEntryScript({ name, globalName, entry, createScriptHook }) {\n    const { entryExports: remoteEntryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScript)(entry, {\n        attrs: {},\n        createScriptHook: (url, attrs)=>{\n            const res = createScriptHook.emit({\n                url,\n                attrs\n            });\n            if (!res) return;\n            if (res instanceof HTMLScriptElement) {\n                return res;\n            }\n            if ('script' in res || 'timeout' in res) {\n                return res;\n            }\n            return;\n        }\n    }).then(()=>{\n        const { remoteEntryKey, entryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(entryExports, `\n      Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.\n      Possible reasons could be:\\n\n      1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\\n\n      2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.\n    `);\n        return entryExports;\n    }).catch((e)=>{\n        throw e;\n    });\n}\nasync function loadEntryDom({ remoteInfo, remoteEntryExports, createScriptHook }) {\n    const { entry, entryGlobalName: globalName, name, type } = remoteInfo;\n    switch(type){\n        case 'esm':\n        case 'module':\n            return loadEsmEntry({\n                entry,\n                remoteEntryExports\n            });\n        case 'system':\n            return loadSystemJsEntry({\n                entry,\n                remoteEntryExports\n            });\n        default:\n            return loadEntryScript({\n                entry,\n                globalName,\n                name,\n                createScriptHook\n            });\n    }\n}\nasync function loadEntryNode({ remoteInfo, createScriptHook }) {\n    const { entry, entryGlobalName: globalName, name } = remoteInfo;\n    const { entryExports: remoteEntryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.loadScriptNode)(entry, {\n        attrs: {\n            name,\n            globalName\n        },\n        createScriptHook: (url, attrs)=>{\n            const res = createScriptHook.emit({\n                url,\n                attrs\n            });\n            if (!res) return;\n            if ('url' in res) {\n                return res;\n            }\n            return;\n        }\n    }).then(()=>{\n        const { remoteEntryKey, entryExports } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(name, globalName);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(entryExports, `\n      Unable to use the ${name}'s '${entry}' URL with ${remoteEntryKey}'s globalName to get remoteEntry exports.\n      Possible reasons could be:\\n\n      1. '${entry}' is not the correct URL, or the remoteEntry resource or name is incorrect.\\n\n      2. ${remoteEntryKey} cannot be used to get remoteEntry exports in the window object.\n    `);\n        return entryExports;\n    }).catch((e)=>{\n        throw e;\n    });\n}\nfunction getRemoteEntryUniqueKey(remoteInfo) {\n    const { entry, name } = remoteInfo;\n    return (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(name, entry);\n}\nasync function getRemoteEntry({ origin, remoteEntryExports, remoteInfo }) {\n    const uniqueKey = getRemoteEntryUniqueKey(remoteInfo);\n    if (remoteEntryExports) {\n        return remoteEntryExports;\n    }\n    if (!_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey]) {\n        const loadEntryHook = origin.remoteHandler.hooks.lifecycle.loadEntry;\n        if (loadEntryHook.listeners.size) {\n            _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey] = loadEntryHook.emit({\n                createScriptHook: origin.loaderHook.lifecycle.createScript,\n                remoteInfo,\n                remoteEntryExports\n            }).then((res)=>res || undefined);\n        } else {\n            const createScriptHook = origin.loaderHook.lifecycle.createScript;\n            if (!(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)()) {\n                _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey] = loadEntryNode({\n                    remoteInfo,\n                    createScriptHook\n                });\n            } else {\n                _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey] = loadEntryDom({\n                    remoteInfo,\n                    remoteEntryExports,\n                    createScriptHook\n                });\n            }\n        }\n    }\n    return _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[uniqueKey];\n}\nfunction getRemoteInfo(remote) {\n    return _extends$7({}, remote, {\n        entry: 'entry' in remote ? remote.entry : '',\n        type: remote.type || _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.D,\n        entryGlobalName: remote.entryGlobalName || remote.name,\n        shareScope: remote.shareScope || _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b\n    });\n}\n\nfunction _extends$6() {\n    _extends$6 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$6.apply(this, arguments);\n}\nlet Module = class Module {\n    async getEntry() {\n        if (this.remoteEntryExports) {\n            return this.remoteEntryExports;\n        }\n        // Get remoteEntry.js\n        const remoteEntryExports = await getRemoteEntry({\n            origin: this.host,\n            remoteInfo: this.remoteInfo,\n            remoteEntryExports: this.remoteEntryExports\n        });\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteEntryExports, `remoteEntryExports is undefined \\n ${(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)(this.remoteInfo)}`);\n        this.remoteEntryExports = remoteEntryExports;\n        return this.remoteEntryExports;\n    }\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    async get(id, expose, options) {\n        const { loadFactory = true } = options || {\n            loadFactory: true\n        };\n        // Get remoteEntry.js\n        const remoteEntryExports = await this.getEntry();\n        if (!this.inited) {\n            const localShareScopeMap = this.host.shareScopeMap;\n            const remoteShareScope = this.remoteInfo.shareScope || 'default';\n            if (!localShareScopeMap[remoteShareScope]) {\n                localShareScopeMap[remoteShareScope] = {};\n            }\n            const shareScope = localShareScopeMap[remoteShareScope];\n            const initScope = [];\n            const remoteEntryInitOptions = {\n                version: this.remoteInfo.version || ''\n            };\n            // Help to find host instance\n            Object.defineProperty(remoteEntryInitOptions, 'shareScopeMap', {\n                value: localShareScopeMap,\n                // remoteEntryInitOptions will be traversed and assigned during container init, ,so this attribute is not allowed to be traversed\n                enumerable: false\n            });\n            const initContainerOptions = await this.host.hooks.lifecycle.beforeInitContainer.emit({\n                shareScope,\n                // @ts-ignore shareScopeMap will be set by Object.defineProperty\n                remoteEntryInitOptions,\n                initScope,\n                remoteInfo: this.remoteInfo,\n                origin: this.host\n            });\n            if (typeof (remoteEntryExports == null ? void 0 : remoteEntryExports.init) === 'undefined') {\n                console.error('The remote entry interface does not contain \"init\"', '\\n', 'Ensure the name of this remote is not reserved or in use. Check if anything already exists on window[nameOfRemote]', '\\n', 'Ensure that window[nameOfRemote] is returning a {get,init} object.');\n            }\n            await remoteEntryExports.init(initContainerOptions.shareScope, initContainerOptions.initScope, initContainerOptions.remoteEntryInitOptions);\n            await this.host.hooks.lifecycle.initContainer.emit(_extends$6({}, initContainerOptions, {\n                remoteEntryExports\n            }));\n        }\n        this.lib = remoteEntryExports;\n        this.inited = true;\n        // get exposeGetter\n        const moduleFactory = await remoteEntryExports.get(expose);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(moduleFactory, `${(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(this.remoteInfo)} remote don't export ${expose}.`);\n        const wrapModuleFactory = this.wraperFactory(moduleFactory, id);\n        if (!loadFactory) {\n            return wrapModuleFactory;\n        }\n        const exposeContent = await wrapModuleFactory();\n        return exposeContent;\n    }\n    wraperFactory(moduleFactory, id) {\n        function defineModuleId(res, id) {\n            if (res && typeof res === 'object' && Object.isExtensible(res) && !Object.getOwnPropertyDescriptor(res, Symbol.for('mf_module_id'))) {\n                Object.defineProperty(res, Symbol.for('mf_module_id'), {\n                    value: id,\n                    enumerable: false\n                });\n            }\n        }\n        if (moduleFactory instanceof Promise) {\n            return async ()=>{\n                const res = await moduleFactory();\n                // This parameter is used for bridge debugging\n                defineModuleId(res, id);\n                return res;\n            };\n        } else {\n            return ()=>{\n                const res = moduleFactory();\n                // This parameter is used for bridge debugging\n                defineModuleId(res, id);\n                return res;\n            };\n        }\n    }\n    constructor({ remoteInfo, host }){\n        this.inited = false;\n        this.lib = undefined;\n        this.remoteInfo = remoteInfo;\n        this.host = host;\n    }\n};\n\nclass SyncHook {\n    on(fn) {\n        if (typeof fn === 'function') {\n            this.listeners.add(fn);\n        }\n    }\n    once(fn) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        this.on(function wrapper(...args) {\n            self.remove(wrapper);\n            // eslint-disable-next-line prefer-spread\n            return fn.apply(null, args);\n        });\n    }\n    emit(...data) {\n        let result;\n        if (this.listeners.size > 0) {\n            // eslint-disable-next-line prefer-spread\n            this.listeners.forEach((fn)=>{\n                result = fn(...data);\n            });\n        }\n        return result;\n    }\n    remove(fn) {\n        this.listeners.delete(fn);\n    }\n    removeAll() {\n        this.listeners.clear();\n    }\n    constructor(type){\n        this.type = '';\n        this.listeners = new Set();\n        if (type) {\n            this.type = type;\n        }\n    }\n}\n\nclass AsyncHook extends SyncHook {\n    emit(...data) {\n        let result;\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const call = (prev)=>{\n                if (prev === false) {\n                    return false; // Abort process\n                } else if (i < ls.length) {\n                    return Promise.resolve(ls[i++].apply(null, data)).then(call);\n                } else {\n                    return prev;\n                }\n            };\n            result = call();\n        }\n        return Promise.resolve(result);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction checkReturnData(originalData, returnedData) {\n    if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(returnedData)) {\n        return false;\n    }\n    if (originalData !== returnedData) {\n        // eslint-disable-next-line no-restricted-syntax\n        for(const key in originalData){\n            if (!(key in returnedData)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nclass SyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The data for the \"${this.type}\" hook should be an object.`);\n        }\n        for (const fn of this.listeners){\n            try {\n                const tempData = fn(data);\n                if (checkReturnData(data, tempData)) {\n                    data = tempData;\n                } else {\n                    this.onerror(`A plugin returned an unacceptable value for the \"${this.type}\" type.`);\n                    break;\n                }\n            } catch (e) {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(e);\n                this.onerror(e);\n            }\n        }\n        return data;\n    }\n    constructor(type){\n        super();\n        this.onerror = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f;\n        this.type = type;\n    }\n}\n\nclass AsyncWaterfallHook extends SyncHook {\n    emit(data) {\n        if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The response data for the \"${this.type}\" hook must be an object.`);\n        }\n        const ls = Array.from(this.listeners);\n        if (ls.length > 0) {\n            let i = 0;\n            const processError = (e)=>{\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.w)(e);\n                this.onerror(e);\n                return data;\n            };\n            const call = (prevData)=>{\n                if (checkReturnData(data, prevData)) {\n                    data = prevData;\n                    if (i < ls.length) {\n                        try {\n                            return Promise.resolve(ls[i++](data)).then(call, processError);\n                        } catch (e) {\n                            return processError(e);\n                        }\n                    }\n                } else {\n                    this.onerror(`A plugin returned an incorrect value for the \"${this.type}\" type.`);\n                }\n                return data;\n            };\n            return Promise.resolve(call(data));\n        }\n        return Promise.resolve(data);\n    }\n    constructor(type){\n        super();\n        this.onerror = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f;\n        this.type = type;\n    }\n}\n\nclass PluginSystem {\n    applyPlugin(plugin) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.h)(plugin), 'Plugin configuration is invalid.');\n        // The plugin's name is mandatory and must be unique\n        const pluginName = plugin.name;\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(pluginName, 'A name must be provided by the plugin.');\n        if (!this.registerPlugins[pluginName]) {\n            this.registerPlugins[pluginName] = plugin;\n            Object.keys(this.lifecycle).forEach((key)=>{\n                const pluginLife = plugin[key];\n                if (pluginLife) {\n                    this.lifecycle[key].on(pluginLife);\n                }\n            });\n        }\n    }\n    removePlugin(pluginName) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(pluginName, 'A name is required.');\n        const plugin = this.registerPlugins[pluginName];\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(plugin, `The plugin \"${pluginName}\" is not registered.`);\n        Object.keys(plugin).forEach((key)=>{\n            if (key !== 'name') {\n                this.lifecycle[key].remove(plugin[key]);\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    inherit({ lifecycle, registerPlugins }) {\n        Object.keys(lifecycle).forEach((hookName)=>{\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!this.lifecycle[hookName], `The hook \"${hookName}\" has a conflict and cannot be inherited.`);\n            this.lifecycle[hookName] = lifecycle[hookName];\n        });\n        Object.keys(registerPlugins).forEach((pluginName)=>{\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!this.registerPlugins[pluginName], `The plugin \"${pluginName}\" has a conflict and cannot be inherited.`);\n            this.applyPlugin(registerPlugins[pluginName]);\n        });\n    }\n    constructor(lifecycle){\n        this.registerPlugins = {};\n        this.lifecycle = lifecycle;\n        this.lifecycleKeys = Object.keys(lifecycle);\n    }\n}\n\nfunction _extends$5() {\n    _extends$5 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$5.apply(this, arguments);\n}\nfunction defaultPreloadArgs(preloadConfig) {\n    return _extends$5({\n        resourceCategory: 'sync',\n        share: true,\n        depsRemote: true,\n        prefetchInterface: false\n    }, preloadConfig);\n}\nfunction formatPreloadArgs(remotes, preloadArgs) {\n    return preloadArgs.map((args)=>{\n        const remoteInfo = matchRemote(remotes, args.nameOrAlias);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteInfo, `Unable to preload ${args.nameOrAlias} as it is not included in ${!remoteInfo && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.s)({\n            remoteInfo,\n            remotes\n        })}`);\n        return {\n            remote: remoteInfo,\n            preloadConfig: defaultPreloadArgs(args)\n        };\n    });\n}\nfunction normalizePreloadExposes(exposes) {\n    if (!exposes) {\n        return [];\n    }\n    return exposes.map((expose)=>{\n        if (expose === '.') {\n            return expose;\n        }\n        if (expose.startsWith('./')) {\n            return expose.replace('./', '');\n        }\n        return expose;\n    });\n}\nfunction preloadAssets(remoteInfo, host, assets, // It is used to distinguish preload from load remote parallel loading\nuseLinkPreload = true) {\n    const { cssAssets, jsAssetsWithoutEntry, entryAssets } = assets;\n    if (host.options.inBrowser) {\n        entryAssets.forEach((asset)=>{\n            const { moduleInfo } = asset;\n            const module = host.moduleCache.get(remoteInfo.name);\n            if (module) {\n                getRemoteEntry({\n                    origin: host,\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: module.remoteEntryExports\n                });\n            } else {\n                getRemoteEntry({\n                    origin: host,\n                    remoteInfo: moduleInfo,\n                    remoteEntryExports: undefined\n                });\n            }\n        });\n        if (useLinkPreload) {\n            const defaultAttrs = {\n                rel: 'preload',\n                as: 'style',\n                crossorigin: 'anonymous'\n            };\n            cssAssets.forEach((cssUrl)=>{\n                const { link: cssEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)({\n                    url: cssUrl,\n                    cb: ()=>{},\n                    attrs: defaultAttrs,\n                    createLinkHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createLink.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLLinkElement) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n                needAttach && document.head.appendChild(cssEl);\n            });\n        } else {\n            const defaultAttrs = {\n                rel: 'stylesheet',\n                type: 'text/css'\n            };\n            cssAssets.forEach((cssUrl)=>{\n                const { link: cssEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)({\n                    url: cssUrl,\n                    cb: ()=>{},\n                    attrs: defaultAttrs,\n                    createLinkHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createLink.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLLinkElement) {\n                            return res;\n                        }\n                        return;\n                    },\n                    needDeleteLink: false\n                });\n                needAttach && document.head.appendChild(cssEl);\n            });\n        }\n        if (useLinkPreload) {\n            const defaultAttrs = {\n                rel: 'preload',\n                as: 'script',\n                crossorigin: 'anonymous'\n            };\n            jsAssetsWithoutEntry.forEach((jsUrl)=>{\n                const { link: linkEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createLink)({\n                    url: jsUrl,\n                    cb: ()=>{},\n                    attrs: defaultAttrs,\n                    createLinkHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createLink.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLLinkElement) {\n                            return res;\n                        }\n                        return;\n                    }\n                });\n                needAttach && document.head.appendChild(linkEl);\n            });\n        } else {\n            const defaultAttrs = {\n                fetchpriority: 'high',\n                type: (remoteInfo == null ? void 0 : remoteInfo.type) === 'module' ? 'module' : 'text/javascript'\n            };\n            jsAssetsWithoutEntry.forEach((jsUrl)=>{\n                const { script: scriptEl, needAttach } = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.createScript)({\n                    url: jsUrl,\n                    cb: ()=>{},\n                    attrs: defaultAttrs,\n                    createScriptHook: (url, attrs)=>{\n                        const res = host.loaderHook.lifecycle.createScript.emit({\n                            url,\n                            attrs\n                        });\n                        if (res instanceof HTMLScriptElement) {\n                            return res;\n                        }\n                        return;\n                    },\n                    needDeleteScript: true\n                });\n                needAttach && document.head.appendChild(scriptEl);\n            });\n        }\n    }\n}\n\nfunction _extends$4() {\n    _extends$4 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$4.apply(this, arguments);\n}\nfunction assignRemoteInfo(remoteInfo, remoteSnapshot) {\n    const remoteEntryInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)(remoteSnapshot);\n    if (!remoteEntryInfo.url) {\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`The attribute remoteEntry of ${remoteInfo.name} must not be undefined.`);\n    }\n    let entryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(remoteSnapshot, remoteEntryInfo.url);\n    if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.m)() && !entryUrl.startsWith('http')) {\n        entryUrl = `https:${entryUrl}`;\n    }\n    remoteInfo.type = remoteEntryInfo.type;\n    remoteInfo.entryGlobalName = remoteEntryInfo.globalName;\n    remoteInfo.entry = entryUrl;\n    remoteInfo.version = remoteSnapshot.version;\n    remoteInfo.buildVersion = remoteSnapshot.buildVersion;\n}\nfunction snapshotPlugin() {\n    return {\n        name: 'snapshot-plugin',\n        async afterResolve (args) {\n            const { remote, pkgNameOrAlias, expose, origin, remoteInfo } = args;\n            if (!(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(remote) || !(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.k)(remote)) {\n                const { remoteSnapshot, globalSnapshot } = await origin.snapshotHandler.loadRemoteSnapshotInfo(remote);\n                assignRemoteInfo(remoteInfo, remoteSnapshot);\n                // preloading assets\n                const preloadOptions = {\n                    remote,\n                    preloadConfig: {\n                        nameOrAlias: pkgNameOrAlias,\n                        exposes: [\n                            expose\n                        ],\n                        resourceCategory: 'sync',\n                        share: false,\n                        depsRemote: false\n                    }\n                };\n                const assets = await origin.remoteHandler.hooks.lifecycle.generatePreloadAssets.emit({\n                    origin,\n                    preloadOptions,\n                    remoteInfo,\n                    remote,\n                    remoteSnapshot,\n                    globalSnapshot\n                });\n                if (assets) {\n                    preloadAssets(remoteInfo, origin, assets, false);\n                }\n                return _extends$4({}, args, {\n                    remoteSnapshot\n                });\n            }\n            return args;\n        }\n    };\n}\n\n// name\n// name:version\nfunction splitId(id) {\n    const splitInfo = id.split(':');\n    if (splitInfo.length === 1) {\n        return {\n            name: splitInfo[0],\n            version: undefined\n        };\n    } else if (splitInfo.length === 2) {\n        return {\n            name: splitInfo[0],\n            version: splitInfo[1]\n        };\n    } else {\n        return {\n            name: splitInfo[1],\n            version: splitInfo[2]\n        };\n    }\n}\n// Traverse all nodes in moduleInfo and traverse the entire snapshot\nfunction traverseModuleInfo(globalSnapshot, remoteInfo, traverse, isRoot, memo = {}, remoteSnapshot) {\n    const id = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(remoteInfo);\n    const { value: snapshotValue } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.n)(globalSnapshot, id);\n    const effectiveRemoteSnapshot = remoteSnapshot || snapshotValue;\n    if (effectiveRemoteSnapshot && !(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(effectiveRemoteSnapshot)) {\n        traverse(effectiveRemoteSnapshot, remoteInfo, isRoot);\n        if (effectiveRemoteSnapshot.remotesInfo) {\n            const remoteKeys = Object.keys(effectiveRemoteSnapshot.remotesInfo);\n            for (const key of remoteKeys){\n                if (memo[key]) {\n                    continue;\n                }\n                memo[key] = true;\n                const subRemoteInfo = splitId(key);\n                const remoteValue = effectiveRemoteSnapshot.remotesInfo[key];\n                traverseModuleInfo(globalSnapshot, {\n                    name: subRemoteInfo.name,\n                    version: remoteValue.matchedVersion\n                }, traverse, false, memo, undefined);\n            }\n        }\n    }\n}\n// eslint-disable-next-line max-lines-per-function\nfunction generatePreloadAssets(origin, preloadOptions, remote, globalSnapshot, remoteSnapshot) {\n    const cssAssets = [];\n    const jsAssets = [];\n    const entryAssets = [];\n    const loadedSharedJsAssets = new Set();\n    const loadedSharedCssAssets = new Set();\n    const { options } = origin;\n    const { preloadConfig: rootPreloadConfig } = preloadOptions;\n    const { depsRemote } = rootPreloadConfig;\n    const memo = {};\n    traverseModuleInfo(globalSnapshot, remote, (moduleInfoSnapshot, remoteInfo, isRoot)=>{\n        let preloadConfig;\n        if (isRoot) {\n            preloadConfig = rootPreloadConfig;\n        } else {\n            if (Array.isArray(depsRemote)) {\n                // eslint-disable-next-line array-callback-return\n                const findPreloadConfig = depsRemote.find((remoteConfig)=>{\n                    if (remoteConfig.nameOrAlias === remoteInfo.name || remoteConfig.nameOrAlias === remoteInfo.alias) {\n                        return true;\n                    }\n                    return false;\n                });\n                if (!findPreloadConfig) {\n                    return;\n                }\n                preloadConfig = defaultPreloadArgs(findPreloadConfig);\n            } else if (depsRemote === true) {\n                preloadConfig = rootPreloadConfig;\n            } else {\n                return;\n            }\n        }\n        const remoteEntryUrl = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.l)(moduleInfoSnapshot).url);\n        if (remoteEntryUrl) {\n            entryAssets.push({\n                name: remoteInfo.name,\n                moduleInfo: {\n                    name: remoteInfo.name,\n                    entry: remoteEntryUrl,\n                    type: 'remoteEntryType' in moduleInfoSnapshot ? moduleInfoSnapshot.remoteEntryType : 'global',\n                    entryGlobalName: 'globalName' in moduleInfoSnapshot ? moduleInfoSnapshot.globalName : remoteInfo.name,\n                    shareScope: '',\n                    version: 'version' in moduleInfoSnapshot ? moduleInfoSnapshot.version : undefined\n                },\n                url: remoteEntryUrl\n            });\n        }\n        let moduleAssetsInfo = 'modules' in moduleInfoSnapshot ? moduleInfoSnapshot.modules : [];\n        const normalizedPreloadExposes = normalizePreloadExposes(preloadConfig.exposes);\n        if (normalizedPreloadExposes.length && 'modules' in moduleInfoSnapshot) {\n            var _moduleInfoSnapshot_modules;\n            moduleAssetsInfo = moduleInfoSnapshot == null ? void 0 : (_moduleInfoSnapshot_modules = moduleInfoSnapshot.modules) == null ? void 0 : _moduleInfoSnapshot_modules.reduce((assets, moduleAssetInfo)=>{\n                if ((normalizedPreloadExposes == null ? void 0 : normalizedPreloadExposes.indexOf(moduleAssetInfo.moduleName)) !== -1) {\n                    assets.push(moduleAssetInfo);\n                }\n                return assets;\n            }, []);\n        }\n        function handleAssets(assets) {\n            const assetsRes = assets.map((asset)=>(0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.getResourceUrl)(moduleInfoSnapshot, asset));\n            if (preloadConfig.filter) {\n                return assetsRes.filter(preloadConfig.filter);\n            }\n            return assetsRes;\n        }\n        if (moduleAssetsInfo) {\n            const assetsLength = moduleAssetsInfo.length;\n            for(let index = 0; index < assetsLength; index++){\n                const assetsInfo = moduleAssetsInfo[index];\n                const exposeFullPath = `${remoteInfo.name}/${assetsInfo.moduleName}`;\n                origin.remoteHandler.hooks.lifecycle.handlePreloadModule.emit({\n                    id: assetsInfo.moduleName === '.' ? remoteInfo.name : exposeFullPath,\n                    name: remoteInfo.name,\n                    remoteSnapshot: moduleInfoSnapshot,\n                    preloadConfig,\n                    remote: remoteInfo,\n                    origin\n                });\n                const preloaded = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.o)(exposeFullPath);\n                if (preloaded) {\n                    continue;\n                }\n                if (preloadConfig.resourceCategory === 'all') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.async));\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.async));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                // eslint-disable-next-line no-constant-condition\n                } else if (preloadConfig.resourceCategory = 'sync') {\n                    cssAssets.push(...handleAssets(assetsInfo.assets.css.sync));\n                    jsAssets.push(...handleAssets(assetsInfo.assets.js.sync));\n                }\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(exposeFullPath);\n            }\n        }\n    }, true, memo, remoteSnapshot);\n    if (remoteSnapshot.shared) {\n        const collectSharedAssets = (shareInfo, snapshotShared)=>{\n            const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(origin.shareScopeMap, snapshotShared.sharedName, shareInfo, origin.sharedHandler.hooks.lifecycle.resolveShare);\n            // If the global share does not exist, or the lib function does not exist, it means that the shared has not been loaded yet and can be preloaded.\n            if (registeredShared && typeof registeredShared.lib === 'function') {\n                snapshotShared.assets.js.sync.forEach((asset)=>{\n                    loadedSharedJsAssets.add(asset);\n                });\n                snapshotShared.assets.css.sync.forEach((asset)=>{\n                    loadedSharedCssAssets.add(asset);\n                });\n            }\n        };\n        remoteSnapshot.shared.forEach((shared)=>{\n            var _options_shared;\n            const shareInfos = (_options_shared = options.shared) == null ? void 0 : _options_shared[shared.sharedName];\n            if (!shareInfos) {\n                return;\n            }\n            // if no version, preload all shared\n            const sharedOptions = shared.version ? shareInfos.find((s)=>s.version === shared.version) : shareInfos;\n            if (!sharedOptions) {\n                return;\n            }\n            const arrayShareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.r)(sharedOptions);\n            arrayShareInfo.forEach((s)=>{\n                collectSharedAssets(s, shared);\n            });\n        });\n    }\n    const needPreloadJsAssets = jsAssets.filter((asset)=>!loadedSharedJsAssets.has(asset));\n    const needPreloadCssAssets = cssAssets.filter((asset)=>!loadedSharedCssAssets.has(asset));\n    return {\n        cssAssets: needPreloadCssAssets,\n        jsAssetsWithoutEntry: needPreloadJsAssets,\n        entryAssets\n    };\n}\nconst generatePreloadAssetsPlugin = function() {\n    return {\n        name: 'generate-preload-assets-plugin',\n        async generatePreloadAssets (args) {\n            const { origin, preloadOptions, remoteInfo, remote, globalSnapshot, remoteSnapshot } = args;\n            if ((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(remote) && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.k)(remote)) {\n                return {\n                    cssAssets: [],\n                    jsAssetsWithoutEntry: [],\n                    entryAssets: [\n                        {\n                            name: remote.name,\n                            url: remote.entry,\n                            moduleInfo: {\n                                name: remoteInfo.name,\n                                entry: remote.entry,\n                                type: 'global',\n                                entryGlobalName: '',\n                                shareScope: ''\n                            }\n                        }\n                    ]\n                };\n            }\n            assignRemoteInfo(remoteInfo, remoteSnapshot);\n            const assets = generatePreloadAssets(origin, preloadOptions, remoteInfo, globalSnapshot, remoteSnapshot);\n            return assets;\n        }\n    };\n};\n\nfunction _extends$3() {\n    _extends$3 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$3.apply(this, arguments);\n}\nfunction getGlobalRemoteInfo(moduleInfo, origin) {\n    const hostGlobalSnapshot = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)({\n        name: origin.options.name,\n        version: origin.options.version\n    });\n    // get remote detail info from global\n    const globalRemoteInfo = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.n)(hostGlobalSnapshot.remotesInfo, moduleInfo.name).value;\n    if (globalRemoteInfo && globalRemoteInfo.matchedVersion) {\n        return {\n            hostGlobalSnapshot,\n            globalSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(),\n            remoteSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)({\n                name: moduleInfo.name,\n                version: globalRemoteInfo.matchedVersion\n            })\n        };\n    }\n    return {\n        hostGlobalSnapshot: undefined,\n        globalSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)(),\n        remoteSnapshot: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)({\n            name: moduleInfo.name,\n            version: 'version' in moduleInfo ? moduleInfo.version : undefined\n        })\n    };\n}\nclass SnapshotHandler {\n    async loadSnapshot(moduleInfo) {\n        const { options } = this.HostInstance;\n        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);\n        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({\n            options,\n            moduleInfo,\n            hostGlobalSnapshot,\n            remoteSnapshot,\n            globalSnapshot\n        });\n        return {\n            remoteSnapshot: globalRemoteSnapshot,\n            globalSnapshot: globalSnapshotRes\n        };\n    }\n    // eslint-disable-next-line max-lines-per-function\n    async loadRemoteSnapshotInfo(moduleInfo) {\n        const { options } = this.HostInstance;\n        await this.hooks.lifecycle.beforeLoadRemoteSnapshot.emit({\n            options,\n            moduleInfo\n        });\n        let hostSnapshot = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)({\n            name: this.HostInstance.options.name,\n            version: this.HostInstance.options.version\n        });\n        if (!hostSnapshot) {\n            hostSnapshot = {\n                version: this.HostInstance.options.version || '',\n                remoteEntry: '',\n                remotesInfo: {}\n            };\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)({\n                [this.HostInstance.options.name]: hostSnapshot\n            });\n        }\n        // In dynamic loadRemote scenarios, incomplete remotesInfo delivery may occur. In such cases, the remotesInfo in the host needs to be completed in the snapshot at runtime.\n        // This ensures the snapshot's integrity and helps the chrome plugin correctly identify all producer modules, ensuring that proxyable producer modules will not be missing.\n        if (hostSnapshot && 'remotesInfo' in hostSnapshot && !(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.n)(hostSnapshot.remotesInfo, moduleInfo.name).value) {\n            if ('version' in moduleInfo || 'entry' in moduleInfo) {\n                hostSnapshot.remotesInfo = _extends$3({}, hostSnapshot == null ? void 0 : hostSnapshot.remotesInfo, {\n                    [moduleInfo.name]: {\n                        matchedVersion: 'version' in moduleInfo ? moduleInfo.version : moduleInfo.entry\n                    }\n                });\n            }\n        }\n        const { hostGlobalSnapshot, remoteSnapshot, globalSnapshot } = this.getGlobalRemoteInfo(moduleInfo);\n        const { remoteSnapshot: globalRemoteSnapshot, globalSnapshot: globalSnapshotRes } = await this.hooks.lifecycle.loadSnapshot.emit({\n            options,\n            moduleInfo,\n            hostGlobalSnapshot,\n            remoteSnapshot,\n            globalSnapshot\n        });\n        // global snapshot includes manifest or module info includes manifest\n        if (globalRemoteSnapshot) {\n            if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isManifestProvider)(globalRemoteSnapshot)) {\n                const remoteEntry = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.m)() ? globalRemoteSnapshot.remoteEntry : globalRemoteSnapshot.ssrRemoteEntry || globalRemoteSnapshot.remoteEntry || '';\n                const moduleSnapshot = await this.getManifestJson(remoteEntry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(_extends$3({}, moduleInfo, {\n                    // The global remote may be overridden\n                    // Therefore, set the snapshot key to the global address of the actual request\n                    entry: remoteEntry\n                }), moduleSnapshot);\n                return {\n                    remoteSnapshot: moduleSnapshot,\n                    globalSnapshot: globalSnapshotRes\n                };\n            } else {\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: globalRemoteSnapshot,\n                    from: 'global'\n                });\n                return {\n                    remoteSnapshot: remoteSnapshotRes,\n                    globalSnapshot: globalSnapshotRes\n                };\n            }\n        } else {\n            if ((0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.j)(moduleInfo)) {\n                // get from manifest.json and merge remote info from remote server\n                const moduleSnapshot = await this.getManifestJson(moduleInfo.entry, moduleInfo, {});\n                // eslint-disable-next-line @typescript-eslint/no-shadow\n                const globalSnapshotRes = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.v)(moduleInfo, moduleSnapshot);\n                const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                    options: this.HostInstance.options,\n                    moduleInfo,\n                    remoteSnapshot: moduleSnapshot,\n                    from: 'global'\n                });\n                return {\n                    remoteSnapshot: remoteSnapshotRes,\n                    globalSnapshot: globalSnapshotRes\n                };\n            } else {\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`\n          Cannot get remoteSnapshot with the name: '${moduleInfo.name}', version: '${moduleInfo.version}' from __FEDERATION__.moduleInfo. The following reasons may be causing the problem:\\n\n          1. The Deploy platform did not deliver the correct data. You can use __FEDERATION__.moduleInfo to check the remoteInfo.\\n\n          2. The remote '${moduleInfo.name}' version '${moduleInfo.version}' is not released.\\n\n          The transformed module info: ${JSON.stringify(globalSnapshotRes)}\n        `);\n            }\n        }\n    }\n    getGlobalRemoteInfo(moduleInfo) {\n        return getGlobalRemoteInfo(moduleInfo, this.HostInstance);\n    }\n    async getManifestJson(manifestUrl, moduleInfo, extraOptions) {\n        const getManifest = async ()=>{\n            let manifestJson = this.manifestCache.get(manifestUrl);\n            if (manifestJson) {\n                return manifestJson;\n            }\n            try {\n                let res = await this.loaderHook.lifecycle.fetch.emit(manifestUrl, {});\n                if (!res || !(res instanceof Response)) {\n                    res = await fetch(manifestUrl, {});\n                }\n                manifestJson = await res.json();\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(manifestJson.metaData && manifestJson.exposes && manifestJson.shared, `${manifestUrl} is not a federation manifest`);\n                this.manifestCache.set(manifestUrl, manifestJson);\n                return manifestJson;\n            } catch (err) {\n                delete this.manifestLoading[manifestUrl];\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.f)(`Failed to get manifestJson for ${moduleInfo.name}. The manifest URL is ${manifestUrl}. Please ensure that the manifestUrl is accessible.\n          \\n Error message:\n          \\n ${err}`);\n            }\n        };\n        const asyncLoadProcess = async ()=>{\n            const manifestJson = await getManifest();\n            const remoteSnapshot = (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.generateSnapshotFromManifest)(manifestJson, {\n                version: manifestUrl\n            });\n            const { remoteSnapshot: remoteSnapshotRes } = await this.hooks.lifecycle.loadRemoteSnapshot.emit({\n                options: this.HostInstance.options,\n                moduleInfo,\n                manifestJson,\n                remoteSnapshot,\n                manifestUrl,\n                from: 'manifest'\n            });\n            return remoteSnapshotRes;\n        };\n        if (!this.manifestLoading[manifestUrl]) {\n            this.manifestLoading[manifestUrl] = asyncLoadProcess().then((res)=>res);\n        }\n        return this.manifestLoading[manifestUrl];\n    }\n    constructor(HostInstance){\n        this.loadingHostSnapshot = null;\n        this.manifestCache = new Map();\n        this.hooks = new PluginSystem({\n            beforeLoadRemoteSnapshot: new AsyncHook('beforeLoadRemoteSnapshot'),\n            loadSnapshot: new AsyncWaterfallHook('loadGlobalSnapshot'),\n            loadRemoteSnapshot: new AsyncWaterfallHook('loadRemoteSnapshot')\n        });\n        this.manifestLoading = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.G.__FEDERATION__.__MANIFEST_LOADING__;\n        this.HostInstance = HostInstance;\n        this.loaderHook = HostInstance.loaderHook;\n    }\n}\n\nfunction _extends$2() {\n    _extends$2 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$2.apply(this, arguments);\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nclass SharedHandler {\n    // register shared in shareScopeMap\n    registerShared(globalOptions, userOptions) {\n        const { shareInfos, shared } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)(globalOptions, userOptions);\n        const sharedKeys = Object.keys(shareInfos);\n        sharedKeys.forEach((sharedKey)=>{\n            const sharedVals = shareInfos[sharedKey];\n            sharedVals.forEach((sharedVal)=>{\n                const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.shareScopeMap, sharedKey, sharedVal, this.hooks.lifecycle.resolveShare);\n                if (!registeredShared && sharedVal && sharedVal.lib) {\n                    this.setShared({\n                        pkgName: sharedKey,\n                        lib: sharedVal.lib,\n                        get: sharedVal.get,\n                        loaded: true,\n                        shared: sharedVal,\n                        from: userOptions.name\n                    });\n                }\n            });\n        });\n        return {\n            shareInfos,\n            shared\n        };\n    }\n    async loadShare(pkgName, extraOptions) {\n        const { host } = this;\n        // This function performs the following steps:\n        // 1. Checks if the currently loaded share already exists, if not, it throws an error\n        // 2. Searches globally for a matching share, if found, it uses it directly\n        // 3. If not found, it retrieves it from the current share and stores the obtained share globally.\n        const shareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareInfo == null ? void 0 : shareInfo.scope) {\n            await Promise.all(shareInfo.scope.map(async (shareScope)=>{\n                await Promise.all(this.initializeSharing(shareScope, {\n                    strategy: shareInfo.strategy\n                }));\n                return;\n            }));\n        }\n        const loadShareRes = await this.hooks.lifecycle.beforeLoadShare.emit({\n            pkgName,\n            shareInfo,\n            shared: host.options.shared,\n            origin: host\n        });\n        const { shareInfo: shareInfoRes } = loadShareRes;\n        // Assert that shareInfoRes exists, if not, throw an error\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(shareInfoRes, `Cannot find ${pkgName} Share in the ${host.options.name}. Please ensure that the ${pkgName} Share parameters have been injected`);\n        // Retrieve from cache\n        const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.B)(shared.useIn, host.options.name);\n        };\n        if (registeredShared && registeredShared.lib) {\n            addUseIn(registeredShared);\n            return registeredShared.lib;\n        } else if (registeredShared && registeredShared.loading && !registeredShared.loaded) {\n            const factory = await registeredShared.loading;\n            registeredShared.loaded = true;\n            if (!registeredShared.lib) {\n                registeredShared.lib = factory;\n            }\n            addUseIn(registeredShared);\n            return factory;\n        } else if (registeredShared) {\n            const asyncLoadProcess = async ()=>{\n                const factory = await registeredShared.get();\n                shareInfoRes.lib = factory;\n                shareInfoRes.loaded = true;\n                addUseIn(shareInfoRes);\n                const gShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n                if (gShared) {\n                    gShared.lib = factory;\n                    gShared.loaded = true;\n                }\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: registeredShared,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        } else {\n            if (extraOptions == null ? void 0 : extraOptions.customShareInfo) {\n                return false;\n            }\n            const asyncLoadProcess = async ()=>{\n                const factory = await shareInfoRes.get();\n                shareInfoRes.lib = factory;\n                shareInfoRes.loaded = true;\n                addUseIn(shareInfoRes);\n                const gShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.shareScopeMap, pkgName, shareInfoRes, this.hooks.lifecycle.resolveShare);\n                if (gShared) {\n                    gShared.lib = factory;\n                    gShared.loaded = true;\n                }\n                return factory;\n            };\n            const loading = asyncLoadProcess();\n            this.setShared({\n                pkgName,\n                loaded: false,\n                shared: shareInfoRes,\n                from: host.options.name,\n                lib: null,\n                loading\n            });\n            return loading;\n        }\n    }\n    /**\n   * This function initializes the sharing sequence (executed only once per share scope).\n   * It accepts one argument, the name of the share scope.\n   * If the share scope does not exist, it creates one.\n   */ // eslint-disable-next-line @typescript-eslint/member-ordering\n    initializeSharing(shareScopeName = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b, extraOptions) {\n        const { host } = this;\n        const from = extraOptions == null ? void 0 : extraOptions.from;\n        const strategy = extraOptions == null ? void 0 : extraOptions.strategy;\n        let initScope = extraOptions == null ? void 0 : extraOptions.initScope;\n        const promises = [];\n        if (from !== 'build') {\n            const { initTokens } = this;\n            if (!initScope) initScope = [];\n            let initToken = initTokens[shareScopeName];\n            if (!initToken) initToken = initTokens[shareScopeName] = {\n                from: this.host.name\n            };\n            if (initScope.indexOf(initToken) >= 0) return promises;\n            initScope.push(initToken);\n        }\n        const shareScope = this.shareScopeMap;\n        const hostName = host.options.name;\n        // Creates a new share scope if necessary\n        if (!shareScope[shareScopeName]) {\n            shareScope[shareScopeName] = {};\n        }\n        // Executes all initialization snippets from all accessible modules\n        const scope = shareScope[shareScopeName];\n        const register = (name, shared)=>{\n            var _activeVersion_shareConfig;\n            const { version, eager } = shared;\n            scope[name] = scope[name] || {};\n            const versions = scope[name];\n            const activeVersion = versions[version];\n            const activeVersionEager = Boolean(activeVersion && (activeVersion.eager || ((_activeVersion_shareConfig = activeVersion.shareConfig) == null ? void 0 : _activeVersion_shareConfig.eager)));\n            if (!activeVersion || activeVersion.strategy !== 'loaded-first' && !activeVersion.loaded && (Boolean(!eager) !== !activeVersionEager ? eager : hostName > activeVersion.from)) {\n                versions[version] = shared;\n            }\n        };\n        const initFn = (mod)=>mod && mod.init && mod.init(shareScope[shareScopeName], initScope);\n        const initRemoteModule = async (key)=>{\n            const { module } = await host.remoteHandler.getRemoteModuleAndOptions({\n                id: key\n            });\n            if (module.getEntry) {\n                const entry = await module.getEntry();\n                if (!module.inited) {\n                    await initFn(entry);\n                    module.inited = true;\n                }\n            }\n        };\n        Object.keys(host.options.shared).forEach((shareName)=>{\n            const sharedArr = host.options.shared[shareName];\n            sharedArr.forEach((shared)=>{\n                if (shared.scope.includes(shareScopeName)) {\n                    register(shareName, shared);\n                }\n            });\n        });\n        // TODO: strategy==='version-first' need to be removed in the future\n        if (host.options.shareStrategy === 'version-first' || strategy === 'version-first') {\n            host.options.remotes.forEach((remote)=>{\n                if (remote.shareScope === shareScopeName) {\n                    promises.push(initRemoteModule(remote.name));\n                }\n            });\n        }\n        return promises;\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        const { host } = this;\n        const shareInfo = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)({\n            pkgName,\n            extraOptions,\n            shareInfos: host.options.shared\n        });\n        if (shareInfo == null ? void 0 : shareInfo.scope) {\n            shareInfo.scope.forEach((shareScope)=>{\n                this.initializeSharing(shareScope, {\n                    strategy: shareInfo.strategy\n                });\n            });\n        }\n        const registeredShared = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)(this.shareScopeMap, pkgName, shareInfo, this.hooks.lifecycle.resolveShare);\n        const addUseIn = (shared)=>{\n            if (!shared.useIn) {\n                shared.useIn = [];\n            }\n            (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.B)(shared.useIn, host.options.name);\n        };\n        if (registeredShared) {\n            if (typeof registeredShared.lib === 'function') {\n                addUseIn(registeredShared);\n                if (!registeredShared.loaded) {\n                    registeredShared.loaded = true;\n                    if (registeredShared.from === host.options.name) {\n                        shareInfo.loaded = true;\n                    }\n                }\n                return registeredShared.lib;\n            }\n            if (typeof registeredShared.get === 'function') {\n                const module = registeredShared.get();\n                if (!(module instanceof Promise)) {\n                    addUseIn(registeredShared);\n                    this.setShared({\n                        pkgName,\n                        loaded: true,\n                        from: host.options.name,\n                        lib: module,\n                        shared: registeredShared\n                    });\n                    return module;\n                }\n            }\n        }\n        if (shareInfo.lib) {\n            if (!shareInfo.loaded) {\n                shareInfo.loaded = true;\n            }\n            return shareInfo.lib;\n        }\n        if (shareInfo.get) {\n            const module = shareInfo.get();\n            if (module instanceof Promise) {\n                throw new Error(`\n        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.\n        Possible reasons for failure: \\n\n        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\\n\n        2. The ${pkgName} share was not registered with the 'lib' attribute.\\n\n      `);\n            }\n            shareInfo.lib = module;\n            this.setShared({\n                pkgName,\n                loaded: true,\n                from: host.options.name,\n                lib: shareInfo.lib,\n                shared: shareInfo\n            });\n            return shareInfo.lib;\n        }\n        throw new Error(`\n        The loadShareSync function was unable to load ${pkgName}. The ${pkgName} could not be found in ${host.options.name}.\n        Possible reasons for failure: \\n\n        1. The ${pkgName} share was registered with the 'get' attribute, but loadShare was not used beforehand.\\n\n        2. The ${pkgName} share was not registered with the 'lib' attribute.\\n\n      `);\n    }\n    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {\n        const { host } = this;\n        this.shareScopeMap[scopeName] = shareScope;\n        this.hooks.lifecycle.initContainerShareScopeMap.emit({\n            shareScope,\n            options: host.options,\n            origin: host,\n            scopeName,\n            hostShareScopeMap: extraOptions.hostShareScopeMap\n        });\n    }\n    setShared({ pkgName, shared, from, lib, loading, loaded, get }) {\n        const { version, scope = 'default' } = shared, shareInfo = _object_without_properties_loose(shared, [\n            \"version\",\n            \"scope\"\n        ]);\n        const scopes = Array.isArray(scope) ? scope : [\n            scope\n        ];\n        scopes.forEach((sc)=>{\n            if (!this.shareScopeMap[sc]) {\n                this.shareScopeMap[sc] = {};\n            }\n            if (!this.shareScopeMap[sc][pkgName]) {\n                this.shareScopeMap[sc][pkgName] = {};\n            }\n            if (this.shareScopeMap[sc][pkgName][version]) {\n                return;\n            }\n            this.shareScopeMap[sc][pkgName][version] = _extends$2({\n                version,\n                scope: [\n                    'default'\n                ]\n            }, shareInfo, {\n                lib,\n                loaded,\n                loading\n            });\n            if (get) {\n                this.shareScopeMap[sc][pkgName][version].get = get;\n            }\n        });\n    }\n    _setGlobalShareScopeMap(hostOptions) {\n        const globalShareScopeMap = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)();\n        const identifier = hostOptions.id || hostOptions.name;\n        if (identifier && !globalShareScopeMap[identifier]) {\n            globalShareScopeMap[identifier] = this.shareScopeMap;\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            afterResolve: new AsyncWaterfallHook('afterResolve'),\n            beforeLoadShare: new AsyncWaterfallHook('beforeLoadShare'),\n            // not used yet\n            loadShare: new AsyncHook(),\n            resolveShare: new SyncWaterfallHook('resolveShare'),\n            // maybe will change, temporarily for internal use only\n            initContainerShareScopeMap: new SyncWaterfallHook('initContainerShareScopeMap')\n        });\n        this.host = host;\n        this.shareScopeMap = {};\n        this.initTokens = {};\n        this._setGlobalShareScopeMap(host.options);\n    }\n}\n\nfunction _extends$1() {\n    _extends$1 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$1.apply(this, arguments);\n}\nclass RemoteHandler {\n    formatAndRegisterRemote(globalOptions, userOptions) {\n        const userRemotes = userOptions.remotes || [];\n        return userRemotes.reduce((res, remote)=>{\n            this.registerRemote(remote, res, {\n                force: false\n            });\n            return res;\n        }, globalOptions.remotes);\n    }\n    setIdToRemoteMap(id, remoteMatchInfo) {\n        const { remote, expose } = remoteMatchInfo;\n        const { name, alias } = remote;\n        this.idToRemoteMap[id] = {\n            name: remote.name,\n            expose\n        };\n        if (alias && id.startsWith(name)) {\n            const idWithAlias = id.replace(name, alias);\n            this.idToRemoteMap[idWithAlias] = {\n                name: remote.name,\n                expose\n            };\n            return;\n        }\n        if (alias && id.startsWith(alias)) {\n            const idWithName = id.replace(alias, name);\n            this.idToRemoteMap[idWithName] = {\n                name: remote.name,\n                expose\n            };\n        }\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        const { host } = this;\n        try {\n            const { loadFactory = true } = options || {\n                loadFactory: true\n            };\n            // 1. Validate the parameters of the retrieved module. There are two module request methods: pkgName + expose and alias + expose.\n            // 2. Request the snapshot information of the current host and globally store the obtained snapshot information. The retrieved module information is partially offline and partially online. The online module information will retrieve the modules used online.\n            // 3. Retrieve the detailed information of the current module from global (remoteEntry address, expose resource address)\n            // 4. After retrieving remoteEntry, call the init of the module, and then retrieve the exported content of the module through get\n            // id: pkgName(@federation/app1) + expose(button) = @federation/app1/button\n            // id: alias(app1) + expose(button) = app1/button\n            // id: alias(app1/utils) + expose(loadash/sort) = app1/utils/loadash/sort\n            const { module, moduleOptions, remoteMatchInfo } = await this.getRemoteModuleAndOptions({\n                id\n            });\n            const { pkgNameOrAlias, remote, expose, id: idRes } = remoteMatchInfo;\n            const moduleOrFactory = await module.get(idRes, expose, options);\n            const moduleWrapper = await this.hooks.lifecycle.onLoad.emit({\n                id: idRes,\n                pkgNameOrAlias,\n                expose,\n                exposeModule: loadFactory ? moduleOrFactory : undefined,\n                exposeModuleFactory: loadFactory ? undefined : moduleOrFactory,\n                remote,\n                options: moduleOptions,\n                moduleInstance: module,\n                origin: host\n            });\n            this.setIdToRemoteMap(id, remoteMatchInfo);\n            if (typeof moduleWrapper === 'function') {\n                return moduleWrapper;\n            }\n            return moduleOrFactory;\n        } catch (error) {\n            const { from = 'runtime' } = options || {\n                from: 'runtime'\n            };\n            const failOver = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                error,\n                from,\n                lifecycle: 'onLoad',\n                origin: host\n            });\n            if (!failOver) {\n                throw error;\n            }\n            return failOver;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        const { host } = this;\n        await this.hooks.lifecycle.beforePreloadRemote.emit({\n            preloadOps: preloadOptions,\n            options: host.options,\n            origin: host\n        });\n        const preloadOps = formatPreloadArgs(host.options.remotes, preloadOptions);\n        await Promise.all(preloadOps.map(async (ops)=>{\n            const { remote } = ops;\n            const remoteInfo = getRemoteInfo(remote);\n            const { globalSnapshot, remoteSnapshot } = await host.snapshotHandler.loadRemoteSnapshotInfo(remote);\n            const assets = await this.hooks.lifecycle.generatePreloadAssets.emit({\n                origin: host,\n                preloadOptions: ops,\n                remote,\n                remoteInfo,\n                globalSnapshot,\n                remoteSnapshot\n            });\n            if (!assets) {\n                return;\n            }\n            preloadAssets(remoteInfo, host, assets);\n        }));\n    }\n    registerRemotes(remotes, options) {\n        const { host } = this;\n        remotes.forEach((remote)=>{\n            this.registerRemote(remote, host.options.remotes, {\n                force: options == null ? void 0 : options.force\n            });\n        });\n    }\n    async getRemoteModuleAndOptions(options) {\n        const { host } = this;\n        const { id } = options;\n        let loadRemoteArgs;\n        try {\n            loadRemoteArgs = await this.hooks.lifecycle.beforeRequest.emit({\n                id,\n                options: host.options,\n                origin: host\n            });\n        } catch (error) {\n            loadRemoteArgs = await this.hooks.lifecycle.errorLoadRemote.emit({\n                id,\n                options: host.options,\n                origin: host,\n                from: 'runtime',\n                error,\n                lifecycle: 'beforeRequest'\n            });\n            if (!loadRemoteArgs) {\n                throw error;\n            }\n        }\n        const { id: idRes } = loadRemoteArgs;\n        const remoteSplitInfo = matchRemoteWithNameAndExpose(host.options.remotes, idRes);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remoteSplitInfo, `\n        Unable to locate ${idRes} in ${host.options.name}. Potential reasons for failure include:\\n\n        1. ${idRes} was not included in the 'remotes' parameter of ${host.options.name || 'the host'}.\\n\n        2. ${idRes} could not be found in the 'remotes' of ${host.options.name} with either 'name' or 'alias' attributes.\n        3. ${idRes} is not online, injected, or loaded.\n        4. ${idRes}  cannot be accessed on the expected.\n        5. The 'beforeRequest' hook was provided but did not return the correct 'remoteInfo' when attempting to load ${idRes}.\n      `);\n        const { remote: rawRemote } = remoteSplitInfo;\n        const remoteInfo = getRemoteInfo(rawRemote);\n        const matchInfo = await host.sharedHandler.hooks.lifecycle.afterResolve.emit(_extends$1({\n            id: idRes\n        }, remoteSplitInfo, {\n            options: host.options,\n            origin: host,\n            remoteInfo\n        }));\n        const { remote, expose } = matchInfo;\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(remote && expose, `The 'beforeRequest' hook was executed, but it failed to return the correct 'remote' and 'expose' values while loading ${idRes}.`);\n        let module = host.moduleCache.get(remote.name);\n        const moduleOptions = {\n            host: host,\n            remoteInfo\n        };\n        if (!module) {\n            module = new Module(moduleOptions);\n            host.moduleCache.set(remote.name, module);\n        }\n        return {\n            module,\n            moduleOptions,\n            remoteMatchInfo: matchInfo\n        };\n    }\n    registerRemote(remote, targetRemotes, options) {\n        const { host } = this;\n        const normalizeRemote = ()=>{\n            if (remote.alias) {\n                // Validate if alias equals the prefix of remote.name and remote.alias, if so, throw an error\n                // As multi-level path references cannot guarantee unique names, alias being a prefix of remote.name is not supported\n                const findEqual = targetRemotes.find((item)=>{\n                    var _item_alias;\n                    return remote.alias && (item.name.startsWith(remote.alias) || ((_item_alias = item.alias) == null ? void 0 : _item_alias.startsWith(remote.alias)));\n                });\n                (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(!findEqual, `The alias ${remote.alias} of remote ${remote.name} is not allowed to be the prefix of ${findEqual && findEqual.name} name or alias`);\n            }\n            // Set the remote entry to a complete path\n            if ('entry' in remote) {\n                if ((0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.isBrowserEnv)() && !remote.entry.startsWith('http')) {\n                    remote.entry = new URL(remote.entry, window.location.origin).href;\n                }\n            }\n            if (!remote.shareScope) {\n                remote.shareScope = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b;\n            }\n            if (!remote.type) {\n                remote.type = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.D;\n            }\n        };\n        this.hooks.lifecycle.beforeRegisterRemote.emit({\n            remote,\n            origin: host\n        });\n        const registeredRemote = targetRemotes.find((item)=>item.name === remote.name);\n        if (!registeredRemote) {\n            normalizeRemote();\n            targetRemotes.push(remote);\n            this.hooks.lifecycle.registerRemote.emit({\n                remote,\n                origin: host\n            });\n        } else {\n            const messages = [\n                `The remote \"${remote.name}\" is already registered.`,\n                (options == null ? void 0 : options.force) ? 'Hope you have known that OVERRIDE it may have some unexpected errors' : 'If you want to merge the remote, you can set \"force: true\".'\n            ];\n            if (options == null ? void 0 : options.force) {\n                // remove registered remote\n                this.removeRemote(registeredRemote);\n                normalizeRemote();\n                targetRemotes.push(remote);\n                this.hooks.lifecycle.registerRemote.emit({\n                    remote,\n                    origin: host\n                });\n            }\n            (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.warn)(messages.join(' '));\n        }\n    }\n    removeRemote(remote) {\n        try {\n            const { host } = this;\n            const { name } = remote;\n            const remoteIndex = host.options.remotes.findIndex((item)=>item.name === name);\n            if (remoteIndex !== -1) {\n                host.options.remotes.splice(remoteIndex, 1);\n            }\n            const loadedModule = host.moduleCache.get(remote.name);\n            if (loadedModule) {\n                const remoteInfo = loadedModule.remoteInfo;\n                const key = remoteInfo.entryGlobalName;\n                if (globalThis[key]) {\n                    var _Object_getOwnPropertyDescriptor;\n                    if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(globalThis, key)) == null ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {\n                        delete globalThis[key];\n                    } else {\n                        // @ts-ignore\n                        globalThis[key] = undefined;\n                    }\n                }\n                const remoteEntryUniqueKey = getRemoteEntryUniqueKey(loadedModule.remoteInfo);\n                if (_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[remoteEntryUniqueKey]) {\n                    delete _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.a[remoteEntryUniqueKey];\n                }\n                host.snapshotHandler.manifestCache.delete(remoteInfo.entry);\n                // delete unloaded shared and instance\n                let remoteInsId = remoteInfo.buildVersion ? (0,_module_federation_sdk__WEBPACK_IMPORTED_MODULE_1__.composeKeyWithSeparator)(remoteInfo.name, remoteInfo.buildVersion) : remoteInfo.name;\n                const remoteInsIndex = globalThis.__FEDERATION__.__INSTANCES__.findIndex((ins)=>{\n                    if (remoteInfo.buildVersion) {\n                        return ins.options.id === remoteInsId;\n                    } else {\n                        return ins.name === remoteInsId;\n                    }\n                });\n                if (remoteInsIndex !== -1) {\n                    const remoteIns = globalThis.__FEDERATION__.__INSTANCES__[remoteInsIndex];\n                    remoteInsId = remoteIns.options.id || remoteInsId;\n                    const globalShareScopeMap = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)();\n                    let isAllSharedNotUsed = true;\n                    const needDeleteKeys = [];\n                    Object.keys(globalShareScopeMap).forEach((instId)=>{\n                        const shareScopeMap = globalShareScopeMap[instId];\n                        shareScopeMap && Object.keys(shareScopeMap).forEach((shareScope)=>{\n                            const shareScopeVal = shareScopeMap[shareScope];\n                            shareScopeVal && Object.keys(shareScopeVal).forEach((shareName)=>{\n                                const sharedPkgs = shareScopeVal[shareName];\n                                sharedPkgs && Object.keys(sharedPkgs).forEach((shareVersion)=>{\n                                    const shared = sharedPkgs[shareVersion];\n                                    if (shared && typeof shared === 'object' && shared.from === remoteInfo.name) {\n                                        if (shared.loaded || shared.loading) {\n                                            shared.useIn = shared.useIn.filter((usedHostName)=>usedHostName !== remoteInfo.name);\n                                            if (shared.useIn.length) {\n                                                isAllSharedNotUsed = false;\n                                            } else {\n                                                needDeleteKeys.push([\n                                                    instId,\n                                                    shareScope,\n                                                    shareName,\n                                                    shareVersion\n                                                ]);\n                                            }\n                                        } else {\n                                            needDeleteKeys.push([\n                                                instId,\n                                                shareScope,\n                                                shareName,\n                                                shareVersion\n                                            ]);\n                                        }\n                                    }\n                                });\n                            });\n                        });\n                    });\n                    if (isAllSharedNotUsed) {\n                        remoteIns.shareScopeMap = {};\n                        delete globalShareScopeMap[remoteInsId];\n                    }\n                    needDeleteKeys.forEach(([insId, shareScope, shareName, shareVersion])=>{\n                        var _globalShareScopeMap_insId_shareScope_shareName, _globalShareScopeMap_insId_shareScope, _globalShareScopeMap_insId;\n                        (_globalShareScopeMap_insId = globalShareScopeMap[insId]) == null ? true : (_globalShareScopeMap_insId_shareScope = _globalShareScopeMap_insId[shareScope]) == null ? true : (_globalShareScopeMap_insId_shareScope_shareName = _globalShareScopeMap_insId_shareScope[shareName]) == null ? true : delete _globalShareScopeMap_insId_shareScope_shareName[shareVersion];\n                    });\n                    globalThis.__FEDERATION__.__INSTANCES__.splice(remoteInsIndex, 1);\n                }\n                const { hostGlobalSnapshot } = getGlobalRemoteInfo(remote, host);\n                if (hostGlobalSnapshot) {\n                    const remoteKey = hostGlobalSnapshot && 'remotesInfo' in hostGlobalSnapshot && hostGlobalSnapshot.remotesInfo && (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.n)(hostGlobalSnapshot.remotesInfo, remote.name).key;\n                    if (remoteKey) {\n                        delete hostGlobalSnapshot.remotesInfo[remoteKey];\n                        if (Boolean(_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.G.__FEDERATION__.__MANIFEST_LOADING__[remoteKey])) {\n                            delete _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.G.__FEDERATION__.__MANIFEST_LOADING__[remoteKey];\n                        }\n                    }\n                }\n                host.moduleCache.delete(remote.name);\n            }\n        } catch (err) {\n            console.log('removeRemote fail: ', err);\n        }\n    }\n    constructor(host){\n        this.hooks = new PluginSystem({\n            beforeRegisterRemote: new SyncWaterfallHook('beforeRegisterRemote'),\n            registerRemote: new SyncWaterfallHook('registerRemote'),\n            beforeRequest: new AsyncWaterfallHook('beforeRequest'),\n            onLoad: new AsyncHook('onLoad'),\n            handlePreloadModule: new SyncHook('handlePreloadModule'),\n            errorLoadRemote: new AsyncHook('errorLoadRemote'),\n            beforePreloadRemote: new AsyncHook('beforePreloadRemote'),\n            generatePreloadAssets: new AsyncHook('generatePreloadAssets'),\n            // not used yet\n            afterPreloadRemote: new AsyncHook(),\n            loadEntry: new AsyncHook()\n        });\n        this.host = host;\n        this.idToRemoteMap = {};\n    }\n}\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nclass FederationHost {\n    initOptions(userOptions) {\n        this.registerPlugins(userOptions.plugins);\n        const options = this.formatOptions(this.options, userOptions);\n        this.options = options;\n        return options;\n    }\n    async loadShare(pkgName, extraOptions) {\n        return this.sharedHandler.loadShare(pkgName, extraOptions);\n    }\n    // The lib function will only be available if the shared set by eager or runtime init is set or the shared is successfully loaded.\n    // 1. If the loaded shared already exists globally, then it will be reused\n    // 2. If lib exists in local shared, it will be used directly\n    // 3. If the local get returns something other than Promise, then it will be used directly\n    loadShareSync(pkgName, extraOptions) {\n        return this.sharedHandler.loadShareSync(pkgName, extraOptions);\n    }\n    initializeSharing(shareScopeName = _share_esm_js__WEBPACK_IMPORTED_MODULE_0__.b, extraOptions) {\n        return this.sharedHandler.initializeSharing(shareScopeName, extraOptions);\n    }\n    initRawContainer(name, url, container) {\n        const remoteInfo = getRemoteInfo({\n            name,\n            entry: url\n        });\n        const module = new Module({\n            host: this,\n            remoteInfo\n        });\n        module.remoteEntryExports = container;\n        this.moduleCache.set(name, module);\n        return module;\n    }\n    // eslint-disable-next-line max-lines-per-function\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async loadRemote(id, options) {\n        return this.remoteHandler.loadRemote(id, options);\n    }\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    async preloadRemote(preloadOptions) {\n        return this.remoteHandler.preloadRemote(preloadOptions);\n    }\n    initShareScopeMap(scopeName, shareScope, extraOptions = {}) {\n        this.sharedHandler.initShareScopeMap(scopeName, shareScope, extraOptions);\n    }\n    formatOptions(globalOptions, userOptions) {\n        const { shared } = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.y)(globalOptions, userOptions);\n        const { userOptions: userOptionsRes, options: globalOptionsRes } = this.hooks.lifecycle.beforeInit.emit({\n            origin: this,\n            userOptions,\n            options: globalOptions,\n            shareInfo: shared\n        });\n        const remotes = this.remoteHandler.formatAndRegisterRemote(globalOptionsRes, userOptionsRes);\n        const { shared: handledShared } = this.sharedHandler.registerShared(globalOptionsRes, userOptionsRes);\n        const plugins = [\n            ...globalOptionsRes.plugins\n        ];\n        if (userOptionsRes.plugins) {\n            userOptionsRes.plugins.forEach((plugin)=>{\n                if (!plugins.includes(plugin)) {\n                    plugins.push(plugin);\n                }\n            });\n        }\n        const optionsRes = _extends({}, globalOptions, userOptions, {\n            plugins,\n            remotes,\n            shared: handledShared\n        });\n        this.hooks.lifecycle.init.emit({\n            origin: this,\n            options: optionsRes\n        });\n        return optionsRes;\n    }\n    registerPlugins(plugins) {\n        const pluginRes = registerPlugins$1(plugins, [\n            this.hooks,\n            this.remoteHandler.hooks,\n            this.sharedHandler.hooks,\n            this.snapshotHandler.hooks,\n            this.loaderHook\n        ]);\n        // Merge plugin\n        this.options.plugins = this.options.plugins.reduce((res, plugin)=>{\n            if (!plugin) return res;\n            if (res && !res.find((item)=>item.name === plugin.name)) {\n                res.push(plugin);\n            }\n            return res;\n        }, pluginRes || []);\n    }\n    registerRemotes(remotes, options) {\n        return this.remoteHandler.registerRemotes(remotes, options);\n    }\n    constructor(userOptions){\n        this.hooks = new PluginSystem({\n            beforeInit: new SyncWaterfallHook('beforeInit'),\n            init: new SyncHook(),\n            // maybe will change, temporarily for internal use only\n            beforeInitContainer: new AsyncWaterfallHook('beforeInitContainer'),\n            // maybe will change, temporarily for internal use only\n            initContainer: new AsyncWaterfallHook('initContainer')\n        });\n        this.version = \"0.5.2\";\n        this.moduleCache = new Map();\n        this.loaderHook = new PluginSystem({\n            // FIXME: may not be suitable , not open to the public yet\n            getModuleInfo: new SyncHook(),\n            createScript: new SyncHook(),\n            createLink: new SyncHook(),\n            // only work for manifest , so not open to the public yet\n            fetch: new AsyncHook()\n        });\n        // TODO: Validate the details of the options\n        // Initialize options with default values\n        const defaultOptions = {\n            id: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.C)(),\n            name: userOptions.name,\n            plugins: [\n                snapshotPlugin(),\n                generatePreloadAssetsPlugin()\n            ],\n            remotes: [],\n            shared: {},\n            inBrowser: (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.m)()\n        };\n        this.name = userOptions.name;\n        this.options = defaultOptions;\n        this.snapshotHandler = new SnapshotHandler(this);\n        this.sharedHandler = new SharedHandler(this);\n        this.remoteHandler = new RemoteHandler(this);\n        this.shareScopeMap = this.sharedHandler.shareScopeMap;\n        this.registerPlugins([\n            ...defaultOptions.plugins,\n            ...userOptions.plugins || []\n        ]);\n        this.options = this.formatOptions(defaultOptions, userOptions);\n    }\n}\n\nlet FederationInstance = null;\nfunction init(options) {\n    // Retrieve the same instance with the same name\n    const instance = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.F)(options.name, options.version);\n    if (!instance) {\n        // Retrieve debug constructor\n        const FederationConstructor = (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.H)() || FederationHost;\n        FederationInstance = new FederationConstructor(options);\n        (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.I)(FederationInstance);\n        return FederationInstance;\n    } else {\n        // Merge options\n        instance.initOptions(options);\n        if (!FederationInstance) {\n            FederationInstance = instance;\n        }\n        return instance;\n    }\n}\nfunction loadRemote(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    const loadRemote1 = FederationInstance.loadRemote;\n    // eslint-disable-next-line prefer-spread\n    return loadRemote1.apply(FederationInstance, args);\n}\nfunction loadShare(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    const loadShare1 = FederationInstance.loadShare;\n    return loadShare1.apply(FederationInstance, args);\n}\nfunction loadShareSync(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    const loadShareSync1 = FederationInstance.loadShareSync;\n    // eslint-disable-next-line prefer-spread\n    return loadShareSync1.apply(FederationInstance, args);\n}\nfunction preloadRemote(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.preloadRemote.apply(FederationInstance, args);\n}\nfunction registerRemotes(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerRemotes.apply(FederationInstance, args);\n}\nfunction registerPlugins(...args) {\n    (0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(FederationInstance, 'Please call init first');\n    // eslint-disable-next-line prefer-spread\n    return FederationInstance.registerPlugins.apply(FederationInstance, args);\n}\nfunction getInstance() {\n    return FederationInstance;\n}\n// Inject for debug\n(0,_share_esm_js__WEBPACK_IMPORTED_MODULE_0__.E)(FederationHost);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0MkI7QUFDaHpCO0FBQzJKO0FBQ25KOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnREFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE1BQU07QUFDbEU7QUFD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QUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdEQUEyQjtBQUNoRDtBQUNBO0FBQ0Esc0NBQXNDLGdEQUE4QjtBQUNwRTtBQUNBLFFBQVEsZ0RBQTJCO0FBQ25DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUE4Qjs7QUFFcUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGUvLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUvZGlzdC9pbmRleC5lc20uanM/NTAzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnIGFzIGdldEdsb2JhbEhvc3RQbHVnaW5zLCBhIGFzIGdsb2JhbExvYWRpbmcsIEQgYXMgREVGQVVMVF9SRU1PVEVfVFlQRSwgYiBhcyBERUZBVUxUX1NDT1BFLCBjIGFzIGdldFJlbW90ZUVudHJ5RXhwb3J0cywgZCBhcyBhc3NlcnQsIHMgYXMgc2FmZVRvU3RyaW5nLCBlIGFzIGdldEZNSWQsIGkgYXMgaXNPYmplY3QsIGYgYXMgZXJyb3IsIHcgYXMgd2FybiwgaCBhcyBpc1BsYWluT2JqZWN0LCBqIGFzIGlzUmVtb3RlSW5mb1dpdGhFbnRyeSwgayBhcyBpc1B1cmVSZW1vdGVFbnRyeSwgbCBhcyBnZXRSZW1vdGVFbnRyeUluZm9Gcm9tU25hcHNob3QsIG0gYXMgaXNCcm93c2VyRW52JDEsIG4gYXMgZ2V0SW5mb1dpdGhvdXRUeXBlLCBvIGFzIGdldFByZWxvYWRlZCwgcCBhcyBzZXRQcmVsb2FkZWQsIHEgYXMgZ2V0UmVnaXN0ZXJlZFNoYXJlLCByIGFzIGFycmF5T3B0aW9ucywgdCBhcyBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8sIHUgYXMgYWRkR2xvYmFsU25hcHNob3QsIHYgYXMgc2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvLCBHIGFzIEdsb2JhbCwgeCBhcyBnZXRHbG9iYWxTbmFwc2hvdCwgeSBhcyBmb3JtYXRTaGFyZUNvbmZpZ3MsIHogYXMgZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucywgQSBhcyBnZXRHbG9iYWxTaGFyZVNjb3BlLCBCIGFzIGFkZFVuaXF1ZUl0ZW0sIEMgYXMgZ2V0QnVpbGRlcklkLCBFIGFzIHNldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvciwgRiBhcyBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UsIEggYXMgZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yLCBJIGFzIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZSB9IGZyb20gJy4vc2hhcmUuZXNtLmpzJztcbmV4cG9ydCB7IEogYXMgcmVnaXN0ZXJHbG9iYWxQbHVnaW5zIH0gZnJvbSAnLi9zaGFyZS5lc20uanMnO1xuaW1wb3J0IHsgaXNCcm93c2VyRW52LCBsb2FkU2NyaXB0Tm9kZSwgY29tcG9zZUtleVdpdGhTZXBhcmF0b3IsIGxvYWRTY3JpcHQsIGNyZWF0ZUxpbmssIGNyZWF0ZVNjcmlwdCwgZ2V0UmVzb3VyY2VVcmwsIGlzTWFuaWZlc3RQcm92aWRlciwgZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCwgd2FybiBhcyB3YXJuJDEgfSBmcm9tICdAbW9kdWxlLWZlZGVyYXRpb24vc2RrJztcbmV4cG9ydCB7IGxvYWRTY3JpcHQsIGxvYWRTY3JpcHROb2RlIH0gZnJvbSAnQG1vZHVsZS1mZWRlcmF0aW9uL3Nkayc7XG5cbi8vIEZ1bmN0aW9uIHRvIG1hdGNoIGEgcmVtb3RlIHdpdGggaXRzIG5hbWUgYW5kIGV4cG9zZVxuLy8gaWQ6IHBrZ05hbWUoQGZlZGVyYXRpb24vYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IEBmZWRlcmF0aW9uL2FwcDEvYnV0dG9uXG4vLyBpZDogYWxpYXMoYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IGFwcDEvYnV0dG9uXG4vLyBpZDogYWxpYXMoYXBwMS91dGlscykgKyBleHBvc2UobG9hZGFzaC9zb3J0KSA9IGFwcDEvdXRpbHMvbG9hZGFzaC9zb3J0XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVdpdGhOYW1lQW5kRXhwb3NlKHJlbW90ZXMsIGlkKSB7XG4gICAgZm9yIChjb25zdCByZW1vdGUgb2YgcmVtb3Rlcyl7XG4gICAgICAgIC8vIG1hdGNoIHBrZ05hbWVcbiAgICAgICAgY29uc3QgaXNOYW1lTWF0Y2hlZCA9IGlkLnN0YXJ0c1dpdGgocmVtb3RlLm5hbWUpO1xuICAgICAgICBsZXQgZXhwb3NlID0gaWQucmVwbGFjZShyZW1vdGUubmFtZSwgJycpO1xuICAgICAgICBpZiAoaXNOYW1lTWF0Y2hlZCkge1xuICAgICAgICAgICAgaWYgKGV4cG9zZS5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwa2dOYW1lT3JBbGlhcyA9IHJlbW90ZS5uYW1lO1xuICAgICAgICAgICAgICAgIGV4cG9zZSA9IGAuJHtleHBvc2V9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHBvc2UgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGtnTmFtZU9yQWxpYXM6IHJlbW90ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBleHBvc2U6ICcuJyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXRjaCBhbGlhc1xuICAgICAgICBjb25zdCBpc0FsaWFzTWF0Y2hlZCA9IHJlbW90ZS5hbGlhcyAmJiBpZC5zdGFydHNXaXRoKHJlbW90ZS5hbGlhcyk7XG4gICAgICAgIGxldCBleHBvc2VXaXRoQWxpYXMgPSByZW1vdGUuYWxpYXMgJiYgaWQucmVwbGFjZShyZW1vdGUuYWxpYXMsICcnKTtcbiAgICAgICAgaWYgKHJlbW90ZS5hbGlhcyAmJiBpc0FsaWFzTWF0Y2hlZCkge1xuICAgICAgICAgICAgaWYgKGV4cG9zZVdpdGhBbGlhcyAmJiBleHBvc2VXaXRoQWxpYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGtnTmFtZU9yQWxpYXMgPSByZW1vdGUuYWxpYXM7XG4gICAgICAgICAgICAgICAgZXhwb3NlV2l0aEFsaWFzID0gYC4ke2V4cG9zZVdpdGhBbGlhc31gO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBrZ05hbWVPckFsaWFzLFxuICAgICAgICAgICAgICAgICAgICBleHBvc2U6IGV4cG9zZVdpdGhBbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwb3NlV2l0aEFsaWFzID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBrZ05hbWVPckFsaWFzOiByZW1vdGUuYWxpYXMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZTogJy4nLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn1cbi8vIEZ1bmN0aW9uIHRvIG1hdGNoIGEgcmVtb3RlIHdpdGggaXRzIG5hbWUgb3IgYWxpYXNcbmZ1bmN0aW9uIG1hdGNoUmVtb3RlKHJlbW90ZXMsIG5hbWVPckFsaWFzKSB7XG4gICAgZm9yIChjb25zdCByZW1vdGUgb2YgcmVtb3Rlcyl7XG4gICAgICAgIGNvbnN0IGlzTmFtZU1hdGNoZWQgPSBuYW1lT3JBbGlhcyA9PT0gcmVtb3RlLm5hbWU7XG4gICAgICAgIGlmIChpc05hbWVNYXRjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQWxpYXNNYXRjaGVkID0gcmVtb3RlLmFsaWFzICYmIG5hbWVPckFsaWFzID09PSByZW1vdGUuYWxpYXM7XG4gICAgICAgIGlmIChpc0FsaWFzTWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2lucyQxKHBsdWdpbnMsIGhvb2tJbnN0YW5jZXMpIHtcbiAgICBjb25zdCBnbG9iYWxQbHVnaW5zID0gZ2V0R2xvYmFsSG9zdFBsdWdpbnMoKTtcbiAgICAvLyBJbmNvcnBvcmF0ZSBnbG9iYWwgcGx1Z2luc1xuICAgIGlmIChnbG9iYWxQbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2xvYmFsUGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pPT57XG4gICAgICAgICAgICBpZiAocGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5maW5kKChpdGVtKT0+aXRlbS5uYW1lICE9PSBwbHVnaW4ubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwbHVnaW5zICYmIHBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbik9PntcbiAgICAgICAgICAgIGhvb2tJbnN0YW5jZXMuZm9yRWFjaCgoaG9va0luc3RhbmNlKT0+e1xuICAgICAgICAgICAgICAgIGhvb2tJbnN0YW5jZS5hcHBseVBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGx1Z2lucztcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMkNygpIHtcbiAgICBfZXh0ZW5kcyQ3ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzJDcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRFc21FbnRyeSh7IGVudHJ5LCByZW1vdGVFbnRyeUV4cG9ydHMgfSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFyZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXZhbFxuICAgICAgICAgICAgICAgIG5ldyBGdW5jdGlvbignY2FsbGJhY2tzJywgYGltcG9ydChcIiR7ZW50cnl9XCIpLnRoZW4oY2FsbGJhY2tzWzBdKS5jYXRjaChjYWxsYmFja3NbMV0pYCkoW1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZW1vdGVFbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRTeXN0ZW1Kc0VudHJ5KHsgZW50cnksIHJlbW90ZUVudHJ5RXhwb3J0cyB9KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1ldmFsXG4gICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdjYWxsYmFja3MnLCBgU3lzdGVtLmltcG9ydChcIiR7ZW50cnl9XCIpLnRoZW4oY2FsbGJhY2tzWzBdKS5jYXRjaChjYWxsYmFja3NbMV0pYCkoW1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZW1vdGVFbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRFbnRyeVNjcmlwdCh7IG5hbWUsIGdsb2JhbE5hbWUsIGVudHJ5LCBjcmVhdGVTY3JpcHRIb29rIH0pIHtcbiAgICBjb25zdCB7IGVudHJ5RXhwb3J0czogcmVtb3RlRW50cnlFeHBvcnRzIH0gPSBnZXRSZW1vdGVFbnRyeUV4cG9ydHMobmFtZSwgZ2xvYmFsTmFtZSk7XG4gICAgaWYgKHJlbW90ZUVudHJ5RXhwb3J0cykge1xuICAgICAgICByZXR1cm4gcmVtb3RlRW50cnlFeHBvcnRzO1xuICAgIH1cbiAgICByZXR1cm4gbG9hZFNjcmlwdChlbnRyeSwge1xuICAgICAgICBhdHRyczoge30sXG4gICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6ICh1cmwsIGF0dHJzKT0+e1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlU2NyaXB0SG9vay5lbWl0KHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXR0cnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MU2NyaXB0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3NjcmlwdCcgaW4gcmVzIHx8ICd0aW1lb3V0JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSkudGhlbigoKT0+e1xuICAgICAgICBjb25zdCB7IHJlbW90ZUVudHJ5S2V5LCBlbnRyeUV4cG9ydHMgfSA9IGdldFJlbW90ZUVudHJ5RXhwb3J0cyhuYW1lLCBnbG9iYWxOYW1lKTtcbiAgICAgICAgYXNzZXJ0KGVudHJ5RXhwb3J0cywgYFxuICAgICAgVW5hYmxlIHRvIHVzZSB0aGUgJHtuYW1lfSdzICcke2VudHJ5fScgVVJMIHdpdGggJHtyZW1vdGVFbnRyeUtleX0ncyBnbG9iYWxOYW1lIHRvIGdldCByZW1vdGVFbnRyeSBleHBvcnRzLlxuICAgICAgUG9zc2libGUgcmVhc29ucyBjb3VsZCBiZTpcXG5cbiAgICAgIDEuICcke2VudHJ5fScgaXMgbm90IHRoZSBjb3JyZWN0IFVSTCwgb3IgdGhlIHJlbW90ZUVudHJ5IHJlc291cmNlIG9yIG5hbWUgaXMgaW5jb3JyZWN0LlxcblxuICAgICAgMi4gJHtyZW1vdGVFbnRyeUtleX0gY2Fubm90IGJlIHVzZWQgdG8gZ2V0IHJlbW90ZUVudHJ5IGV4cG9ydHMgaW4gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgYCk7XG4gICAgICAgIHJldHVybiBlbnRyeUV4cG9ydHM7XG4gICAgfSkuY2F0Y2goKGUpPT57XG4gICAgICAgIHRocm93IGU7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBsb2FkRW50cnlEb20oeyByZW1vdGVJbmZvLCByZW1vdGVFbnRyeUV4cG9ydHMsIGNyZWF0ZVNjcmlwdEhvb2sgfSkge1xuICAgIGNvbnN0IHsgZW50cnksIGVudHJ5R2xvYmFsTmFtZTogZ2xvYmFsTmFtZSwgbmFtZSwgdHlwZSB9ID0gcmVtb3RlSW5mbztcbiAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgIGNhc2UgJ2VzbSc6XG4gICAgICAgIGNhc2UgJ21vZHVsZSc6XG4gICAgICAgICAgICByZXR1cm4gbG9hZEVzbUVudHJ5KHtcbiAgICAgICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdzeXN0ZW0nOlxuICAgICAgICAgICAgcmV0dXJuIGxvYWRTeXN0ZW1Kc0VudHJ5KHtcbiAgICAgICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGxvYWRFbnRyeVNjcmlwdCh7XG4gICAgICAgICAgICAgICAgZW50cnksXG4gICAgICAgICAgICAgICAgZ2xvYmFsTmFtZSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2tcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRFbnRyeU5vZGUoeyByZW1vdGVJbmZvLCBjcmVhdGVTY3JpcHRIb29rIH0pIHtcbiAgICBjb25zdCB7IGVudHJ5LCBlbnRyeUdsb2JhbE5hbWU6IGdsb2JhbE5hbWUsIG5hbWUgfSA9IHJlbW90ZUluZm87XG4gICAgY29uc3QgeyBlbnRyeUV4cG9ydHM6IHJlbW90ZUVudHJ5RXhwb3J0cyB9ID0gZ2V0UmVtb3RlRW50cnlFeHBvcnRzKG5hbWUsIGdsb2JhbE5hbWUpO1xuICAgIGlmIChyZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgcmV0dXJuIGxvYWRTY3JpcHROb2RlKGVudHJ5LCB7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZ2xvYmFsTmFtZVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVTY3JpcHRIb29rOiAodXJsLCBhdHRycyk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZVNjcmlwdEhvb2suZW1pdCh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoJ3VybCcgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pLnRoZW4oKCk9PntcbiAgICAgICAgY29uc3QgeyByZW1vdGVFbnRyeUtleSwgZW50cnlFeHBvcnRzIH0gPSBnZXRSZW1vdGVFbnRyeUV4cG9ydHMobmFtZSwgZ2xvYmFsTmFtZSk7XG4gICAgICAgIGFzc2VydChlbnRyeUV4cG9ydHMsIGBcbiAgICAgIFVuYWJsZSB0byB1c2UgdGhlICR7bmFtZX0ncyAnJHtlbnRyeX0nIFVSTCB3aXRoICR7cmVtb3RlRW50cnlLZXl9J3MgZ2xvYmFsTmFtZSB0byBnZXQgcmVtb3RlRW50cnkgZXhwb3J0cy5cbiAgICAgIFBvc3NpYmxlIHJlYXNvbnMgY291bGQgYmU6XFxuXG4gICAgICAxLiAnJHtlbnRyeX0nIGlzIG5vdCB0aGUgY29ycmVjdCBVUkwsIG9yIHRoZSByZW1vdGVFbnRyeSByZXNvdXJjZSBvciBuYW1lIGlzIGluY29ycmVjdC5cXG5cbiAgICAgIDIuICR7cmVtb3RlRW50cnlLZXl9IGNhbm5vdCBiZSB1c2VkIHRvIGdldCByZW1vdGVFbnRyeSBleHBvcnRzIGluIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgIGApO1xuICAgICAgICByZXR1cm4gZW50cnlFeHBvcnRzO1xuICAgIH0pLmNhdGNoKChlKT0+e1xuICAgICAgICB0aHJvdyBlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVtb3RlRW50cnlVbmlxdWVLZXkocmVtb3RlSW5mbykge1xuICAgIGNvbnN0IHsgZW50cnksIG5hbWUgfSA9IHJlbW90ZUluZm87XG4gICAgcmV0dXJuIGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yKG5hbWUsIGVudHJ5KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlbW90ZUVudHJ5KHsgb3JpZ2luLCByZW1vdGVFbnRyeUV4cG9ydHMsIHJlbW90ZUluZm8gfSkge1xuICAgIGNvbnN0IHVuaXF1ZUtleSA9IGdldFJlbW90ZUVudHJ5VW5pcXVlS2V5KHJlbW90ZUluZm8pO1xuICAgIGlmIChyZW1vdGVFbnRyeUV4cG9ydHMpIHtcbiAgICAgICAgcmV0dXJuIHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICB9XG4gICAgaWYgKCFnbG9iYWxMb2FkaW5nW3VuaXF1ZUtleV0pIHtcbiAgICAgICAgY29uc3QgbG9hZEVudHJ5SG9vayA9IG9yaWdpbi5yZW1vdGVIYW5kbGVyLmhvb2tzLmxpZmVjeWNsZS5sb2FkRW50cnk7XG4gICAgICAgIGlmIChsb2FkRW50cnlIb29rLmxpc3RlbmVycy5zaXplKSB7XG4gICAgICAgICAgICBnbG9iYWxMb2FkaW5nW3VuaXF1ZUtleV0gPSBsb2FkRW50cnlIb29rLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2s6IG9yaWdpbi5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVTY3JpcHQsXG4gICAgICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pLnRoZW4oKHJlcyk9PnJlcyB8fCB1bmRlZmluZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlU2NyaXB0SG9vayA9IG9yaWdpbi5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVTY3JpcHQ7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldID0gbG9hZEVudHJ5Tm9kZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdEhvb2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9hZGluZ1t1bmlxdWVLZXldID0gbG9hZEVudHJ5RG9tKHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRIb29rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdsb2JhbExvYWRpbmdbdW5pcXVlS2V5XTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUluZm8ocmVtb3RlKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzJDcoe30sIHJlbW90ZSwge1xuICAgICAgICBlbnRyeTogJ2VudHJ5JyBpbiByZW1vdGUgPyByZW1vdGUuZW50cnkgOiAnJyxcbiAgICAgICAgdHlwZTogcmVtb3RlLnR5cGUgfHwgREVGQVVMVF9SRU1PVEVfVFlQRSxcbiAgICAgICAgZW50cnlHbG9iYWxOYW1lOiByZW1vdGUuZW50cnlHbG9iYWxOYW1lIHx8IHJlbW90ZS5uYW1lLFxuICAgICAgICBzaGFyZVNjb3BlOiByZW1vdGUuc2hhcmVTY29wZSB8fCBERUZBVUxUX1NDT1BFXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDYoKSB7XG4gICAgX2V4dGVuZHMkNiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQ2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5sZXQgTW9kdWxlID0gY2xhc3MgTW9kdWxlIHtcbiAgICBhc3luYyBnZXRFbnRyeSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVtb3RlRW50cnlFeHBvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJlbW90ZUVudHJ5LmpzXG4gICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5RXhwb3J0cyA9IGF3YWl0IGdldFJlbW90ZUVudHJ5KHtcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5ob3N0LFxuICAgICAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzOiB0aGlzLnJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0KHJlbW90ZUVudHJ5RXhwb3J0cywgYHJlbW90ZUVudHJ5RXhwb3J0cyBpcyB1bmRlZmluZWQgXFxuICR7c2FmZVRvU3RyaW5nKHRoaXMucmVtb3RlSW5mbyl9YCk7XG4gICAgICAgIHRoaXMucmVtb3RlRW50cnlFeHBvcnRzID0gcmVtb3RlRW50cnlFeHBvcnRzO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVFbnRyeUV4cG9ydHM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgYXN5bmMgZ2V0KGlkLCBleHBvc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBsb2FkRmFjdG9yeSA9IHRydWUgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgbG9hZEZhY3Rvcnk6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gR2V0IHJlbW90ZUVudHJ5LmpzXG4gICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5RXhwb3J0cyA9IGF3YWl0IHRoaXMuZ2V0RW50cnkoKTtcbiAgICAgICAgaWYgKCF0aGlzLmluaXRlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTaGFyZVNjb3BlTWFwID0gdGhpcy5ob3N0LnNoYXJlU2NvcGVNYXA7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVTaGFyZVNjb3BlID0gdGhpcy5yZW1vdGVJbmZvLnNoYXJlU2NvcGUgfHwgJ2RlZmF1bHQnO1xuICAgICAgICAgICAgaWYgKCFsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNoYXJlU2NvcGUgPSBsb2NhbFNoYXJlU2NvcGVNYXBbcmVtb3RlU2hhcmVTY29wZV07XG4gICAgICAgICAgICBjb25zdCBpbml0U2NvcGUgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5yZW1vdGVJbmZvLnZlcnNpb24gfHwgJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBIZWxwIHRvIGZpbmQgaG9zdCBpbnN0YW5jZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMsICdzaGFyZVNjb3BlTWFwJywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBsb2NhbFNoYXJlU2NvcGVNYXAsXG4gICAgICAgICAgICAgICAgLy8gcmVtb3RlRW50cnlJbml0T3B0aW9ucyB3aWxsIGJlIHRyYXZlcnNlZCBhbmQgYXNzaWduZWQgZHVyaW5nIGNvbnRhaW5lciBpbml0LCAsc28gdGhpcyBhdHRyaWJ1dGUgaXMgbm90IGFsbG93ZWQgdG8gYmUgdHJhdmVyc2VkXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaW5pdENvbnRhaW5lck9wdGlvbnMgPSBhd2FpdCB0aGlzLmhvc3QuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUluaXRDb250YWluZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgc2hhcmVTY29wZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHNoYXJlU2NvcGVNYXAgd2lsbCBiZSBzZXQgYnkgT2JqZWN0LmRlZmluZVByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmVtb3RlRW50cnlJbml0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbml0U2NvcGUsXG4gICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogdGhpcy5yZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogdGhpcy5ob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlbW90ZUVudHJ5RXhwb3J0cyA9PSBudWxsID8gdm9pZCAwIDogcmVtb3RlRW50cnlFeHBvcnRzLmluaXQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSByZW1vdGUgZW50cnkgaW50ZXJmYWNlIGRvZXMgbm90IGNvbnRhaW4gXCJpbml0XCInLCAnXFxuJywgJ0Vuc3VyZSB0aGUgbmFtZSBvZiB0aGlzIHJlbW90ZSBpcyBub3QgcmVzZXJ2ZWQgb3IgaW4gdXNlLiBDaGVjayBpZiBhbnl0aGluZyBhbHJlYWR5IGV4aXN0cyBvbiB3aW5kb3dbbmFtZU9mUmVtb3RlXScsICdcXG4nLCAnRW5zdXJlIHRoYXQgd2luZG93W25hbWVPZlJlbW90ZV0gaXMgcmV0dXJuaW5nIGEge2dldCxpbml0fSBvYmplY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCByZW1vdGVFbnRyeUV4cG9ydHMuaW5pdChpbml0Q29udGFpbmVyT3B0aW9ucy5zaGFyZVNjb3BlLCBpbml0Q29udGFpbmVyT3B0aW9ucy5pbml0U2NvcGUsIGluaXRDb250YWluZXJPcHRpb25zLnJlbW90ZUVudHJ5SW5pdE9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ob3N0Lmhvb2tzLmxpZmVjeWNsZS5pbml0Q29udGFpbmVyLmVtaXQoX2V4dGVuZHMkNih7fSwgaW5pdENvbnRhaW5lck9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeUV4cG9ydHNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpYiA9IHJlbW90ZUVudHJ5RXhwb3J0cztcbiAgICAgICAgdGhpcy5pbml0ZWQgPSB0cnVlO1xuICAgICAgICAvLyBnZXQgZXhwb3NlR2V0dGVyXG4gICAgICAgIGNvbnN0IG1vZHVsZUZhY3RvcnkgPSBhd2FpdCByZW1vdGVFbnRyeUV4cG9ydHMuZ2V0KGV4cG9zZSk7XG4gICAgICAgIGFzc2VydChtb2R1bGVGYWN0b3J5LCBgJHtnZXRGTUlkKHRoaXMucmVtb3RlSW5mbyl9IHJlbW90ZSBkb24ndCBleHBvcnQgJHtleHBvc2V9LmApO1xuICAgICAgICBjb25zdCB3cmFwTW9kdWxlRmFjdG9yeSA9IHRoaXMud3JhcGVyRmFjdG9yeShtb2R1bGVGYWN0b3J5LCBpZCk7XG4gICAgICAgIGlmICghbG9hZEZhY3RvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwTW9kdWxlRmFjdG9yeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBvc2VDb250ZW50ID0gYXdhaXQgd3JhcE1vZHVsZUZhY3RvcnkoKTtcbiAgICAgICAgcmV0dXJuIGV4cG9zZUNvbnRlbnQ7XG4gICAgfVxuICAgIHdyYXBlckZhY3RvcnkobW9kdWxlRmFjdG9yeSwgaWQpIHtcbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lTW9kdWxlSWQocmVzLCBpZCkge1xuICAgICAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHJlcykgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocmVzLCBTeW1ib2wuZm9yKCdtZl9tb2R1bGVfaWQnKSkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzLCBTeW1ib2wuZm9yKCdtZl9tb2R1bGVfaWQnKSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZHVsZUZhY3RvcnkgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtb2R1bGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBmb3IgYnJpZGdlIGRlYnVnZ2luZ1xuICAgICAgICAgICAgICAgIGRlZmluZU1vZHVsZUlkKHJlcywgaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gbW9kdWxlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGJyaWRnZSBkZWJ1Z2dpbmdcbiAgICAgICAgICAgICAgICBkZWZpbmVNb2R1bGVJZChyZXMsIGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IHJlbW90ZUluZm8sIGhvc3QgfSl7XG4gICAgICAgIHRoaXMuaW5pdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGliID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlbW90ZUluZm8gPSByZW1vdGVJbmZvO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgIH1cbn07XG5cbmNsYXNzIFN5bmNIb29rIHtcbiAgICBvbihmbikge1xuICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5hZGQoZm4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uY2UoZm4pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uKGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgICAgICAgICAgc2VsZi5yZW1vdmUod3JhcHBlcik7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1pdCguLi5kYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGZuKT0+e1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZuKC4uLmRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVtb3ZlKGZuKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShmbik7XG4gICAgfVxuICAgIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodHlwZSl7XG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFzeW5jSG9vayBleHRlbmRzIFN5bmNIb29rIHtcbiAgICBlbWl0KC4uLmRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3QgbHMgPSBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzKTtcbiAgICAgICAgaWYgKGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSAocHJldik9PntcbiAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBBYm9ydCBwcm9jZXNzXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobHNbaSsrXS5hcHBseShudWxsLCBkYXRhKSkudGhlbihjYWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBjaGVja1JldHVybkRhdGEob3JpZ2luYWxEYXRhLCByZXR1cm5lZERhdGEpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHJldHVybmVkRGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3JpZ2luYWxEYXRhICE9PSByZXR1cm5lZERhdGEpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gb3JpZ2luYWxEYXRhKXtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiByZXR1cm5lZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgU3luY1dhdGVyZmFsbEhvb2sgZXh0ZW5kcyBTeW5jSG9vayB7XG4gICAgZW1pdChkYXRhKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGVycm9yKGBUaGUgZGF0YSBmb3IgdGhlIFwiJHt0aGlzLnR5cGV9XCIgaG9vayBzaG91bGQgYmUgYW4gb2JqZWN0LmApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5saXN0ZW5lcnMpe1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wRGF0YSA9IGZuKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1JldHVybkRhdGEoZGF0YSwgdGVtcERhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0ZW1wRGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoYEEgcGx1Z2luIHJldHVybmVkIGFuIHVuYWNjZXB0YWJsZSB2YWx1ZSBmb3IgdGhlIFwiJHt0aGlzLnR5cGV9XCIgdHlwZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHdhcm4oZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxufVxuXG5jbGFzcyBBc3luY1dhdGVyZmFsbEhvb2sgZXh0ZW5kcyBTeW5jSG9vayB7XG4gICAgZW1pdChkYXRhKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGVycm9yKGBUaGUgcmVzcG9uc2UgZGF0YSBmb3IgdGhlIFwiJHt0aGlzLnR5cGV9XCIgaG9vayBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBscyA9IEFycmF5LmZyb20odGhpcy5saXN0ZW5lcnMpO1xuICAgICAgICBpZiAobHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGUpPT57XG4gICAgICAgICAgICAgICAgd2FybihlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbCA9IChwcmV2RGF0YSk9PntcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tSZXR1cm5EYXRhKGRhdGEsIHByZXZEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcHJldkRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobHNbaSsrXShkYXRhKSkudGhlbihjYWxsLCBwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoYEEgcGx1Z2luIHJldHVybmVkIGFuIGluY29ycmVjdCB2YWx1ZSBmb3IgdGhlIFwiJHt0aGlzLnR5cGV9XCIgdHlwZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWxsKGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxufVxuXG5jbGFzcyBQbHVnaW5TeXN0ZW0ge1xuICAgIGFwcGx5UGx1Z2luKHBsdWdpbikge1xuICAgICAgICBhc3NlcnQoaXNQbGFpbk9iamVjdChwbHVnaW4pLCAnUGx1Z2luIGNvbmZpZ3VyYXRpb24gaXMgaW52YWxpZC4nKTtcbiAgICAgICAgLy8gVGhlIHBsdWdpbidzIG5hbWUgaXMgbWFuZGF0b3J5IGFuZCBtdXN0IGJlIHVuaXF1ZVxuICAgICAgICBjb25zdCBwbHVnaW5OYW1lID0gcGx1Z2luLm5hbWU7XG4gICAgICAgIGFzc2VydChwbHVnaW5OYW1lLCAnQSBuYW1lIG11c3QgYmUgcHJvdmlkZWQgYnkgdGhlIHBsdWdpbi4nKTtcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyUGx1Z2luc1twbHVnaW5OYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW47XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmxpZmVjeWNsZSkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsdWdpbkxpZmUgPSBwbHVnaW5ba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luTGlmZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpZmVjeWNsZVtrZXldLm9uKHBsdWdpbkxpZmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVBsdWdpbihwbHVnaW5OYW1lKSB7XG4gICAgICAgIGFzc2VydChwbHVnaW5OYW1lLCAnQSBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnJlZ2lzdGVyUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgICAgYXNzZXJ0KHBsdWdpbiwgYFRoZSBwbHVnaW4gXCIke3BsdWdpbk5hbWV9XCIgaXMgbm90IHJlZ2lzdGVyZWQuYCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHBsdWdpbikuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ25hbWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saWZlY3ljbGVba2V5XS5yZW1vdmUocGx1Z2luW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICBpbmhlcml0KHsgbGlmZWN5Y2xlLCByZWdpc3RlclBsdWdpbnMgfSkge1xuICAgICAgICBPYmplY3Qua2V5cyhsaWZlY3ljbGUpLmZvckVhY2goKGhvb2tOYW1lKT0+e1xuICAgICAgICAgICAgYXNzZXJ0KCF0aGlzLmxpZmVjeWNsZVtob29rTmFtZV0sIGBUaGUgaG9vayBcIiR7aG9va05hbWV9XCIgaGFzIGEgY29uZmxpY3QgYW5kIGNhbm5vdCBiZSBpbmhlcml0ZWQuYCk7XG4gICAgICAgICAgICB0aGlzLmxpZmVjeWNsZVtob29rTmFtZV0gPSBsaWZlY3ljbGVbaG9va05hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmtleXMocmVnaXN0ZXJQbHVnaW5zKS5mb3JFYWNoKChwbHVnaW5OYW1lKT0+e1xuICAgICAgICAgICAgYXNzZXJ0KCF0aGlzLnJlZ2lzdGVyUGx1Z2luc1twbHVnaW5OYW1lXSwgYFRoZSBwbHVnaW4gXCIke3BsdWdpbk5hbWV9XCIgaGFzIGEgY29uZmxpY3QgYW5kIGNhbm5vdCBiZSBpbmhlcml0ZWQuYCk7XG4gICAgICAgICAgICB0aGlzLmFwcGx5UGx1Z2luKHJlZ2lzdGVyUGx1Z2luc1twbHVnaW5OYW1lXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihsaWZlY3ljbGUpe1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2lucyA9IHt9O1xuICAgICAgICB0aGlzLmxpZmVjeWNsZSA9IGxpZmVjeWNsZTtcbiAgICAgICAgdGhpcy5saWZlY3ljbGVLZXlzID0gT2JqZWN0LmtleXMobGlmZWN5Y2xlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDUoKSB7XG4gICAgX2V4dGVuZHMkNSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQ1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UHJlbG9hZEFyZ3MocHJlbG9hZENvbmZpZykge1xuICAgIHJldHVybiBfZXh0ZW5kcyQ1KHtcbiAgICAgICAgcmVzb3VyY2VDYXRlZ29yeTogJ3N5bmMnLFxuICAgICAgICBzaGFyZTogdHJ1ZSxcbiAgICAgICAgZGVwc1JlbW90ZTogdHJ1ZSxcbiAgICAgICAgcHJlZmV0Y2hJbnRlcmZhY2U6IGZhbHNlXG4gICAgfSwgcHJlbG9hZENvbmZpZyk7XG59XG5mdW5jdGlvbiBmb3JtYXRQcmVsb2FkQXJncyhyZW1vdGVzLCBwcmVsb2FkQXJncykge1xuICAgIHJldHVybiBwcmVsb2FkQXJncy5tYXAoKGFyZ3MpPT57XG4gICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBtYXRjaFJlbW90ZShyZW1vdGVzLCBhcmdzLm5hbWVPckFsaWFzKTtcbiAgICAgICAgYXNzZXJ0KHJlbW90ZUluZm8sIGBVbmFibGUgdG8gcHJlbG9hZCAke2FyZ3MubmFtZU9yQWxpYXN9IGFzIGl0IGlzIG5vdCBpbmNsdWRlZCBpbiAkeyFyZW1vdGVJbmZvICYmIHNhZmVUb1N0cmluZyh7XG4gICAgICAgICAgICByZW1vdGVJbmZvLFxuICAgICAgICAgICAgcmVtb3Rlc1xuICAgICAgICB9KX1gKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbW90ZTogcmVtb3RlSW5mbyxcbiAgICAgICAgICAgIHByZWxvYWRDb25maWc6IGRlZmF1bHRQcmVsb2FkQXJncyhhcmdzKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplUHJlbG9hZEV4cG9zZXMoZXhwb3Nlcykge1xuICAgIGlmICghZXhwb3Nlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBleHBvc2VzLm1hcCgoZXhwb3NlKT0+e1xuICAgICAgICBpZiAoZXhwb3NlID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9zZS5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3NlLnJlcGxhY2UoJy4vJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwcmVsb2FkQXNzZXRzKHJlbW90ZUluZm8sIGhvc3QsIGFzc2V0cywgLy8gSXQgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCBwcmVsb2FkIGZyb20gbG9hZCByZW1vdGUgcGFyYWxsZWwgbG9hZGluZ1xudXNlTGlua1ByZWxvYWQgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBjc3NBc3NldHMsIGpzQXNzZXRzV2l0aG91dEVudHJ5LCBlbnRyeUFzc2V0cyB9ID0gYXNzZXRzO1xuICAgIGlmIChob3N0Lm9wdGlvbnMuaW5Ccm93c2VyKSB7XG4gICAgICAgIGVudHJ5QXNzZXRzLmZvckVhY2goKGFzc2V0KT0+e1xuICAgICAgICAgICAgY29uc3QgeyBtb2R1bGVJbmZvIH0gPSBhc3NldDtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGhvc3QubW9kdWxlQ2FjaGUuZ2V0KHJlbW90ZUluZm8ubmFtZSk7XG4gICAgICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgZ2V0UmVtb3RlRW50cnkoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUluZm86IG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUVudHJ5RXhwb3J0czogbW9kdWxlLnJlbW90ZUVudHJ5RXhwb3J0c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRSZW1vdGVFbnRyeSh7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlSW5mbzogbW9kdWxlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlRW50cnlFeHBvcnRzOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1c2VMaW5rUHJlbG9hZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEF0dHJzID0ge1xuICAgICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICAgIGFzOiAnc3R5bGUnLFxuICAgICAgICAgICAgICAgIGNyb3Nzb3JpZ2luOiAnYW5vbnltb3VzJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNzc0Fzc2V0cy5mb3JFYWNoKChjc3NVcmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsaW5rOiBjc3NFbCwgbmVlZEF0dGFjaCB9ID0gY3JlYXRlTGluayh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogY3NzVXJsLFxuICAgICAgICAgICAgICAgICAgICBjYjogKCk9Pnt9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogZGVmYXVsdEF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVMaW5rSG9vazogKHVybCwgYXR0cnMpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBob3N0LmxvYWRlckhvb2subGlmZWN5Y2xlLmNyZWF0ZUxpbmsuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBIVE1MTGlua0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGNzc0VsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEF0dHJzID0ge1xuICAgICAgICAgICAgICAgIHJlbDogJ3N0eWxlc2hlZXQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0L2NzcydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjc3NBc3NldHMuZm9yRWFjaCgoY3NzVXJsKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGluazogY3NzRWwsIG5lZWRBdHRhY2ggfSA9IGNyZWF0ZUxpbmsoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGNzc1VybCxcbiAgICAgICAgICAgICAgICAgICAgY2I6ICgpPT57fSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IGRlZmF1bHRBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTGlua0hvb2s6ICh1cmwsIGF0dHJzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gaG9zdC5sb2FkZXJIb29rLmxpZmVjeWNsZS5jcmVhdGVMaW5rLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTExpbmtFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUxpbms6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGNzc0VsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VMaW5rUHJlbG9hZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEF0dHJzID0ge1xuICAgICAgICAgICAgICAgIHJlbDogJ3ByZWxvYWQnLFxuICAgICAgICAgICAgICAgIGFzOiAnc2NyaXB0JyxcbiAgICAgICAgICAgICAgICBjcm9zc29yaWdpbjogJ2Fub255bW91cydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeS5mb3JFYWNoKChqc1VybCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxpbms6IGxpbmtFbCwgbmVlZEF0dGFjaCB9ID0gY3JlYXRlTGluayh7XG4gICAgICAgICAgICAgICAgICAgIHVybDoganNVcmwsXG4gICAgICAgICAgICAgICAgICAgIGNiOiAoKT0+e30sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBkZWZhdWx0QXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUxpbmtIb29rOiAodXJsLCBhdHRycyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlTGluay5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEhUTUxMaW5rRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZWVkQXR0YWNoICYmIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGlua0VsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdEF0dHJzID0ge1xuICAgICAgICAgICAgICAgIGZldGNocHJpb3JpdHk6ICdoaWdoJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAocmVtb3RlSW5mbyA9PSBudWxsID8gdm9pZCAwIDogcmVtb3RlSW5mby50eXBlKSA9PT0gJ21vZHVsZScgPyAnbW9kdWxlJyA6ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAganNBc3NldHNXaXRob3V0RW50cnkuZm9yRWFjaCgoanNVcmwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY3JpcHQ6IHNjcmlwdEVsLCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVTY3JpcHQoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGpzVXJsLFxuICAgICAgICAgICAgICAgICAgICBjYjogKCk9Pnt9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogZGVmYXVsdEF0dHJzLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHRIb29rOiAodXJsLCBhdHRycyk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGhvc3QubG9hZGVySG9vay5saWZlY3ljbGUuY3JlYXRlU2NyaXB0LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBuZWVkRGVsZXRlU2NyaXB0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcyQ0KCkge1xuICAgIF9leHRlbmRzJDQgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gYXNzaWduUmVtb3RlSW5mbyhyZW1vdGVJbmZvLCByZW1vdGVTbmFwc2hvdCkge1xuICAgIGNvbnN0IHJlbW90ZUVudHJ5SW5mbyA9IGdldFJlbW90ZUVudHJ5SW5mb0Zyb21TbmFwc2hvdChyZW1vdGVTbmFwc2hvdCk7XG4gICAgaWYgKCFyZW1vdGVFbnRyeUluZm8udXJsKSB7XG4gICAgICAgIGVycm9yKGBUaGUgYXR0cmlidXRlIHJlbW90ZUVudHJ5IG9mICR7cmVtb3RlSW5mby5uYW1lfSBtdXN0IG5vdCBiZSB1bmRlZmluZWQuYCk7XG4gICAgfVxuICAgIGxldCBlbnRyeVVybCA9IGdldFJlc291cmNlVXJsKHJlbW90ZVNuYXBzaG90LCByZW1vdGVFbnRyeUluZm8udXJsKTtcbiAgICBpZiAoIWlzQnJvd3NlckVudiQxKCkgJiYgIWVudHJ5VXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgICAgICBlbnRyeVVybCA9IGBodHRwczoke2VudHJ5VXJsfWA7XG4gICAgfVxuICAgIHJlbW90ZUluZm8udHlwZSA9IHJlbW90ZUVudHJ5SW5mby50eXBlO1xuICAgIHJlbW90ZUluZm8uZW50cnlHbG9iYWxOYW1lID0gcmVtb3RlRW50cnlJbmZvLmdsb2JhbE5hbWU7XG4gICAgcmVtb3RlSW5mby5lbnRyeSA9IGVudHJ5VXJsO1xuICAgIHJlbW90ZUluZm8udmVyc2lvbiA9IHJlbW90ZVNuYXBzaG90LnZlcnNpb247XG4gICAgcmVtb3RlSW5mby5idWlsZFZlcnNpb24gPSByZW1vdGVTbmFwc2hvdC5idWlsZFZlcnNpb247XG59XG5mdW5jdGlvbiBzbmFwc2hvdFBsdWdpbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnc25hcHNob3QtcGx1Z2luJyxcbiAgICAgICAgYXN5bmMgYWZ0ZXJSZXNvbHZlIChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlbW90ZSwgcGtnTmFtZU9yQWxpYXMsIGV4cG9zZSwgb3JpZ2luLCByZW1vdGVJbmZvIH0gPSBhcmdzO1xuICAgICAgICAgICAgaWYgKCFpc1JlbW90ZUluZm9XaXRoRW50cnkocmVtb3RlKSB8fCAhaXNQdXJlUmVtb3RlRW50cnkocmVtb3RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3QsIGdsb2JhbFNuYXBzaG90IH0gPSBhd2FpdCBvcmlnaW4uc25hcHNob3RIYW5kbGVyLmxvYWRSZW1vdGVTbmFwc2hvdEluZm8ocmVtb3RlKTtcbiAgICAgICAgICAgICAgICBhc3NpZ25SZW1vdGVJbmZvKHJlbW90ZUluZm8sIHJlbW90ZVNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICAvLyBwcmVsb2FkaW5nIGFzc2V0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVPckFsaWFzOiBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9zZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZUNhdGVnb3J5OiAnc3luYycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzUmVtb3RlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCBvcmlnaW4ucmVtb3RlSGFuZGxlci5ob29rcy5saWZlY3ljbGUuZ2VuZXJhdGVQcmVsb2FkQXNzZXRzLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxTbmFwc2hvdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChhc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlbG9hZEFzc2V0cyhyZW1vdGVJbmZvLCBvcmlnaW4sIGFzc2V0cywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMkNCh7fSwgYXJncywge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBuYW1lXG4vLyBuYW1lOnZlcnNpb25cbmZ1bmN0aW9uIHNwbGl0SWQoaWQpIHtcbiAgICBjb25zdCBzcGxpdEluZm8gPSBpZC5zcGxpdCgnOicpO1xuICAgIGlmIChzcGxpdEluZm8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMF0sXG4gICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0SW5mby5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHNwbGl0SW5mb1swXSxcbiAgICAgICAgICAgIHZlcnNpb246IHNwbGl0SW5mb1sxXVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzcGxpdEluZm9bMV0sXG4gICAgICAgICAgICB2ZXJzaW9uOiBzcGxpdEluZm9bMl1cbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyBUcmF2ZXJzZSBhbGwgbm9kZXMgaW4gbW9kdWxlSW5mbyBhbmQgdHJhdmVyc2UgdGhlIGVudGlyZSBzbmFwc2hvdFxuZnVuY3Rpb24gdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCByZW1vdGVJbmZvLCB0cmF2ZXJzZSwgaXNSb290LCBtZW1vID0ge30sIHJlbW90ZVNuYXBzaG90KSB7XG4gICAgY29uc3QgaWQgPSBnZXRGTUlkKHJlbW90ZUluZm8pO1xuICAgIGNvbnN0IHsgdmFsdWU6IHNuYXBzaG90VmFsdWUgfSA9IGdldEluZm9XaXRob3V0VHlwZShnbG9iYWxTbmFwc2hvdCwgaWQpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90ID0gcmVtb3RlU25hcHNob3QgfHwgc25hcHNob3RWYWx1ZTtcbiAgICBpZiAoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QgJiYgIWlzTWFuaWZlc3RQcm92aWRlcihlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdCkpIHtcbiAgICAgICAgdHJhdmVyc2UoZWZmZWN0aXZlUmVtb3RlU25hcHNob3QsIHJlbW90ZUluZm8sIGlzUm9vdCk7XG4gICAgICAgIGlmIChlZmZlY3RpdmVSZW1vdGVTbmFwc2hvdC5yZW1vdGVzSW5mbykge1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlS2V5cyA9IE9iamVjdC5rZXlzKGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LnJlbW90ZXNJbmZvKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlbW90ZUtleXMpe1xuICAgICAgICAgICAgICAgIGlmIChtZW1vW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViUmVtb3RlSW5mbyA9IHNwbGl0SWQoa2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVWYWx1ZSA9IGVmZmVjdGl2ZVJlbW90ZVNuYXBzaG90LnJlbW90ZXNJbmZvW2tleV07XG4gICAgICAgICAgICAgICAgdHJhdmVyc2VNb2R1bGVJbmZvKGdsb2JhbFNuYXBzaG90LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN1YlJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogcmVtb3RlVmFsdWUubWF0Y2hlZFZlcnNpb25cbiAgICAgICAgICAgICAgICB9LCB0cmF2ZXJzZSwgZmFsc2UsIG1lbW8sIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuZnVuY3Rpb24gZ2VuZXJhdGVQcmVsb2FkQXNzZXRzKG9yaWdpbiwgcHJlbG9hZE9wdGlvbnMsIHJlbW90ZSwgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90KSB7XG4gICAgY29uc3QgY3NzQXNzZXRzID0gW107XG4gICAgY29uc3QganNBc3NldHMgPSBbXTtcbiAgICBjb25zdCBlbnRyeUFzc2V0cyA9IFtdO1xuICAgIGNvbnN0IGxvYWRlZFNoYXJlZEpzQXNzZXRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGxvYWRlZFNoYXJlZENzc0Fzc2V0cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IG9yaWdpbjtcbiAgICBjb25zdCB7IHByZWxvYWRDb25maWc6IHJvb3RQcmVsb2FkQ29uZmlnIH0gPSBwcmVsb2FkT3B0aW9ucztcbiAgICBjb25zdCB7IGRlcHNSZW1vdGUgfSA9IHJvb3RQcmVsb2FkQ29uZmlnO1xuICAgIGNvbnN0IG1lbW8gPSB7fTtcbiAgICB0cmF2ZXJzZU1vZHVsZUluZm8oZ2xvYmFsU25hcHNob3QsIHJlbW90ZSwgKG1vZHVsZUluZm9TbmFwc2hvdCwgcmVtb3RlSW5mbywgaXNSb290KT0+e1xuICAgICAgICBsZXQgcHJlbG9hZENvbmZpZztcbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgICAgcHJlbG9hZENvbmZpZyA9IHJvb3RQcmVsb2FkQ29uZmlnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVwc1JlbW90ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICAgICAgY29uc3QgZmluZFByZWxvYWRDb25maWcgPSBkZXBzUmVtb3RlLmZpbmQoKHJlbW90ZUNvbmZpZyk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZUNvbmZpZy5uYW1lT3JBbGlhcyA9PT0gcmVtb3RlSW5mby5uYW1lIHx8IHJlbW90ZUNvbmZpZy5uYW1lT3JBbGlhcyA9PT0gcmVtb3RlSW5mby5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghZmluZFByZWxvYWRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnID0gZGVmYXVsdFByZWxvYWRBcmdzKGZpbmRQcmVsb2FkQ29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwc1JlbW90ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHByZWxvYWRDb25maWcgPSByb290UHJlbG9hZENvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbW90ZUVudHJ5VXJsID0gZ2V0UmVzb3VyY2VVcmwobW9kdWxlSW5mb1NuYXBzaG90LCBnZXRSZW1vdGVFbnRyeUluZm9Gcm9tU25hcHNob3QobW9kdWxlSW5mb1NuYXBzaG90KS51cmwpO1xuICAgICAgICBpZiAocmVtb3RlRW50cnlVcmwpIHtcbiAgICAgICAgICAgIGVudHJ5QXNzZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZUluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZW50cnk6IHJlbW90ZUVudHJ5VXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVtb3RlRW50cnlUeXBlJyBpbiBtb2R1bGVJbmZvU25hcHNob3QgPyBtb2R1bGVJbmZvU25hcHNob3QucmVtb3RlRW50cnlUeXBlIDogJ2dsb2JhbCcsXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5R2xvYmFsTmFtZTogJ2dsb2JhbE5hbWUnIGluIG1vZHVsZUluZm9TbmFwc2hvdCA/IG1vZHVsZUluZm9TbmFwc2hvdC5nbG9iYWxOYW1lIDogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJ3ZlcnNpb24nIGluIG1vZHVsZUluZm9TbmFwc2hvdCA/IG1vZHVsZUluZm9TbmFwc2hvdC52ZXJzaW9uIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1cmw6IHJlbW90ZUVudHJ5VXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9kdWxlQXNzZXRzSW5mbyA9ICdtb2R1bGVzJyBpbiBtb2R1bGVJbmZvU25hcHNob3QgPyBtb2R1bGVJbmZvU25hcHNob3QubW9kdWxlcyA6IFtdO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkUHJlbG9hZEV4cG9zZXMgPSBub3JtYWxpemVQcmVsb2FkRXhwb3NlcyhwcmVsb2FkQ29uZmlnLmV4cG9zZXMpO1xuICAgICAgICBpZiAobm9ybWFsaXplZFByZWxvYWRFeHBvc2VzLmxlbmd0aCAmJiAnbW9kdWxlcycgaW4gbW9kdWxlSW5mb1NuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgX21vZHVsZUluZm9TbmFwc2hvdF9tb2R1bGVzO1xuICAgICAgICAgICAgbW9kdWxlQXNzZXRzSW5mbyA9IG1vZHVsZUluZm9TbmFwc2hvdCA9PSBudWxsID8gdm9pZCAwIDogKF9tb2R1bGVJbmZvU25hcHNob3RfbW9kdWxlcyA9IG1vZHVsZUluZm9TbmFwc2hvdC5tb2R1bGVzKSA9PSBudWxsID8gdm9pZCAwIDogX21vZHVsZUluZm9TbmFwc2hvdF9tb2R1bGVzLnJlZHVjZSgoYXNzZXRzLCBtb2R1bGVBc3NldEluZm8pPT57XG4gICAgICAgICAgICAgICAgaWYgKChub3JtYWxpemVkUHJlbG9hZEV4cG9zZXMgPT0gbnVsbCA/IHZvaWQgMCA6IG5vcm1hbGl6ZWRQcmVsb2FkRXhwb3Nlcy5pbmRleE9mKG1vZHVsZUFzc2V0SW5mby5tb2R1bGVOYW1lKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2V0cy5wdXNoKG1vZHVsZUFzc2V0SW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhc3NldHM7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQXNzZXRzKGFzc2V0cykge1xuICAgICAgICAgICAgY29uc3QgYXNzZXRzUmVzID0gYXNzZXRzLm1hcCgoYXNzZXQpPT5nZXRSZXNvdXJjZVVybChtb2R1bGVJbmZvU25hcHNob3QsIGFzc2V0KSk7XG4gICAgICAgICAgICBpZiAocHJlbG9hZENvbmZpZy5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzZXRzUmVzLmZpbHRlcihwcmVsb2FkQ29uZmlnLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNzZXRzUmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2R1bGVBc3NldHNJbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBhc3NldHNMZW5ndGggPSBtb2R1bGVBc3NldHNJbmZvLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFzc2V0c0xlbmd0aDsgaW5kZXgrKyl7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzZXRzSW5mbyA9IG1vZHVsZUFzc2V0c0luZm9baW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9zZUZ1bGxQYXRoID0gYCR7cmVtb3RlSW5mby5uYW1lfS8ke2Fzc2V0c0luZm8ubW9kdWxlTmFtZX1gO1xuICAgICAgICAgICAgICAgIG9yaWdpbi5yZW1vdGVIYW5kbGVyLmhvb2tzLmxpZmVjeWNsZS5oYW5kbGVQcmVsb2FkTW9kdWxlLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBpZDogYXNzZXRzSW5mby5tb2R1bGVOYW1lID09PSAnLicgPyByZW1vdGVJbmZvLm5hbWUgOiBleHBvc2VGdWxsUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlSW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogbW9kdWxlSW5mb1NuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGU6IHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWxvYWRlZCA9IGdldFByZWxvYWRlZChleHBvc2VGdWxsUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZWxvYWRDb25maWcucmVzb3VyY2VDYXRlZ29yeSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3NzQXNzZXRzLnB1c2goLi4uaGFuZGxlQXNzZXRzKGFzc2V0c0luZm8uYXNzZXRzLmNzcy5hc3luYykpO1xuICAgICAgICAgICAgICAgICAgICBjc3NBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuY3NzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuanMuYXN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuanMuc3luYykpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZWxvYWRDb25maWcucmVzb3VyY2VDYXRlZ29yeSA9ICdzeW5jJykge1xuICAgICAgICAgICAgICAgICAgICBjc3NBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuY3NzLnN5bmMpKTtcbiAgICAgICAgICAgICAgICAgICAganNBc3NldHMucHVzaCguLi5oYW5kbGVBc3NldHMoYXNzZXRzSW5mby5hc3NldHMuanMuc3luYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQcmVsb2FkZWQoZXhwb3NlRnVsbFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgdHJ1ZSwgbWVtbywgcmVtb3RlU25hcHNob3QpO1xuICAgIGlmIChyZW1vdGVTbmFwc2hvdC5zaGFyZWQpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdFNoYXJlZEFzc2V0cyA9IChzaGFyZUluZm8sIHNuYXBzaG90U2hhcmVkKT0+e1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNoYXJlZCA9IGdldFJlZ2lzdGVyZWRTaGFyZShvcmlnaW4uc2hhcmVTY29wZU1hcCwgc25hcHNob3RTaGFyZWQuc2hhcmVkTmFtZSwgc2hhcmVJbmZvLCBvcmlnaW4uc2hhcmVkSGFuZGxlci5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBnbG9iYWwgc2hhcmUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBsaWIgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QsIGl0IG1lYW5zIHRoYXQgdGhlIHNoYXJlZCBoYXMgbm90IGJlZW4gbG9hZGVkIHlldCBhbmQgY2FuIGJlIHByZWxvYWRlZC5cbiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkICYmIHR5cGVvZiByZWdpc3RlcmVkU2hhcmVkLmxpYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNuYXBzaG90U2hhcmVkLmFzc2V0cy5qcy5zeW5jLmZvckVhY2goKGFzc2V0KT0+e1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWRTaGFyZWRKc0Fzc2V0cy5hZGQoYXNzZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNuYXBzaG90U2hhcmVkLmFzc2V0cy5jc3Muc3luYy5mb3JFYWNoKChhc3NldCk9PntcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkU2hhcmVkQ3NzQXNzZXRzLmFkZChhc3NldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlbW90ZVNuYXBzaG90LnNoYXJlZC5mb3JFYWNoKChzaGFyZWQpPT57XG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2hhcmVkO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVJbmZvcyA9IChfb3B0aW9uc19zaGFyZWQgPSBvcHRpb25zLnNoYXJlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zX3NoYXJlZFtzaGFyZWQuc2hhcmVkTmFtZV07XG4gICAgICAgICAgICBpZiAoIXNoYXJlSW5mb3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBubyB2ZXJzaW9uLCBwcmVsb2FkIGFsbCBzaGFyZWRcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSBzaGFyZWQudmVyc2lvbiA/IHNoYXJlSW5mb3MuZmluZCgocyk9PnMudmVyc2lvbiA9PT0gc2hhcmVkLnZlcnNpb24pIDogc2hhcmVJbmZvcztcbiAgICAgICAgICAgIGlmICghc2hhcmVkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFycmF5U2hhcmVJbmZvID0gYXJyYXlPcHRpb25zKHNoYXJlZE9wdGlvbnMpO1xuICAgICAgICAgICAgYXJyYXlTaGFyZUluZm8uZm9yRWFjaCgocyk9PntcbiAgICAgICAgICAgICAgICBjb2xsZWN0U2hhcmVkQXNzZXRzKHMsIHNoYXJlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG5lZWRQcmVsb2FkSnNBc3NldHMgPSBqc0Fzc2V0cy5maWx0ZXIoKGFzc2V0KT0+IWxvYWRlZFNoYXJlZEpzQXNzZXRzLmhhcyhhc3NldCkpO1xuICAgIGNvbnN0IG5lZWRQcmVsb2FkQ3NzQXNzZXRzID0gY3NzQXNzZXRzLmZpbHRlcigoYXNzZXQpPT4hbG9hZGVkU2hhcmVkQ3NzQXNzZXRzLmhhcyhhc3NldCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNzc0Fzc2V0czogbmVlZFByZWxvYWRDc3NBc3NldHMsXG4gICAgICAgIGpzQXNzZXRzV2l0aG91dEVudHJ5OiBuZWVkUHJlbG9hZEpzQXNzZXRzLFxuICAgICAgICBlbnRyeUFzc2V0c1xuICAgIH07XG59XG5jb25zdCBnZW5lcmF0ZVByZWxvYWRBc3NldHNQbHVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnZ2VuZXJhdGUtcHJlbG9hZC1hc3NldHMtcGx1Z2luJyxcbiAgICAgICAgYXN5bmMgZ2VuZXJhdGVQcmVsb2FkQXNzZXRzIChhcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9yaWdpbiwgcHJlbG9hZE9wdGlvbnMsIHJlbW90ZUluZm8sIHJlbW90ZSwgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90IH0gPSBhcmdzO1xuICAgICAgICAgICAgaWYgKGlzUmVtb3RlSW5mb1dpdGhFbnRyeShyZW1vdGUpICYmIGlzUHVyZVJlbW90ZUVudHJ5KHJlbW90ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjc3NBc3NldHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBqc0Fzc2V0c1dpdGhvdXRFbnRyeTogW10sXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5QXNzZXRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByZW1vdGUuZW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByZW1vdGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5OiByZW1vdGUuZW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdnbG9iYWwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyeUdsb2JhbE5hbWU6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlOiAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25SZW1vdGVJbmZvKHJlbW90ZUluZm8sIHJlbW90ZVNuYXBzaG90KTtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0cyA9IGdlbmVyYXRlUHJlbG9hZEFzc2V0cyhvcmlnaW4sIHByZWxvYWRPcHRpb25zLCByZW1vdGVJbmZvLCBnbG9iYWxTbmFwc2hvdCwgcmVtb3RlU25hcHNob3QpO1xuICAgICAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBfZXh0ZW5kcyQzKCkge1xuICAgIF9leHRlbmRzJDMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsUmVtb3RlSW5mbyhtb2R1bGVJbmZvLCBvcmlnaW4pIHtcbiAgICBjb25zdCBob3N0R2xvYmFsU25hcHNob3QgPSBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICBuYW1lOiBvcmlnaW4ub3B0aW9ucy5uYW1lLFxuICAgICAgICB2ZXJzaW9uOiBvcmlnaW4ub3B0aW9ucy52ZXJzaW9uXG4gICAgfSk7XG4gICAgLy8gZ2V0IHJlbW90ZSBkZXRhaWwgaW5mbyBmcm9tIGdsb2JhbFxuICAgIGNvbnN0IGdsb2JhbFJlbW90ZUluZm8gPSBob3N0R2xvYmFsU25hcHNob3QgJiYgJ3JlbW90ZXNJbmZvJyBpbiBob3N0R2xvYmFsU25hcHNob3QgJiYgaG9zdEdsb2JhbFNuYXBzaG90LnJlbW90ZXNJbmZvICYmIGdldEluZm9XaXRob3V0VHlwZShob3N0R2xvYmFsU25hcHNob3QucmVtb3Rlc0luZm8sIG1vZHVsZUluZm8ubmFtZSkudmFsdWU7XG4gICAgaWYgKGdsb2JhbFJlbW90ZUluZm8gJiYgZ2xvYmFsUmVtb3RlSW5mby5tYXRjaGVkVmVyc2lvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdEdsb2JhbFNuYXBzaG90LFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3Q6IGdldEdsb2JhbFNuYXBzaG90KCksXG4gICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtb2R1bGVJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogZ2xvYmFsUmVtb3RlSW5mby5tYXRjaGVkVmVyc2lvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaG9zdEdsb2JhbFNuYXBzaG90OiB1bmRlZmluZWQsXG4gICAgICAgIGdsb2JhbFNuYXBzaG90OiBnZXRHbG9iYWxTbmFwc2hvdCgpLFxuICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKHtcbiAgICAgICAgICAgIG5hbWU6IG1vZHVsZUluZm8ubmFtZSxcbiAgICAgICAgICAgIHZlcnNpb246ICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvID8gbW9kdWxlSW5mby52ZXJzaW9uIDogdW5kZWZpbmVkXG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmNsYXNzIFNuYXBzaG90SGFuZGxlciB7XG4gICAgYXN5bmMgbG9hZFNuYXBzaG90KG1vZHVsZUluZm8pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLkhvc3RJbnN0YW5jZTtcbiAgICAgICAgY29uc3QgeyBob3N0R2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdCB9ID0gdGhpcy5nZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8pO1xuICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiBnbG9iYWxSZW1vdGVTbmFwc2hvdCwgZ2xvYmFsU25hcHNob3Q6IGdsb2JhbFNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgbW9kdWxlSW5mbyxcbiAgICAgICAgICAgIGhvc3RHbG9iYWxTbmFwc2hvdCxcbiAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgZ2xvYmFsU25hcHNob3RcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2xvYmFsUmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1saW5lcy1wZXItZnVuY3Rpb25cbiAgICBhc3luYyBsb2FkUmVtb3RlU25hcHNob3RJbmZvKG1vZHVsZUluZm8pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzLkhvc3RJbnN0YW5jZTtcbiAgICAgICAgYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlTG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG1vZHVsZUluZm9cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBob3N0U25hcHNob3QgPSBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8oe1xuICAgICAgICAgICAgbmFtZTogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy5Ib3N0SW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWhvc3RTbmFwc2hvdCkge1xuICAgICAgICAgICAgaG9zdFNuYXBzaG90ID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMudmVyc2lvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICByZW1vdGVFbnRyeTogJycsXG4gICAgICAgICAgICAgICAgcmVtb3Rlc0luZm86IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkR2xvYmFsU25hcHNob3Qoe1xuICAgICAgICAgICAgICAgIFt0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLm5hbWVdOiBob3N0U25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIGR5bmFtaWMgbG9hZFJlbW90ZSBzY2VuYXJpb3MsIGluY29tcGxldGUgcmVtb3Rlc0luZm8gZGVsaXZlcnkgbWF5IG9jY3VyLiBJbiBzdWNoIGNhc2VzLCB0aGUgcmVtb3Rlc0luZm8gaW4gdGhlIGhvc3QgbmVlZHMgdG8gYmUgY29tcGxldGVkIGluIHRoZSBzbmFwc2hvdCBhdCBydW50aW1lLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhlIHNuYXBzaG90J3MgaW50ZWdyaXR5IGFuZCBoZWxwcyB0aGUgY2hyb21lIHBsdWdpbiBjb3JyZWN0bHkgaWRlbnRpZnkgYWxsIHByb2R1Y2VyIG1vZHVsZXMsIGVuc3VyaW5nIHRoYXQgcHJveHlhYmxlIHByb2R1Y2VyIG1vZHVsZXMgd2lsbCBub3QgYmUgbWlzc2luZy5cbiAgICAgICAgaWYgKGhvc3RTbmFwc2hvdCAmJiAncmVtb3Rlc0luZm8nIGluIGhvc3RTbmFwc2hvdCAmJiAhZ2V0SW5mb1dpdGhvdXRUeXBlKGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbywgbW9kdWxlSW5mby5uYW1lKS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvIHx8ICdlbnRyeScgaW4gbW9kdWxlSW5mbykge1xuICAgICAgICAgICAgICAgIGhvc3RTbmFwc2hvdC5yZW1vdGVzSW5mbyA9IF9leHRlbmRzJDMoe30sIGhvc3RTbmFwc2hvdCA9PSBudWxsID8gdm9pZCAwIDogaG9zdFNuYXBzaG90LnJlbW90ZXNJbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgIFttb2R1bGVJbmZvLm5hbWVdOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbjogJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gPyBtb2R1bGVJbmZvLnZlcnNpb24gOiBtb2R1bGVJbmZvLmVudHJ5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGhvc3RHbG9iYWxTbmFwc2hvdCwgcmVtb3RlU25hcHNob3QsIGdsb2JhbFNuYXBzaG90IH0gPSB0aGlzLmdldEdsb2JhbFJlbW90ZUluZm8obW9kdWxlSW5mbyk7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IGdsb2JhbFJlbW90ZVNuYXBzaG90LCBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXMgfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgaG9zdEdsb2JhbFNuYXBzaG90LFxuICAgICAgICAgICAgcmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICBnbG9iYWxTbmFwc2hvdFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZ2xvYmFsIHNuYXBzaG90IGluY2x1ZGVzIG1hbmlmZXN0IG9yIG1vZHVsZSBpbmZvIGluY2x1ZGVzIG1hbmlmZXN0XG4gICAgICAgIGlmIChnbG9iYWxSZW1vdGVTbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKGlzTWFuaWZlc3RQcm92aWRlcihnbG9iYWxSZW1vdGVTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeSA9IGlzQnJvd3NlckVudiQxKCkgPyBnbG9iYWxSZW1vdGVTbmFwc2hvdC5yZW1vdGVFbnRyeSA6IGdsb2JhbFJlbW90ZVNuYXBzaG90LnNzclJlbW90ZUVudHJ5IHx8IGdsb2JhbFJlbW90ZVNuYXBzaG90LnJlbW90ZUVudHJ5IHx8ICcnO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNuYXBzaG90ID0gYXdhaXQgdGhpcy5nZXRNYW5pZmVzdEpzb24ocmVtb3RlRW50cnksIG1vZHVsZUluZm8sIHt9KTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNuYXBzaG90UmVzID0gc2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvKF9leHRlbmRzJDMoe30sIG1vZHVsZUluZm8sIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGdsb2JhbCByZW1vdGUgbWF5IGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCBzZXQgdGhlIHNuYXBzaG90IGtleSB0byB0aGUgZ2xvYmFsIGFkZHJlc3Mgb2YgdGhlIGFjdHVhbCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5OiByZW1vdGVFbnRyeVxuICAgICAgICAgICAgICAgIH0pLCBtb2R1bGVTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IG1vZHVsZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlbW90ZVNuYXBzaG90OiByZW1vdGVTbmFwc2hvdFJlcyB9ID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUubG9hZFJlbW90ZVNuYXBzaG90LmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogZ2xvYmFsUmVtb3RlU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgIGZyb206ICdnbG9iYWwnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzLFxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxTbmFwc2hvdDogZ2xvYmFsU25hcHNob3RSZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzUmVtb3RlSW5mb1dpdGhFbnRyeShtb2R1bGVJbmZvKSkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBmcm9tIG1hbmlmZXN0Lmpzb24gYW5kIG1lcmdlIHJlbW90ZSBpbmZvIGZyb20gcmVtb3RlIHNlcnZlclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZVNuYXBzaG90ID0gYXdhaXQgdGhpcy5nZXRNYW5pZmVzdEpzb24obW9kdWxlSW5mby5lbnRyeSwgbW9kdWxlSW5mbywge30pO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsU25hcHNob3RSZXMgPSBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8obW9kdWxlSW5mbywgbW9kdWxlU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVtb3RlU25hcHNob3Q6IHJlbW90ZVNuYXBzaG90UmVzIH0gPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5sb2FkUmVtb3RlU25hcHNob3QuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuSG9zdEluc3RhbmNlLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90OiBtb2R1bGVTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJ2dsb2JhbCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTbmFwc2hvdDogcmVtb3RlU25hcHNob3RSZXMsXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbFNuYXBzaG90OiBnbG9iYWxTbmFwc2hvdFJlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yKGBcbiAgICAgICAgICBDYW5ub3QgZ2V0IHJlbW90ZVNuYXBzaG90IHdpdGggdGhlIG5hbWU6ICcke21vZHVsZUluZm8ubmFtZX0nLCB2ZXJzaW9uOiAnJHttb2R1bGVJbmZvLnZlcnNpb259JyBmcm9tIF9fRkVERVJBVElPTl9fLm1vZHVsZUluZm8uIFRoZSBmb2xsb3dpbmcgcmVhc29ucyBtYXkgYmUgY2F1c2luZyB0aGUgcHJvYmxlbTpcXG5cbiAgICAgICAgICAxLiBUaGUgRGVwbG95IHBsYXRmb3JtIGRpZCBub3QgZGVsaXZlciB0aGUgY29ycmVjdCBkYXRhLiBZb3UgY2FuIHVzZSBfX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvIHRvIGNoZWNrIHRoZSByZW1vdGVJbmZvLlxcblxuICAgICAgICAgIDIuIFRoZSByZW1vdGUgJyR7bW9kdWxlSW5mby5uYW1lfScgdmVyc2lvbiAnJHttb2R1bGVJbmZvLnZlcnNpb259JyBpcyBub3QgcmVsZWFzZWQuXFxuXG4gICAgICAgICAgVGhlIHRyYW5zZm9ybWVkIG1vZHVsZSBpbmZvOiAke0pTT04uc3RyaW5naWZ5KGdsb2JhbFNuYXBzaG90UmVzKX1cbiAgICAgICAgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0R2xvYmFsUmVtb3RlSW5mbyhtb2R1bGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBnZXRHbG9iYWxSZW1vdGVJbmZvKG1vZHVsZUluZm8sIHRoaXMuSG9zdEluc3RhbmNlKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TWFuaWZlc3RKc29uKG1hbmlmZXN0VXJsLCBtb2R1bGVJbmZvLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2V0TWFuaWZlc3QgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgbGV0IG1hbmlmZXN0SnNvbiA9IHRoaXMubWFuaWZlc3RDYWNoZS5nZXQobWFuaWZlc3RVcmwpO1xuICAgICAgICAgICAgaWYgKG1hbmlmZXN0SnNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdEpzb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXMgPSBhd2FpdCB0aGlzLmxvYWRlckhvb2subGlmZWN5Y2xlLmZldGNoLmVtaXQobWFuaWZlc3RVcmwsIHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFVybCwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5pZmVzdEpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICAgICAgICAgIGFzc2VydChtYW5pZmVzdEpzb24ubWV0YURhdGEgJiYgbWFuaWZlc3RKc29uLmV4cG9zZXMgJiYgbWFuaWZlc3RKc29uLnNoYXJlZCwgYCR7bWFuaWZlc3RVcmx9IGlzIG5vdCBhIGZlZGVyYXRpb24gbWFuaWZlc3RgKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmlmZXN0Q2FjaGUuc2V0KG1hbmlmZXN0VXJsLCBtYW5pZmVzdEpzb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdEpzb247XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5tYW5pZmVzdExvYWRpbmdbbWFuaWZlc3RVcmxdO1xuICAgICAgICAgICAgICAgIGVycm9yKGBGYWlsZWQgdG8gZ2V0IG1hbmlmZXN0SnNvbiBmb3IgJHttb2R1bGVJbmZvLm5hbWV9LiBUaGUgbWFuaWZlc3QgVVJMIGlzICR7bWFuaWZlc3RVcmx9LiBQbGVhc2UgZW5zdXJlIHRoYXQgdGhlIG1hbmlmZXN0VXJsIGlzIGFjY2Vzc2libGUuXG4gICAgICAgICAgXFxuIEVycm9yIG1lc3NhZ2U6XG4gICAgICAgICAgXFxuICR7ZXJyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhc3luY0xvYWRQcm9jZXNzID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0SnNvbiA9IGF3YWl0IGdldE1hbmlmZXN0KCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVTbmFwc2hvdCA9IGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3QobWFuaWZlc3RKc29uLCB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogbWFuaWZlc3RVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyByZW1vdGVTbmFwc2hvdDogcmVtb3RlU25hcHNob3RSZXMgfSA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmxvYWRSZW1vdGVTbmFwc2hvdC5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB0aGlzLkhvc3RJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG1vZHVsZUluZm8sXG4gICAgICAgICAgICAgICAgbWFuaWZlc3RKc29uLFxuICAgICAgICAgICAgICAgIHJlbW90ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAgIG1hbmlmZXN0VXJsLFxuICAgICAgICAgICAgICAgIGZyb206ICdtYW5pZmVzdCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVNuYXBzaG90UmVzO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMubWFuaWZlc3RMb2FkaW5nW21hbmlmZXN0VXJsXSkge1xuICAgICAgICAgICAgdGhpcy5tYW5pZmVzdExvYWRpbmdbbWFuaWZlc3RVcmxdID0gYXN5bmNMb2FkUHJvY2VzcygpLnRoZW4oKHJlcyk9PnJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaWZlc3RMb2FkaW5nW21hbmlmZXN0VXJsXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoSG9zdEluc3RhbmNlKXtcbiAgICAgICAgdGhpcy5sb2FkaW5nSG9zdFNuYXBzaG90ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYW5pZmVzdENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmhvb2tzID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICAgICAgICBiZWZvcmVMb2FkUmVtb3RlU25hcHNob3Q6IG5ldyBBc3luY0hvb2soJ2JlZm9yZUxvYWRSZW1vdGVTbmFwc2hvdCcpLFxuICAgICAgICAgICAgbG9hZFNuYXBzaG90OiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdsb2FkR2xvYmFsU25hcHNob3QnKSxcbiAgICAgICAgICAgIGxvYWRSZW1vdGVTbmFwc2hvdDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnbG9hZFJlbW90ZVNuYXBzaG90JylcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFuaWZlc3RMb2FkaW5nID0gR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fTUFOSUZFU1RfTE9BRElOR19fO1xuICAgICAgICB0aGlzLkhvc3RJbnN0YW5jZSA9IEhvc3RJbnN0YW5jZTtcbiAgICAgICAgdGhpcy5sb2FkZXJIb29rID0gSG9zdEluc3RhbmNlLmxvYWRlckhvb2s7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcyQyKCkge1xuICAgIF9leHRlbmRzJDIgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMkMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmNsYXNzIFNoYXJlZEhhbmRsZXIge1xuICAgIC8vIHJlZ2lzdGVyIHNoYXJlZCBpbiBzaGFyZVNjb3BlTWFwXG4gICAgcmVnaXN0ZXJTaGFyZWQoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzaGFyZUluZm9zLCBzaGFyZWQgfSA9IGZvcm1hdFNoYXJlQ29uZmlncyhnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSBPYmplY3Qua2V5cyhzaGFyZUluZm9zKTtcbiAgICAgICAgc2hhcmVkS2V5cy5mb3JFYWNoKChzaGFyZWRLZXkpPT57XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWxzID0gc2hhcmVJbmZvc1tzaGFyZWRLZXldO1xuICAgICAgICAgICAgc2hhcmVkVmFscy5mb3JFYWNoKChzaGFyZWRWYWwpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNoYXJlZCA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIHNoYXJlZEtleSwgc2hhcmVkVmFsLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICAgICAgICAgIGlmICghcmVnaXN0ZXJlZFNoYXJlZCAmJiBzaGFyZWRWYWwgJiYgc2hhcmVkVmFsLmxpYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwa2dOYW1lOiBzaGFyZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWI6IHNoYXJlZFZhbC5saWIsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IHNoYXJlZFZhbC5nZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWQ6IHNoYXJlZFZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHVzZXJPcHRpb25zLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2hhcmVJbmZvcyxcbiAgICAgICAgICAgIHNoYXJlZFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBsb2FkU2hhcmUocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICAgICAgICAvLyAxLiBDaGVja3MgaWYgdGhlIGN1cnJlbnRseSBsb2FkZWQgc2hhcmUgYWxyZWFkeSBleGlzdHMsIGlmIG5vdCwgaXQgdGhyb3dzIGFuIGVycm9yXG4gICAgICAgIC8vIDIuIFNlYXJjaGVzIGdsb2JhbGx5IGZvciBhIG1hdGNoaW5nIHNoYXJlLCBpZiBmb3VuZCwgaXQgdXNlcyBpdCBkaXJlY3RseVxuICAgICAgICAvLyAzLiBJZiBub3QgZm91bmQsIGl0IHJldHJpZXZlcyBpdCBmcm9tIHRoZSBjdXJyZW50IHNoYXJlIGFuZCBzdG9yZXMgdGhlIG9idGFpbmVkIHNoYXJlIGdsb2JhbGx5LlxuICAgICAgICBjb25zdCBzaGFyZUluZm8gPSBnZXRUYXJnZXRTaGFyZWRPcHRpb25zKHtcbiAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICBleHRyYU9wdGlvbnMsXG4gICAgICAgICAgICBzaGFyZUluZm9zOiBob3N0Lm9wdGlvbnMuc2hhcmVkXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hhcmVJbmZvID09IG51bGwgPyB2b2lkIDAgOiBzaGFyZUluZm8uc2NvcGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHNoYXJlSW5mby5zY29wZS5tYXAoYXN5bmMgKHNoYXJlU2NvcGUpPT57XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5pbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiBzaGFyZUluZm8uc3RyYXRlZ3lcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRTaGFyZVJlcyA9IGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZUxvYWRTaGFyZS5lbWl0KHtcbiAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICBzaGFyZUluZm8sXG4gICAgICAgICAgICBzaGFyZWQ6IGhvc3Qub3B0aW9ucy5zaGFyZWQsXG4gICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVJbmZvOiBzaGFyZUluZm9SZXMgfSA9IGxvYWRTaGFyZVJlcztcbiAgICAgICAgLy8gQXNzZXJ0IHRoYXQgc2hhcmVJbmZvUmVzIGV4aXN0cywgaWYgbm90LCB0aHJvdyBhbiBlcnJvclxuICAgICAgICBhc3NlcnQoc2hhcmVJbmZvUmVzLCBgQ2Fubm90IGZpbmQgJHtwa2dOYW1lfSBTaGFyZSBpbiB0aGUgJHtob3N0Lm9wdGlvbnMubmFtZX0uIFBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgJHtwa2dOYW1lfSBTaGFyZSBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBpbmplY3RlZGApO1xuICAgICAgICAvLyBSZXRyaWV2ZSBmcm9tIGNhY2hlXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZUluZm9SZXMsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgIGNvbnN0IGFkZFVzZUluID0gKHNoYXJlZCk9PntcbiAgICAgICAgICAgIGlmICghc2hhcmVkLnVzZUluKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkLnVzZUluID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRVbmlxdWVJdGVtKHNoYXJlZC51c2VJbiwgaG9zdC5vcHRpb25zLm5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiByZWdpc3RlcmVkU2hhcmVkLmxpYikge1xuICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNoYXJlZC5saWI7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJlZFNoYXJlZCAmJiByZWdpc3RlcmVkU2hhcmVkLmxvYWRpbmcgJiYgIXJlZ2lzdGVyZWRTaGFyZWQubG9hZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkaW5nO1xuICAgICAgICAgICAgcmVnaXN0ZXJlZFNoYXJlZC5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkLmxpYikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRTaGFyZWQubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFVzZUluKHJlZ2lzdGVyZWRTaGFyZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVnaXN0ZXJlZFNoYXJlZCkge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHJlZ2lzdGVyZWRTaGFyZWQuZ2V0KCk7XG4gICAgICAgICAgICAgICAgc2hhcmVJbmZvUmVzLmxpYiA9IGZhY3Rvcnk7XG4gICAgICAgICAgICAgICAgc2hhcmVJbmZvUmVzLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWRkVXNlSW4oc2hhcmVJbmZvUmVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnU2hhcmVkID0gZ2V0UmVnaXN0ZXJlZFNoYXJlKHRoaXMuc2hhcmVTY29wZU1hcCwgcGtnTmFtZSwgc2hhcmVJbmZvUmVzLCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5yZXNvbHZlU2hhcmUpO1xuICAgICAgICAgICAgICAgIGlmIChnU2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdTaGFyZWQubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICAgICAgZ1NoYXJlZC5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBsb2FkaW5nID0gYXN5bmNMb2FkUHJvY2VzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgIHBrZ05hbWUsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaGFyZWQ6IHJlZ2lzdGVyZWRTaGFyZWQsXG4gICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgbGliOiBudWxsLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuY3VzdG9tU2hhcmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXN5bmNMb2FkUHJvY2VzcyA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IGF3YWl0IHNoYXJlSW5mb1Jlcy5nZXQoKTtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm9SZXMubGliID0gZmFjdG9yeTtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm9SZXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGRVc2VJbihzaGFyZUluZm9SZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdTaGFyZWQgPSBnZXRSZWdpc3RlcmVkU2hhcmUodGhpcy5zaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZUluZm9SZXMsIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlc29sdmVTaGFyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdTaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ1NoYXJlZC5saWIgPSBmYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgICBnU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRpbmcgPSBhc3luY0xvYWRQcm9jZXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNoYXJlZDogc2hhcmVJbmZvUmVzLFxuICAgICAgICAgICAgICAgIGZyb206IGhvc3Qub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIGxpYjogbnVsbCxcbiAgICAgICAgICAgICAgICBsb2FkaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsb2FkaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIHRoZSBzaGFyaW5nIHNlcXVlbmNlIChleGVjdXRlZCBvbmx5IG9uY2UgcGVyIHNoYXJlIHNjb3BlKS5cbiAgICogSXQgYWNjZXB0cyBvbmUgYXJndW1lbnQsIHRoZSBuYW1lIG9mIHRoZSBzaGFyZSBzY29wZS5cbiAgICogSWYgdGhlIHNoYXJlIHNjb3BlIGRvZXMgbm90IGV4aXN0LCBpdCBjcmVhdGVzIG9uZS5cbiAgICovIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgaW5pdGlhbGl6ZVNoYXJpbmcoc2hhcmVTY29wZU5hbWUgPSBERUZBVUxUX1NDT1BFLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBmcm9tID0gZXh0cmFPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBleHRyYU9wdGlvbnMuZnJvbTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5zdHJhdGVneTtcbiAgICAgICAgbGV0IGluaXRTY29wZSA9IGV4dHJhT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZXh0cmFPcHRpb25zLmluaXRTY29wZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gIT09ICdidWlsZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5pdFRva2VucyB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICghaW5pdFNjb3BlKSBpbml0U2NvcGUgPSBbXTtcbiAgICAgICAgICAgIGxldCBpbml0VG9rZW4gPSBpbml0VG9rZW5zW3NoYXJlU2NvcGVOYW1lXTtcbiAgICAgICAgICAgIGlmICghaW5pdFRva2VuKSBpbml0VG9rZW4gPSBpbml0VG9rZW5zW3NoYXJlU2NvcGVOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmhvc3QubmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbml0U2NvcGUuaW5kZXhPZihpbml0VG9rZW4pID49IDApIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgICAgIGluaXRTY29wZS5wdXNoKGluaXRUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhcmVTY29wZSA9IHRoaXMuc2hhcmVTY29wZU1hcDtcbiAgICAgICAgY29uc3QgaG9zdE5hbWUgPSBob3N0Lm9wdGlvbnMubmFtZTtcbiAgICAgICAgLy8gQ3JlYXRlcyBhIG5ldyBzaGFyZSBzY29wZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFzaGFyZVNjb3BlW3NoYXJlU2NvcGVOYW1lXSkge1xuICAgICAgICAgICAgc2hhcmVTY29wZVtzaGFyZVNjb3BlTmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGVjdXRlcyBhbGwgaW5pdGlhbGl6YXRpb24gc25pcHBldHMgZnJvbSBhbGwgYWNjZXNzaWJsZSBtb2R1bGVzXG4gICAgICAgIGNvbnN0IHNjb3BlID0gc2hhcmVTY29wZVtzaGFyZVNjb3BlTmFtZV07XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIHNoYXJlZCk9PntcbiAgICAgICAgICAgIHZhciBfYWN0aXZlVmVyc2lvbl9zaGFyZUNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgdmVyc2lvbiwgZWFnZXIgfSA9IHNoYXJlZDtcbiAgICAgICAgICAgIHNjb3BlW25hbWVdID0gc2NvcGVbbmFtZV0gfHwge307XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IHNjb3BlW25hbWVdO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlVmVyc2lvbiA9IHZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlVmVyc2lvbkVhZ2VyID0gQm9vbGVhbihhY3RpdmVWZXJzaW9uICYmIChhY3RpdmVWZXJzaW9uLmVhZ2VyIHx8ICgoX2FjdGl2ZVZlcnNpb25fc2hhcmVDb25maWcgPSBhY3RpdmVWZXJzaW9uLnNoYXJlQ29uZmlnKSA9PSBudWxsID8gdm9pZCAwIDogX2FjdGl2ZVZlcnNpb25fc2hhcmVDb25maWcuZWFnZXIpKSk7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVZlcnNpb24gfHwgYWN0aXZlVmVyc2lvbi5zdHJhdGVneSAhPT0gJ2xvYWRlZC1maXJzdCcgJiYgIWFjdGl2ZVZlcnNpb24ubG9hZGVkICYmIChCb29sZWFuKCFlYWdlcikgIT09ICFhY3RpdmVWZXJzaW9uRWFnZXIgPyBlYWdlciA6IGhvc3ROYW1lID4gYWN0aXZlVmVyc2lvbi5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHZlcnNpb25zW3ZlcnNpb25dID0gc2hhcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbml0Rm4gPSAobW9kKT0+bW9kICYmIG1vZC5pbml0ICYmIG1vZC5pbml0KHNoYXJlU2NvcGVbc2hhcmVTY29wZU5hbWVdLCBpbml0U2NvcGUpO1xuICAgICAgICBjb25zdCBpbml0UmVtb3RlTW9kdWxlID0gYXN5bmMgKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kdWxlIH0gPSBhd2FpdCBob3N0LnJlbW90ZUhhbmRsZXIuZ2V0UmVtb3RlTW9kdWxlQW5kT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgaWQ6IGtleVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobW9kdWxlLmdldEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBtb2R1bGUuZ2V0RW50cnkoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1vZHVsZS5pbml0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaW5pdEZuKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmluaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhob3N0Lm9wdGlvbnMuc2hhcmVkKS5mb3JFYWNoKChzaGFyZU5hbWUpPT57XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRBcnIgPSBob3N0Lm9wdGlvbnMuc2hhcmVkW3NoYXJlTmFtZV07XG4gICAgICAgICAgICBzaGFyZWRBcnIuZm9yRWFjaCgoc2hhcmVkKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaGFyZWQuc2NvcGUuaW5jbHVkZXMoc2hhcmVTY29wZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyKHNoYXJlTmFtZSwgc2hhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IHN0cmF0ZWd5PT09J3ZlcnNpb24tZmlyc3QnIG5lZWQgdG8gYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXG4gICAgICAgIGlmIChob3N0Lm9wdGlvbnMuc2hhcmVTdHJhdGVneSA9PT0gJ3ZlcnNpb24tZmlyc3QnIHx8IHN0cmF0ZWd5ID09PSAndmVyc2lvbi1maXJzdCcpIHtcbiAgICAgICAgICAgIGhvc3Qub3B0aW9ucy5yZW1vdGVzLmZvckVhY2goKHJlbW90ZSk9PntcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlLnNoYXJlU2NvcGUgPT09IHNoYXJlU2NvcGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goaW5pdFJlbW90ZU1vZHVsZShyZW1vdGUubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICB9XG4gICAgLy8gVGhlIGxpYiBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBzaGFyZWQgc2V0IGJ5IGVhZ2VyIG9yIHJ1bnRpbWUgaW5pdCBpcyBzZXQgb3IgdGhlIHNoYXJlZCBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgIC8vIDEuIElmIHRoZSBsb2FkZWQgc2hhcmVkIGFscmVhZHkgZXhpc3RzIGdsb2JhbGx5LCB0aGVuIGl0IHdpbGwgYmUgcmV1c2VkXG4gICAgLy8gMi4gSWYgbGliIGV4aXN0cyBpbiBsb2NhbCBzaGFyZWQsIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIC8vIDMuIElmIHRoZSBsb2NhbCBnZXQgcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBQcm9taXNlLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIGxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2hhcmVJbmZvID0gZ2V0VGFyZ2V0U2hhcmVkT3B0aW9ucyh7XG4gICAgICAgICAgICBwa2dOYW1lLFxuICAgICAgICAgICAgZXh0cmFPcHRpb25zLFxuICAgICAgICAgICAgc2hhcmVJbmZvczogaG9zdC5vcHRpb25zLnNoYXJlZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNoYXJlSW5mbyA9PSBudWxsID8gdm9pZCAwIDogc2hhcmVJbmZvLnNjb3BlKSB7XG4gICAgICAgICAgICBzaGFyZUluZm8uc2NvcGUuZm9yRWFjaCgoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGUsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3k6IHNoYXJlSW5mby5zdHJhdGVneVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZFNoYXJlZCA9IGdldFJlZ2lzdGVyZWRTaGFyZSh0aGlzLnNoYXJlU2NvcGVNYXAsIHBrZ05hbWUsIHNoYXJlSW5mbywgdGhpcy5ob29rcy5saWZlY3ljbGUucmVzb2x2ZVNoYXJlKTtcbiAgICAgICAgY29uc3QgYWRkVXNlSW4gPSAoc2hhcmVkKT0+e1xuICAgICAgICAgICAgaWYgKCFzaGFyZWQudXNlSW4pIHtcbiAgICAgICAgICAgICAgICBzaGFyZWQudXNlSW4gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFVuaXF1ZUl0ZW0oc2hhcmVkLnVzZUluLCBob3N0Lm9wdGlvbnMubmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyZWRTaGFyZWQubGliID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgYWRkVXNlSW4ocmVnaXN0ZXJlZFNoYXJlZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcmVkU2hhcmVkLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkU2hhcmVkLmZyb20gPT09IGhvc3Qub3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZUluZm8ubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFNoYXJlZC5saWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyZWRTaGFyZWQuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gcmVnaXN0ZXJlZFNoYXJlZC5nZXQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIShtb2R1bGUgaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRVc2VJbihyZWdpc3RlcmVkU2hhcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTaGFyZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGhvc3Qub3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGliOiBtb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWQ6IHJlZ2lzdGVyZWRTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZUluZm8ubGliKSB7XG4gICAgICAgICAgICBpZiAoIXNoYXJlSW5mby5sb2FkZWQpIHtcbiAgICAgICAgICAgICAgICBzaGFyZUluZm8ubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaGFyZUluZm8ubGliO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFyZUluZm8uZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGUgPSBzaGFyZUluZm8uZ2V0KCk7XG4gICAgICAgICAgICBpZiAobW9kdWxlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgIFRoZSBsb2FkU2hhcmVTeW5jIGZ1bmN0aW9uIHdhcyB1bmFibGUgdG8gbG9hZCAke3BrZ05hbWV9LiBUaGUgJHtwa2dOYW1lfSBjb3VsZCBub3QgYmUgZm91bmQgaW4gJHtob3N0Lm9wdGlvbnMubmFtZX0uXG4gICAgICAgIFBvc3NpYmxlIHJlYXNvbnMgZm9yIGZhaWx1cmU6IFxcblxuICAgICAgICAxLiBUaGUgJHtwa2dOYW1lfSBzaGFyZSB3YXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnZ2V0JyBhdHRyaWJ1dGUsIGJ1dCBsb2FkU2hhcmUgd2FzIG5vdCB1c2VkIGJlZm9yZWhhbmQuXFxuXG4gICAgICAgIDIuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnbGliJyBhdHRyaWJ1dGUuXFxuXG4gICAgICBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXJlSW5mby5saWIgPSBtb2R1bGU7XG4gICAgICAgICAgICB0aGlzLnNldFNoYXJlZCh7XG4gICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZnJvbTogaG9zdC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgbGliOiBzaGFyZUluZm8ubGliLFxuICAgICAgICAgICAgICAgIHNoYXJlZDogc2hhcmVJbmZvXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzaGFyZUluZm8ubGliO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICAgIFRoZSBsb2FkU2hhcmVTeW5jIGZ1bmN0aW9uIHdhcyB1bmFibGUgdG8gbG9hZCAke3BrZ05hbWV9LiBUaGUgJHtwa2dOYW1lfSBjb3VsZCBub3QgYmUgZm91bmQgaW4gJHtob3N0Lm9wdGlvbnMubmFtZX0uXG4gICAgICAgIFBvc3NpYmxlIHJlYXNvbnMgZm9yIGZhaWx1cmU6IFxcblxuICAgICAgICAxLiBUaGUgJHtwa2dOYW1lfSBzaGFyZSB3YXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnZ2V0JyBhdHRyaWJ1dGUsIGJ1dCBsb2FkU2hhcmUgd2FzIG5vdCB1c2VkIGJlZm9yZWhhbmQuXFxuXG4gICAgICAgIDIuIFRoZSAke3BrZ05hbWV9IHNoYXJlIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnbGliJyBhdHRyaWJ1dGUuXFxuXG4gICAgICBgKTtcbiAgICB9XG4gICAgaW5pdFNoYXJlU2NvcGVNYXAoc2NvcGVOYW1lLCBzaGFyZVNjb3BlLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcFtzY29wZU5hbWVdID0gc2hhcmVTY29wZTtcbiAgICAgICAgdGhpcy5ob29rcy5saWZlY3ljbGUuaW5pdENvbnRhaW5lclNoYXJlU2NvcGVNYXAuZW1pdCh7XG4gICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgb3B0aW9uczogaG9zdC5vcHRpb25zLFxuICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgc2NvcGVOYW1lLFxuICAgICAgICAgICAgaG9zdFNoYXJlU2NvcGVNYXA6IGV4dHJhT3B0aW9ucy5ob3N0U2hhcmVTY29wZU1hcFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0U2hhcmVkKHsgcGtnTmFtZSwgc2hhcmVkLCBmcm9tLCBsaWIsIGxvYWRpbmcsIGxvYWRlZCwgZ2V0IH0pIHtcbiAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBzY29wZSA9ICdkZWZhdWx0JyB9ID0gc2hhcmVkLCBzaGFyZUluZm8gPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShzaGFyZWQsIFtcbiAgICAgICAgICAgIFwidmVyc2lvblwiLFxuICAgICAgICAgICAgXCJzY29wZVwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBBcnJheS5pc0FycmF5KHNjb3BlKSA/IHNjb3BlIDogW1xuICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgXTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goKHNjKT0+e1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlU2NvcGVNYXBbc2NdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bdmVyc2lvbl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW3ZlcnNpb25dID0gX2V4dGVuZHMkMih7XG4gICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICBzY29wZTogW1xuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LCBzaGFyZUluZm8sIHtcbiAgICAgICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICAgICAgbG9hZGVkLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV1bdmVyc2lvbl0uZ2V0ID0gZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NldEdsb2JhbFNoYXJlU2NvcGVNYXAoaG9zdE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2xvYmFsU2hhcmVTY29wZU1hcCA9IGdldEdsb2JhbFNoYXJlU2NvcGUoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGhvc3RPcHRpb25zLmlkIHx8IGhvc3RPcHRpb25zLm5hbWU7XG4gICAgICAgIGlmIChpZGVudGlmaWVyICYmICFnbG9iYWxTaGFyZVNjb3BlTWFwW2lkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBnbG9iYWxTaGFyZVNjb3BlTWFwW2lkZW50aWZpZXJdID0gdGhpcy5zaGFyZVNjb3BlTWFwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGhvc3Qpe1xuICAgICAgICB0aGlzLmhvb2tzID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICAgICAgICBhZnRlclJlc29sdmU6IG5ldyBBc3luY1dhdGVyZmFsbEhvb2soJ2FmdGVyUmVzb2x2ZScpLFxuICAgICAgICAgICAgYmVmb3JlTG9hZFNoYXJlOiBuZXcgQXN5bmNXYXRlcmZhbGxIb29rKCdiZWZvcmVMb2FkU2hhcmUnKSxcbiAgICAgICAgICAgIC8vIG5vdCB1c2VkIHlldFxuICAgICAgICAgICAgbG9hZFNoYXJlOiBuZXcgQXN5bmNIb29rKCksXG4gICAgICAgICAgICByZXNvbHZlU2hhcmU6IG5ldyBTeW5jV2F0ZXJmYWxsSG9vaygncmVzb2x2ZVNoYXJlJyksXG4gICAgICAgICAgICAvLyBtYXliZSB3aWxsIGNoYW5nZSwgdGVtcG9yYXJpbHkgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgICAgICBpbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcDogbmV3IFN5bmNXYXRlcmZhbGxIb29rKCdpbml0Q29udGFpbmVyU2hhcmVTY29wZU1hcCcpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnNoYXJlU2NvcGVNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5pbml0VG9rZW5zID0ge307XG4gICAgICAgIHRoaXMuX3NldEdsb2JhbFNoYXJlU2NvcGVNYXAoaG9zdC5vcHRpb25zKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDEoKSB7XG4gICAgX2V4dGVuZHMkMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jbGFzcyBSZW1vdGVIYW5kbGVyIHtcbiAgICBmb3JtYXRBbmRSZWdpc3RlclJlbW90ZShnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCB1c2VyUmVtb3RlcyA9IHVzZXJPcHRpb25zLnJlbW90ZXMgfHwgW107XG4gICAgICAgIHJldHVybiB1c2VyUmVtb3Rlcy5yZWR1Y2UoKHJlcywgcmVtb3RlKT0+e1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclJlbW90ZShyZW1vdGUsIHJlcywge1xuICAgICAgICAgICAgICAgIGZvcmNlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBnbG9iYWxPcHRpb25zLnJlbW90ZXMpO1xuICAgIH1cbiAgICBzZXRJZFRvUmVtb3RlTWFwKGlkLCByZW1vdGVNYXRjaEluZm8pIHtcbiAgICAgICAgY29uc3QgeyByZW1vdGUsIGV4cG9zZSB9ID0gcmVtb3RlTWF0Y2hJbmZvO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGFsaWFzIH0gPSByZW1vdGU7XG4gICAgICAgIHRoaXMuaWRUb1JlbW90ZU1hcFtpZF0gPSB7XG4gICAgICAgICAgICBuYW1lOiByZW1vdGUubmFtZSxcbiAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoYWxpYXMgJiYgaWQuc3RhcnRzV2l0aChuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgaWRXaXRoQWxpYXMgPSBpZC5yZXBsYWNlKG5hbWUsIGFsaWFzKTtcbiAgICAgICAgICAgIHRoaXMuaWRUb1JlbW90ZU1hcFtpZFdpdGhBbGlhc10gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogcmVtb3RlLm5hbWUsXG4gICAgICAgICAgICAgICAgZXhwb3NlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGlhcyAmJiBpZC5zdGFydHNXaXRoKGFsaWFzKSkge1xuICAgICAgICAgICAgY29uc3QgaWRXaXRoTmFtZSA9IGlkLnJlcGxhY2UoYWxpYXMsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5pZFRvUmVtb3RlTWFwW2lkV2l0aE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHJlbW90ZS5uYW1lLFxuICAgICAgICAgICAgICAgIGV4cG9zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgbG9hZFJlbW90ZShpZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGxvYWRGYWN0b3J5ID0gdHJ1ZSB9ID0gb3B0aW9ucyB8fCB7XG4gICAgICAgICAgICAgICAgbG9hZEZhY3Rvcnk6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAxLiBWYWxpZGF0ZSB0aGUgcGFyYW1ldGVycyBvZiB0aGUgcmV0cmlldmVkIG1vZHVsZS4gVGhlcmUgYXJlIHR3byBtb2R1bGUgcmVxdWVzdCBtZXRob2RzOiBwa2dOYW1lICsgZXhwb3NlIGFuZCBhbGlhcyArIGV4cG9zZS5cbiAgICAgICAgICAgIC8vIDIuIFJlcXVlc3QgdGhlIHNuYXBzaG90IGluZm9ybWF0aW9uIG9mIHRoZSBjdXJyZW50IGhvc3QgYW5kIGdsb2JhbGx5IHN0b3JlIHRoZSBvYnRhaW5lZCBzbmFwc2hvdCBpbmZvcm1hdGlvbi4gVGhlIHJldHJpZXZlZCBtb2R1bGUgaW5mb3JtYXRpb24gaXMgcGFydGlhbGx5IG9mZmxpbmUgYW5kIHBhcnRpYWxseSBvbmxpbmUuIFRoZSBvbmxpbmUgbW9kdWxlIGluZm9ybWF0aW9uIHdpbGwgcmV0cmlldmUgdGhlIG1vZHVsZXMgdXNlZCBvbmxpbmUuXG4gICAgICAgICAgICAvLyAzLiBSZXRyaWV2ZSB0aGUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb2YgdGhlIGN1cnJlbnQgbW9kdWxlIGZyb20gZ2xvYmFsIChyZW1vdGVFbnRyeSBhZGRyZXNzLCBleHBvc2UgcmVzb3VyY2UgYWRkcmVzcylcbiAgICAgICAgICAgIC8vIDQuIEFmdGVyIHJldHJpZXZpbmcgcmVtb3RlRW50cnksIGNhbGwgdGhlIGluaXQgb2YgdGhlIG1vZHVsZSwgYW5kIHRoZW4gcmV0cmlldmUgdGhlIGV4cG9ydGVkIGNvbnRlbnQgb2YgdGhlIG1vZHVsZSB0aHJvdWdoIGdldFxuICAgICAgICAgICAgLy8gaWQ6IHBrZ05hbWUoQGZlZGVyYXRpb24vYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IEBmZWRlcmF0aW9uL2FwcDEvYnV0dG9uXG4gICAgICAgICAgICAvLyBpZDogYWxpYXMoYXBwMSkgKyBleHBvc2UoYnV0dG9uKSA9IGFwcDEvYnV0dG9uXG4gICAgICAgICAgICAvLyBpZDogYWxpYXMoYXBwMS91dGlscykgKyBleHBvc2UobG9hZGFzaC9zb3J0KSA9IGFwcDEvdXRpbHMvbG9hZGFzaC9zb3J0XG4gICAgICAgICAgICBjb25zdCB7IG1vZHVsZSwgbW9kdWxlT3B0aW9ucywgcmVtb3RlTWF0Y2hJbmZvIH0gPSBhd2FpdCB0aGlzLmdldFJlbW90ZU1vZHVsZUFuZE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtnTmFtZU9yQWxpYXMsIHJlbW90ZSwgZXhwb3NlLCBpZDogaWRSZXMgfSA9IHJlbW90ZU1hdGNoSW5mbztcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZU9yRmFjdG9yeSA9IGF3YWl0IG1vZHVsZS5nZXQoaWRSZXMsIGV4cG9zZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVXcmFwcGVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUub25Mb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZFJlcyxcbiAgICAgICAgICAgICAgICBwa2dOYW1lT3JBbGlhcyxcbiAgICAgICAgICAgICAgICBleHBvc2UsXG4gICAgICAgICAgICAgICAgZXhwb3NlTW9kdWxlOiBsb2FkRmFjdG9yeSA/IG1vZHVsZU9yRmFjdG9yeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBleHBvc2VNb2R1bGVGYWN0b3J5OiBsb2FkRmFjdG9yeSA/IHVuZGVmaW5lZCA6IG1vZHVsZU9yRmFjdG9yeSxcbiAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbW9kdWxlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtb2R1bGVJbnN0YW5jZTogbW9kdWxlLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNldElkVG9SZW1vdGVNYXAoaWQsIHJlbW90ZU1hdGNoSW5mbyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZVdyYXBwZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlV3JhcHBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVPckZhY3Rvcnk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20gPSAncnVudGltZScgfSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgICAgIGZyb206ICdydW50aW1lJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWxPdmVyID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlOiAnb25Mb2FkJyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFmYWlsT3Zlcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhaWxPdmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgcHJlbG9hZFJlbW90ZShwcmVsb2FkT3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGF3YWl0IHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVByZWxvYWRSZW1vdGUuZW1pdCh7XG4gICAgICAgICAgICBwcmVsb2FkT3BzOiBwcmVsb2FkT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJlbG9hZE9wcyA9IGZvcm1hdFByZWxvYWRBcmdzKGhvc3Qub3B0aW9ucy5yZW1vdGVzLCBwcmVsb2FkT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZWxvYWRPcHMubWFwKGFzeW5jIChvcHMpPT57XG4gICAgICAgICAgICBjb25zdCB7IHJlbW90ZSB9ID0gb3BzO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlSW5mbyA9IGdldFJlbW90ZUluZm8ocmVtb3RlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZ2xvYmFsU25hcHNob3QsIHJlbW90ZVNuYXBzaG90IH0gPSBhd2FpdCBob3N0LnNuYXBzaG90SGFuZGxlci5sb2FkUmVtb3RlU25hcHNob3RJbmZvKHJlbW90ZSk7XG4gICAgICAgICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCB0aGlzLmhvb2tzLmxpZmVjeWNsZS5nZW5lcmF0ZVByZWxvYWRBc3NldHMuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgICAgIHByZWxvYWRPcHRpb25zOiBvcHMsXG4gICAgICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgICAgIHJlbW90ZUluZm8sXG4gICAgICAgICAgICAgICAgZ2xvYmFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgcmVtb3RlU25hcHNob3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhc3NldHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVsb2FkQXNzZXRzKHJlbW90ZUluZm8sIGhvc3QsIGFzc2V0cyk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW1vdGVzKHJlbW90ZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICByZW1vdGVzLmZvckVhY2goKHJlbW90ZSk9PntcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJSZW1vdGUocmVtb3RlLCBob3N0Lm9wdGlvbnMucmVtb3Rlcywge1xuICAgICAgICAgICAgICAgIGZvcmNlOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlbW90ZU1vZHVsZUFuZE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBsb2FkUmVtb3RlQXJncztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvYWRSZW1vdGVBcmdzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlUmVxdWVzdC5lbWl0KHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBob3N0Lm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvYWRSZW1vdGVBcmdzID0gYXdhaXQgdGhpcy5ob29rcy5saWZlY3ljbGUuZXJyb3JMb2FkUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGhvc3Qub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3QsXG4gICAgICAgICAgICAgICAgZnJvbTogJ3J1bnRpbWUnLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZTogJ2JlZm9yZVJlcXVlc3QnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghbG9hZFJlbW90ZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlkOiBpZFJlcyB9ID0gbG9hZFJlbW90ZUFyZ3M7XG4gICAgICAgIGNvbnN0IHJlbW90ZVNwbGl0SW5mbyA9IG1hdGNoUmVtb3RlV2l0aE5hbWVBbmRFeHBvc2UoaG9zdC5vcHRpb25zLnJlbW90ZXMsIGlkUmVzKTtcbiAgICAgICAgYXNzZXJ0KHJlbW90ZVNwbGl0SW5mbywgYFxuICAgICAgICBVbmFibGUgdG8gbG9jYXRlICR7aWRSZXN9IGluICR7aG9zdC5vcHRpb25zLm5hbWV9LiBQb3RlbnRpYWwgcmVhc29ucyBmb3IgZmFpbHVyZSBpbmNsdWRlOlxcblxuICAgICAgICAxLiAke2lkUmVzfSB3YXMgbm90IGluY2x1ZGVkIGluIHRoZSAncmVtb3RlcycgcGFyYW1ldGVyIG9mICR7aG9zdC5vcHRpb25zLm5hbWUgfHwgJ3RoZSBob3N0J30uXFxuXG4gICAgICAgIDIuICR7aWRSZXN9IGNvdWxkIG5vdCBiZSBmb3VuZCBpbiB0aGUgJ3JlbW90ZXMnIG9mICR7aG9zdC5vcHRpb25zLm5hbWV9IHdpdGggZWl0aGVyICduYW1lJyBvciAnYWxpYXMnIGF0dHJpYnV0ZXMuXG4gICAgICAgIDMuICR7aWRSZXN9IGlzIG5vdCBvbmxpbmUsIGluamVjdGVkLCBvciBsb2FkZWQuXG4gICAgICAgIDQuICR7aWRSZXN9ICBjYW5ub3QgYmUgYWNjZXNzZWQgb24gdGhlIGV4cGVjdGVkLlxuICAgICAgICA1LiBUaGUgJ2JlZm9yZVJlcXVlc3QnIGhvb2sgd2FzIHByb3ZpZGVkIGJ1dCBkaWQgbm90IHJldHVybiB0aGUgY29ycmVjdCAncmVtb3RlSW5mbycgd2hlbiBhdHRlbXB0aW5nIHRvIGxvYWQgJHtpZFJlc30uXG4gICAgICBgKTtcbiAgICAgICAgY29uc3QgeyByZW1vdGU6IHJhd1JlbW90ZSB9ID0gcmVtb3RlU3BsaXRJbmZvO1xuICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gZ2V0UmVtb3RlSW5mbyhyYXdSZW1vdGUpO1xuICAgICAgICBjb25zdCBtYXRjaEluZm8gPSBhd2FpdCBob3N0LnNoYXJlZEhhbmRsZXIuaG9va3MubGlmZWN5Y2xlLmFmdGVyUmVzb2x2ZS5lbWl0KF9leHRlbmRzJDEoe1xuICAgICAgICAgICAgaWQ6IGlkUmVzXG4gICAgICAgIH0sIHJlbW90ZVNwbGl0SW5mbywge1xuICAgICAgICAgICAgb3B0aW9uczogaG9zdC5vcHRpb25zLFxuICAgICAgICAgICAgb3JpZ2luOiBob3N0LFxuICAgICAgICAgICAgcmVtb3RlSW5mb1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlLCBleHBvc2UgfSA9IG1hdGNoSW5mbztcbiAgICAgICAgYXNzZXJ0KHJlbW90ZSAmJiBleHBvc2UsIGBUaGUgJ2JlZm9yZVJlcXVlc3QnIGhvb2sgd2FzIGV4ZWN1dGVkLCBidXQgaXQgZmFpbGVkIHRvIHJldHVybiB0aGUgY29ycmVjdCAncmVtb3RlJyBhbmQgJ2V4cG9zZScgdmFsdWVzIHdoaWxlIGxvYWRpbmcgJHtpZFJlc30uYCk7XG4gICAgICAgIGxldCBtb2R1bGUgPSBob3N0Lm1vZHVsZUNhY2hlLmdldChyZW1vdGUubmFtZSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgcmVtb3RlSW5mb1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgICAgbW9kdWxlID0gbmV3IE1vZHVsZShtb2R1bGVPcHRpb25zKTtcbiAgICAgICAgICAgIGhvc3QubW9kdWxlQ2FjaGUuc2V0KHJlbW90ZS5uYW1lLCBtb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2R1bGUsXG4gICAgICAgICAgICBtb2R1bGVPcHRpb25zLFxuICAgICAgICAgICAgcmVtb3RlTWF0Y2hJbmZvOiBtYXRjaEluZm9cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSZW1vdGUocmVtb3RlLCB0YXJnZXRSZW1vdGVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgaG9zdCB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplUmVtb3RlID0gKCk9PntcbiAgICAgICAgICAgIGlmIChyZW1vdGUuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSBpZiBhbGlhcyBlcXVhbHMgdGhlIHByZWZpeCBvZiByZW1vdGUubmFtZSBhbmQgcmVtb3RlLmFsaWFzLCBpZiBzbywgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBBcyBtdWx0aS1sZXZlbCBwYXRoIHJlZmVyZW5jZXMgY2Fubm90IGd1YXJhbnRlZSB1bmlxdWUgbmFtZXMsIGFsaWFzIGJlaW5nIGEgcHJlZml4IG9mIHJlbW90ZS5uYW1lIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5kRXF1YWwgPSB0YXJnZXRSZW1vdGVzLmZpbmQoKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlbV9hbGlhcztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW90ZS5hbGlhcyAmJiAoaXRlbS5uYW1lLnN0YXJ0c1dpdGgocmVtb3RlLmFsaWFzKSB8fCAoKF9pdGVtX2FsaWFzID0gaXRlbS5hbGlhcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pdGVtX2FsaWFzLnN0YXJ0c1dpdGgocmVtb3RlLmFsaWFzKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydCghZmluZEVxdWFsLCBgVGhlIGFsaWFzICR7cmVtb3RlLmFsaWFzfSBvZiByZW1vdGUgJHtyZW1vdGUubmFtZX0gaXMgbm90IGFsbG93ZWQgdG8gYmUgdGhlIHByZWZpeCBvZiAke2ZpbmRFcXVhbCAmJiBmaW5kRXF1YWwubmFtZX0gbmFtZSBvciBhbGlhc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHRoZSByZW1vdGUgZW50cnkgdG8gYSBjb21wbGV0ZSBwYXRoXG4gICAgICAgICAgICBpZiAoJ2VudHJ5JyBpbiByZW1vdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyRW52KCkgJiYgIXJlbW90ZS5lbnRyeS5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlLmVudHJ5ID0gbmV3IFVSTChyZW1vdGUuZW50cnksIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLmhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZW1vdGUuc2hhcmVTY29wZSkge1xuICAgICAgICAgICAgICAgIHJlbW90ZS5zaGFyZVNjb3BlID0gREVGQVVMVF9TQ09QRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVtb3RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdGUudHlwZSA9IERFRkFVTFRfUkVNT1RFX1RZUEU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLmJlZm9yZVJlZ2lzdGVyUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgb3JpZ2luOiBob3N0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWdpc3RlcmVkUmVtb3RlID0gdGFyZ2V0UmVtb3Rlcy5maW5kKChpdGVtKT0+aXRlbS5uYW1lID09PSByZW1vdGUubmFtZSk7XG4gICAgICAgIGlmICghcmVnaXN0ZXJlZFJlbW90ZSkge1xuICAgICAgICAgICAgbm9ybWFsaXplUmVtb3RlKCk7XG4gICAgICAgICAgICB0YXJnZXRSZW1vdGVzLnB1c2gocmVtb3RlKTtcbiAgICAgICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlZ2lzdGVyUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IGhvc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgYFRoZSByZW1vdGUgXCIke3JlbW90ZS5uYW1lfVwiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5gLFxuICAgICAgICAgICAgICAgIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcmNlKSA/ICdIb3BlIHlvdSBoYXZlIGtub3duIHRoYXQgT1ZFUlJJREUgaXQgbWF5IGhhdmUgc29tZSB1bmV4cGVjdGVkIGVycm9ycycgOiAnSWYgeW91IHdhbnQgdG8gbWVyZ2UgdGhlIHJlbW90ZSwgeW91IGNhbiBzZXQgXCJmb3JjZTogdHJ1ZVwiLidcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSByZWdpc3RlcmVkIHJlbW90ZVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVtb3RlKHJlZ2lzdGVyZWRSZW1vdGUpO1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJlbW90ZSgpO1xuICAgICAgICAgICAgICAgIHRhcmdldFJlbW90ZXMucHVzaChyZW1vdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9va3MubGlmZWN5Y2xlLnJlZ2lzdGVyUmVtb3RlLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICByZW1vdGUsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogaG9zdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FybiQxKG1lc3NhZ2VzLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlUmVtb3RlKHJlbW90ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBob3N0IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSByZW1vdGU7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVJbmRleCA9IGhvc3Qub3B0aW9ucy5yZW1vdGVzLmZpbmRJbmRleCgoaXRlbSk9Pml0ZW0ubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAocmVtb3RlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaG9zdC5vcHRpb25zLnJlbW90ZXMuc3BsaWNlKHJlbW90ZUluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZE1vZHVsZSA9IGhvc3QubW9kdWxlQ2FjaGUuZ2V0KHJlbW90ZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChsb2FkZWRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVJbmZvID0gbG9hZGVkTW9kdWxlLnJlbW90ZUluZm87XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVtb3RlSW5mby5lbnRyeUdsb2JhbE5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbFRoaXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX09iamVjdF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX09iamVjdF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbFRoaXMsIGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfT2JqZWN0X2dldE93blByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxUaGlzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlRW50cnlVbmlxdWVLZXkgPSBnZXRSZW1vdGVFbnRyeVVuaXF1ZUtleShsb2FkZWRNb2R1bGUucmVtb3RlSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbExvYWRpbmdbcmVtb3RlRW50cnlVbmlxdWVLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxMb2FkaW5nW3JlbW90ZUVudHJ5VW5pcXVlS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9zdC5zbmFwc2hvdEhhbmRsZXIubWFuaWZlc3RDYWNoZS5kZWxldGUocmVtb3RlSW5mby5lbnRyeSk7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIHVubG9hZGVkIHNoYXJlZCBhbmQgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBsZXQgcmVtb3RlSW5zSWQgPSByZW1vdGVJbmZvLmJ1aWxkVmVyc2lvbiA/IGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yKHJlbW90ZUluZm8ubmFtZSwgcmVtb3RlSW5mby5idWlsZFZlcnNpb24pIDogcmVtb3RlSW5mby5uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUluc0luZGV4ID0gZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLmZpbmRJbmRleCgoaW5zKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlSW5mby5idWlsZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnMub3B0aW9ucy5pZCA9PT0gcmVtb3RlSW5zSWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zLm5hbWUgPT09IHJlbW90ZUluc0lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZUluc0luZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVJbnMgPSBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX19bcmVtb3RlSW5zSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVJbnNJZCA9IHJlbW90ZUlucy5vcHRpb25zLmlkIHx8IHJlbW90ZUluc0lkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTaGFyZVNjb3BlTWFwID0gZ2V0R2xvYmFsU2hhcmVTY29wZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNBbGxTaGFyZWROb3RVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVlZERlbGV0ZUtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZ2xvYmFsU2hhcmVTY29wZU1hcCkuZm9yRWFjaCgoaW5zdElkKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVTY29wZU1hcCA9IGdsb2JhbFNoYXJlU2NvcGVNYXBbaW5zdElkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVNYXAgJiYgT2JqZWN0LmtleXMoc2hhcmVTY29wZU1hcCkuZm9yRWFjaCgoc2hhcmVTY29wZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZVNjb3BlVmFsID0gc2hhcmVTY29wZU1hcFtzaGFyZVNjb3BlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlVmFsICYmIE9iamVjdC5rZXlzKHNoYXJlU2NvcGVWYWwpLmZvckVhY2goKHNoYXJlTmFtZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkUGtncyA9IHNoYXJlU2NvcGVWYWxbc2hhcmVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkUGtncyAmJiBPYmplY3Qua2V5cyhzaGFyZWRQa2dzKS5mb3JFYWNoKChzaGFyZVZlcnNpb24pPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWQgPSBzaGFyZWRQa2dzW3NoYXJlVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkICYmIHR5cGVvZiBzaGFyZWQgPT09ICdvYmplY3QnICYmIHNoYXJlZC5mcm9tID09PSByZW1vdGVJbmZvLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLmxvYWRlZCB8fCBzaGFyZWQubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWQudXNlSW4gPSBzaGFyZWQudXNlSW4uZmlsdGVyKCh1c2VkSG9zdE5hbWUpPT51c2VkSG9zdE5hbWUgIT09IHJlbW90ZUluZm8ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZWQudXNlSW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FsbFNoYXJlZE5vdFVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWREZWxldGVLZXlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUtleXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFyZVNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVWZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FsbFNoYXJlZE5vdFVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUlucy5zaGFyZVNjb3BlTWFwID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2xvYmFsU2hhcmVTY29wZU1hcFtyZW1vdGVJbnNJZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmVlZERlbGV0ZUtleXMuZm9yRWFjaCgoW2luc0lkLCBzaGFyZVNjb3BlLCBzaGFyZU5hbWUsIHNoYXJlVmVyc2lvbl0pPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWUsIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGUsIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkID0gZ2xvYmFsU2hhcmVTY29wZU1hcFtpbnNJZF0pID09IG51bGwgPyB0cnVlIDogKF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGUgPSBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZFtzaGFyZVNjb3BlXSkgPT0gbnVsbCA/IHRydWUgOiAoX2dsb2JhbFNoYXJlU2NvcGVNYXBfaW5zSWRfc2hhcmVTY29wZV9zaGFyZU5hbWUgPSBfZ2xvYmFsU2hhcmVTY29wZU1hcF9pbnNJZF9zaGFyZVNjb3BlW3NoYXJlTmFtZV0pID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9nbG9iYWxTaGFyZVNjb3BlTWFwX2luc0lkX3NoYXJlU2NvcGVfc2hhcmVOYW1lW3NoYXJlVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fSU5TVEFOQ0VTX18uc3BsaWNlKHJlbW90ZUluc0luZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBob3N0R2xvYmFsU25hcHNob3QgfSA9IGdldEdsb2JhbFJlbW90ZUluZm8ocmVtb3RlLCBob3N0KTtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdEdsb2JhbFNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUtleSA9IGhvc3RHbG9iYWxTbmFwc2hvdCAmJiAncmVtb3Rlc0luZm8nIGluIGhvc3RHbG9iYWxTbmFwc2hvdCAmJiBob3N0R2xvYmFsU25hcHNob3QucmVtb3Rlc0luZm8gJiYgZ2V0SW5mb1dpdGhvdXRUeXBlKGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mbywgcmVtb3RlLm5hbWUpLmtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhvc3RHbG9iYWxTbmFwc2hvdC5yZW1vdGVzSW5mb1tyZW1vdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEJvb2xlYW4oR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fTUFOSUZFU1RfTE9BRElOR19fW3JlbW90ZUtleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIEdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX01BTklGRVNUX0xPQURJTkdfX1tyZW1vdGVLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvc3QubW9kdWxlQ2FjaGUuZGVsZXRlKHJlbW90ZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncmVtb3ZlUmVtb3RlIGZhaWw6ICcsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoaG9zdCl7XG4gICAgICAgIHRoaXMuaG9va3MgPSBuZXcgUGx1Z2luU3lzdGVtKHtcbiAgICAgICAgICAgIGJlZm9yZVJlZ2lzdGVyUmVtb3RlOiBuZXcgU3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZVJlZ2lzdGVyUmVtb3RlJyksXG4gICAgICAgICAgICByZWdpc3RlclJlbW90ZTogbmV3IFN5bmNXYXRlcmZhbGxIb29rKCdyZWdpc3RlclJlbW90ZScpLFxuICAgICAgICAgICAgYmVmb3JlUmVxdWVzdDogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlUmVxdWVzdCcpLFxuICAgICAgICAgICAgb25Mb2FkOiBuZXcgQXN5bmNIb29rKCdvbkxvYWQnKSxcbiAgICAgICAgICAgIGhhbmRsZVByZWxvYWRNb2R1bGU6IG5ldyBTeW5jSG9vaygnaGFuZGxlUHJlbG9hZE1vZHVsZScpLFxuICAgICAgICAgICAgZXJyb3JMb2FkUmVtb3RlOiBuZXcgQXN5bmNIb29rKCdlcnJvckxvYWRSZW1vdGUnKSxcbiAgICAgICAgICAgIGJlZm9yZVByZWxvYWRSZW1vdGU6IG5ldyBBc3luY0hvb2soJ2JlZm9yZVByZWxvYWRSZW1vdGUnKSxcbiAgICAgICAgICAgIGdlbmVyYXRlUHJlbG9hZEFzc2V0czogbmV3IEFzeW5jSG9vaygnZ2VuZXJhdGVQcmVsb2FkQXNzZXRzJyksXG4gICAgICAgICAgICAvLyBub3QgdXNlZCB5ZXRcbiAgICAgICAgICAgIGFmdGVyUHJlbG9hZFJlbW90ZTogbmV3IEFzeW5jSG9vaygpLFxuICAgICAgICAgICAgbG9hZEVudHJ5OiBuZXcgQXN5bmNIb29rKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuaWRUb1JlbW90ZU1hcCA9IHt9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiBzb3VyY2Upe1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmNsYXNzIEZlZGVyYXRpb25Ib3N0IHtcbiAgICBpbml0T3B0aW9ucyh1c2VyT3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUGx1Z2lucyh1c2VyT3B0aW9ucy5wbHVnaW5zKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZm9ybWF0T3B0aW9ucyh0aGlzLm9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTaGFyZShwa2dOYW1lLCBleHRyYU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkSGFuZGxlci5sb2FkU2hhcmUocGtnTmFtZSwgZXh0cmFPcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVGhlIGxpYiBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgYXZhaWxhYmxlIGlmIHRoZSBzaGFyZWQgc2V0IGJ5IGVhZ2VyIG9yIHJ1bnRpbWUgaW5pdCBpcyBzZXQgb3IgdGhlIHNoYXJlZCBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgIC8vIDEuIElmIHRoZSBsb2FkZWQgc2hhcmVkIGFscmVhZHkgZXhpc3RzIGdsb2JhbGx5LCB0aGVuIGl0IHdpbGwgYmUgcmV1c2VkXG4gICAgLy8gMi4gSWYgbGliIGV4aXN0cyBpbiBsb2NhbCBzaGFyZWQsIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIC8vIDMuIElmIHRoZSBsb2NhbCBnZXQgcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhbiBQcm9taXNlLCB0aGVuIGl0IHdpbGwgYmUgdXNlZCBkaXJlY3RseVxuICAgIGxvYWRTaGFyZVN5bmMocGtnTmFtZSwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXJlZEhhbmRsZXIubG9hZFNoYXJlU3luYyhwa2dOYW1lLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgICBpbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlTmFtZSA9IERFRkFVTFRfU0NPUEUsIGV4dHJhT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFyZWRIYW5kbGVyLmluaXRpYWxpemVTaGFyaW5nKHNoYXJlU2NvcGVOYW1lLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgICBpbml0UmF3Q29udGFpbmVyKG5hbWUsIHVybCwgY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZUluZm8gPSBnZXRSZW1vdGVJbmZvKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlbnRyeTogdXJsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBuZXcgTW9kdWxlKHtcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMsXG4gICAgICAgICAgICByZW1vdGVJbmZvXG4gICAgICAgIH0pO1xuICAgICAgICBtb2R1bGUucmVtb3RlRW50cnlFeHBvcnRzID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLm1vZHVsZUNhY2hlLnNldChuYW1lLCBtb2R1bGUpO1xuICAgICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxpbmVzLXBlci1mdW5jdGlvblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbWVtYmVyLW9yZGVyaW5nXG4gICAgYXN5bmMgbG9hZFJlbW90ZShpZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVIYW5kbGVyLmxvYWRSZW1vdGUoaWQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L21lbWJlci1vcmRlcmluZ1xuICAgIGFzeW5jIHByZWxvYWRSZW1vdGUocHJlbG9hZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3RlSGFuZGxlci5wcmVsb2FkUmVtb3RlKHByZWxvYWRPcHRpb25zKTtcbiAgICB9XG4gICAgaW5pdFNoYXJlU2NvcGVNYXAoc2NvcGVOYW1lLCBzaGFyZVNjb3BlLCBleHRyYU9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnNoYXJlZEhhbmRsZXIuaW5pdFNoYXJlU2NvcGVNYXAoc2NvcGVOYW1lLCBzaGFyZVNjb3BlLCBleHRyYU9wdGlvbnMpO1xuICAgIH1cbiAgICBmb3JtYXRPcHRpb25zKGdsb2JhbE9wdGlvbnMsIHVzZXJPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVkIH0gPSBmb3JtYXRTaGFyZUNvbmZpZ3MoZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IHVzZXJPcHRpb25zOiB1c2VyT3B0aW9uc1Jlcywgb3B0aW9uczogZ2xvYmFsT3B0aW9uc1JlcyB9ID0gdGhpcy5ob29rcy5saWZlY3ljbGUuYmVmb3JlSW5pdC5lbWl0KHtcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcyxcbiAgICAgICAgICAgIHVzZXJPcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9uczogZ2xvYmFsT3B0aW9ucyxcbiAgICAgICAgICAgIHNoYXJlSW5mbzogc2hhcmVkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZW1vdGVzID0gdGhpcy5yZW1vdGVIYW5kbGVyLmZvcm1hdEFuZFJlZ2lzdGVyUmVtb3RlKGdsb2JhbE9wdGlvbnNSZXMsIHVzZXJPcHRpb25zUmVzKTtcbiAgICAgICAgY29uc3QgeyBzaGFyZWQ6IGhhbmRsZWRTaGFyZWQgfSA9IHRoaXMuc2hhcmVkSGFuZGxlci5yZWdpc3RlclNoYXJlZChnbG9iYWxPcHRpb25zUmVzLCB1c2VyT3B0aW9uc1Jlcyk7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBbXG4gICAgICAgICAgICAuLi5nbG9iYWxPcHRpb25zUmVzLnBsdWdpbnNcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKHVzZXJPcHRpb25zUmVzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHVzZXJPcHRpb25zUmVzLnBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKT0+e1xuICAgICAgICAgICAgICAgIGlmICghcGx1Z2lucy5pbmNsdWRlcyhwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnNSZXMgPSBfZXh0ZW5kcyh7fSwgZ2xvYmFsT3B0aW9ucywgdXNlck9wdGlvbnMsIHtcbiAgICAgICAgICAgIHBsdWdpbnMsXG4gICAgICAgICAgICByZW1vdGVzLFxuICAgICAgICAgICAgc2hhcmVkOiBoYW5kbGVkU2hhcmVkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhvb2tzLmxpZmVjeWNsZS5pbml0LmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luOiB0aGlzLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1Jlc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNSZXM7XG4gICAgfVxuICAgIHJlZ2lzdGVyUGx1Z2lucyhwbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpblJlcyA9IHJlZ2lzdGVyUGx1Z2lucyQxKHBsdWdpbnMsIFtcbiAgICAgICAgICAgIHRoaXMuaG9va3MsXG4gICAgICAgICAgICB0aGlzLnJlbW90ZUhhbmRsZXIuaG9va3MsXG4gICAgICAgICAgICB0aGlzLnNoYXJlZEhhbmRsZXIuaG9va3MsXG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90SGFuZGxlci5ob29rcyxcbiAgICAgICAgICAgIHRoaXMubG9hZGVySG9va1xuICAgICAgICBdKTtcbiAgICAgICAgLy8gTWVyZ2UgcGx1Z2luXG4gICAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zID0gdGhpcy5vcHRpb25zLnBsdWdpbnMucmVkdWNlKChyZXMsIHBsdWdpbik9PntcbiAgICAgICAgICAgIGlmICghcGx1Z2luKSByZXR1cm4gcmVzO1xuICAgICAgICAgICAgaWYgKHJlcyAmJiAhcmVzLmZpbmQoKGl0ZW0pPT5pdGVtLm5hbWUgPT09IHBsdWdpbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBwbHVnaW5SZXMgfHwgW10pO1xuICAgIH1cbiAgICByZWdpc3RlclJlbW90ZXMocmVtb3Rlcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdGVIYW5kbGVyLnJlZ2lzdGVyUmVtb3RlcyhyZW1vdGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodXNlck9wdGlvbnMpe1xuICAgICAgICB0aGlzLmhvb2tzID0gbmV3IFBsdWdpblN5c3RlbSh7XG4gICAgICAgICAgICBiZWZvcmVJbml0OiBuZXcgU3luY1dhdGVyZmFsbEhvb2soJ2JlZm9yZUluaXQnKSxcbiAgICAgICAgICAgIGluaXQ6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgICAgICAgLy8gbWF5YmUgd2lsbCBjaGFuZ2UsIHRlbXBvcmFyaWx5IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICAgICAgYmVmb3JlSW5pdENvbnRhaW5lcjogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnYmVmb3JlSW5pdENvbnRhaW5lcicpLFxuICAgICAgICAgICAgLy8gbWF5YmUgd2lsbCBjaGFuZ2UsIHRlbXBvcmFyaWx5IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICAgICAgaW5pdENvbnRhaW5lcjogbmV3IEFzeW5jV2F0ZXJmYWxsSG9vaygnaW5pdENvbnRhaW5lcicpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBcIjAuNS4yXCI7XG4gICAgICAgIHRoaXMubW9kdWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9hZGVySG9vayA9IG5ldyBQbHVnaW5TeXN0ZW0oe1xuICAgICAgICAgICAgLy8gRklYTUU6IG1heSBub3QgYmUgc3VpdGFibGUgLCBub3Qgb3BlbiB0byB0aGUgcHVibGljIHlldFxuICAgICAgICAgICAgZ2V0TW9kdWxlSW5mbzogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHQ6IG5ldyBTeW5jSG9vaygpLFxuICAgICAgICAgICAgY3JlYXRlTGluazogbmV3IFN5bmNIb29rKCksXG4gICAgICAgICAgICAvLyBvbmx5IHdvcmsgZm9yIG1hbmlmZXN0ICwgc28gbm90IG9wZW4gdG8gdGhlIHB1YmxpYyB5ZXRcbiAgICAgICAgICAgIGZldGNoOiBuZXcgQXN5bmNIb29rKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoZSBkZXRhaWxzIG9mIHRoZSBvcHRpb25zXG4gICAgICAgIC8vIEluaXRpYWxpemUgb3B0aW9ucyB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgaWQ6IGdldEJ1aWxkZXJJZCgpLFxuICAgICAgICAgICAgbmFtZTogdXNlck9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdFBsdWdpbigpLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlUHJlbG9hZEFzc2V0c1BsdWdpbigpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgcmVtb3RlczogW10sXG4gICAgICAgICAgICBzaGFyZWQ6IHt9LFxuICAgICAgICAgICAgaW5Ccm93c2VyOiBpc0Jyb3dzZXJFbnYkMSgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZSA9IHVzZXJPcHRpb25zLm5hbWU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB0aGlzLnNuYXBzaG90SGFuZGxlciA9IG5ldyBTbmFwc2hvdEhhbmRsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuc2hhcmVkSGFuZGxlciA9IG5ldyBTaGFyZWRIYW5kbGVyKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbW90ZUhhbmRsZXIgPSBuZXcgUmVtb3RlSGFuZGxlcih0aGlzKTtcbiAgICAgICAgdGhpcy5zaGFyZVNjb3BlTWFwID0gdGhpcy5zaGFyZWRIYW5kbGVyLnNoYXJlU2NvcGVNYXA7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQbHVnaW5zKFtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLnBsdWdpbnMsXG4gICAgICAgICAgICAuLi51c2VyT3B0aW9ucy5wbHVnaW5zIHx8IFtdXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmZvcm1hdE9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICB9XG59XG5cbmxldCBGZWRlcmF0aW9uSW5zdGFuY2UgPSBudWxsO1xuZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgLy8gUmV0cmlldmUgdGhlIHNhbWUgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgY29uc3QgaW5zdGFuY2UgPSBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2Uob3B0aW9ucy5uYW1lLCBvcHRpb25zLnZlcnNpb24pO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgZGVidWcgY29uc3RydWN0b3JcbiAgICAgICAgY29uc3QgRmVkZXJhdGlvbkNvbnN0cnVjdG9yID0gZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yKCkgfHwgRmVkZXJhdGlvbkhvc3Q7XG4gICAgICAgIEZlZGVyYXRpb25JbnN0YW5jZSA9IG5ldyBGZWRlcmF0aW9uQ29uc3RydWN0b3Iob3B0aW9ucyk7XG4gICAgICAgIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZShGZWRlcmF0aW9uSW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIG9wdGlvbnNcbiAgICAgICAgaW5zdGFuY2UuaW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICghRmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICBGZWRlcmF0aW9uSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9hZFJlbW90ZSguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICBjb25zdCBsb2FkUmVtb3RlMSA9IEZlZGVyYXRpb25JbnN0YW5jZS5sb2FkUmVtb3RlO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIGxvYWRSZW1vdGUxLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBsb2FkU2hhcmUoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICBjb25zdCBsb2FkU2hhcmUxID0gRmVkZXJhdGlvbkluc3RhbmNlLmxvYWRTaGFyZTtcbiAgICByZXR1cm4gbG9hZFNoYXJlMS5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gbG9hZFNoYXJlU3luYyguLi5hcmdzKSB7XG4gICAgYXNzZXJ0KEZlZGVyYXRpb25JbnN0YW5jZSwgJ1BsZWFzZSBjYWxsIGluaXQgZmlyc3QnKTtcbiAgICBjb25zdCBsb2FkU2hhcmVTeW5jMSA9IEZlZGVyYXRpb25JbnN0YW5jZS5sb2FkU2hhcmVTeW5jO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIGxvYWRTaGFyZVN5bmMxLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiBwcmVsb2FkUmVtb3RlKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZS5wcmVsb2FkUmVtb3RlLmFwcGx5KEZlZGVyYXRpb25JbnN0YW5jZSwgYXJncyk7XG59XG5mdW5jdGlvbiByZWdpc3RlclJlbW90ZXMoLi4uYXJncykge1xuICAgIGFzc2VydChGZWRlcmF0aW9uSW5zdGFuY2UsICdQbGVhc2UgY2FsbCBpbml0IGZpcnN0Jyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICByZXR1cm4gRmVkZXJhdGlvbkluc3RhbmNlLnJlZ2lzdGVyUmVtb3Rlcy5hcHBseShGZWRlcmF0aW9uSW5zdGFuY2UsIGFyZ3MpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICBhc3NlcnQoRmVkZXJhdGlvbkluc3RhbmNlLCAnUGxlYXNlIGNhbGwgaW5pdCBmaXJzdCcpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG4gICAgcmV0dXJuIEZlZGVyYXRpb25JbnN0YW5jZS5yZWdpc3RlclBsdWdpbnMuYXBwbHkoRmVkZXJhdGlvbkluc3RhbmNlLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICAgIHJldHVybiBGZWRlcmF0aW9uSW5zdGFuY2U7XG59XG4vLyBJbmplY3QgZm9yIGRlYnVnXG5zZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IoRmVkZXJhdGlvbkhvc3QpO1xuXG5leHBvcnQgeyBGZWRlcmF0aW9uSG9zdCwgZ2V0SW5zdGFuY2UsIGdldFJlbW90ZUVudHJ5LCBnZXRSZW1vdGVJbmZvLCBpbml0LCBsb2FkUmVtb3RlLCBsb2FkU2hhcmUsIGxvYWRTaGFyZVN5bmMsIHByZWxvYWRSZW1vdGUsIHJlZ2lzdGVyUGx1Z2lucywgcmVnaXN0ZXJSZW1vdGVzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/runtime/dist/index.esm.js\n"));

/***/ }),

/***/ "./node_modules/@module-federation/runtime/dist/share.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@module-federation/runtime/dist/share.esm.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: function() { return /* binding */ getGlobalShareScope; },\n/* harmony export */   B: function() { return /* binding */ addUniqueItem; },\n/* harmony export */   C: function() { return /* binding */ getBuilderId; },\n/* harmony export */   D: function() { return /* binding */ DEFAULT_REMOTE_TYPE; },\n/* harmony export */   E: function() { return /* binding */ setGlobalFederationConstructor; },\n/* harmony export */   F: function() { return /* binding */ getGlobalFederationInstance; },\n/* harmony export */   G: function() { return /* binding */ Global; },\n/* harmony export */   H: function() { return /* binding */ getGlobalFederationConstructor; },\n/* harmony export */   I: function() { return /* binding */ setGlobalFederationInstance; },\n/* harmony export */   J: function() { return /* binding */ registerGlobalPlugins; },\n/* harmony export */   K: function() { return /* binding */ nativeGlobal; },\n/* harmony export */   L: function() { return /* binding */ resetFederationGlobalInfo; },\n/* harmony export */   M: function() { return /* binding */ getTargetSnapshotInfoByModuleInfo; },\n/* harmony export */   a: function() { return /* binding */ globalLoading; },\n/* harmony export */   b: function() { return /* binding */ DEFAULT_SCOPE; },\n/* harmony export */   c: function() { return /* binding */ getRemoteEntryExports; },\n/* harmony export */   d: function() { return /* binding */ assert; },\n/* harmony export */   e: function() { return /* binding */ getFMId; },\n/* harmony export */   f: function() { return /* binding */ error; },\n/* harmony export */   g: function() { return /* binding */ getGlobalHostPlugins; },\n/* harmony export */   h: function() { return /* binding */ isPlainObject; },\n/* harmony export */   i: function() { return /* binding */ isObject; },\n/* harmony export */   j: function() { return /* binding */ isRemoteInfoWithEntry; },\n/* harmony export */   k: function() { return /* binding */ isPureRemoteEntry; },\n/* harmony export */   l: function() { return /* binding */ getRemoteEntryInfoFromSnapshot; },\n/* harmony export */   m: function() { return /* binding */ isBrowserEnv; },\n/* harmony export */   n: function() { return /* binding */ getInfoWithoutType; },\n/* harmony export */   o: function() { return /* binding */ getPreloaded; },\n/* harmony export */   p: function() { return /* binding */ setPreloaded; },\n/* harmony export */   q: function() { return /* binding */ getRegisteredShare; },\n/* harmony export */   r: function() { return /* binding */ arrayOptions; },\n/* harmony export */   s: function() { return /* binding */ safeToString; },\n/* harmony export */   t: function() { return /* binding */ getGlobalSnapshotInfoByModuleInfo; },\n/* harmony export */   u: function() { return /* binding */ addGlobalSnapshot; },\n/* harmony export */   v: function() { return /* binding */ setGlobalSnapshotInfoByModuleInfo; },\n/* harmony export */   w: function() { return /* binding */ warn; },\n/* harmony export */   x: function() { return /* binding */ getGlobalSnapshot; },\n/* harmony export */   y: function() { return /* binding */ formatShareConfigs; },\n/* harmony export */   z: function() { return /* binding */ getTargetSharedOptions; }\n/* harmony export */ });\nfunction getBuilderId() {\n    //@ts-ignore\n    return  true ? \"remote:0.1.0\" : 0;\n}\nfunction isDebugMode() {\n    return Boolean(\"\");\n}\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction assert(condition, msg) {\n    if (!condition) {\n        error(msg);\n    }\n}\nfunction error(msg) {\n    if (msg instanceof Error) {\n        msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        throw msg;\n    }\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n}\nfunction warn(msg) {\n    if (msg instanceof Error) {\n        msg.message = `${LOG_CATEGORY}: ${msg.message}`;\n        console.warn(msg);\n    } else {\n        console.warn(`${LOG_CATEGORY}: ${msg}`);\n    }\n}\n\nfunction addUniqueItem(arr, item) {\n    if (arr.findIndex((name)=>name === item) === -1) {\n        arr.push(item);\n    }\n    return arr;\n}\nfunction getFMId(remoteInfo) {\n    if ('version' in remoteInfo && remoteInfo.version) {\n        return `${remoteInfo.name}:${remoteInfo.version}`;\n    } else if ('entry' in remoteInfo && remoteInfo.entry) {\n        return `${remoteInfo.name}:${remoteInfo.entry}`;\n    } else {\n        return `${remoteInfo.name}`;\n    }\n}\nfunction isRemoteInfoWithEntry(remote) {\n    return typeof remote.entry !== 'undefined';\n}\nfunction isPureRemoteEntry(remote) {\n    return !remote.entry.includes('.json') && remote.entry.includes('.js');\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nfunction isObject(val) {\n    return val && typeof val === 'object';\n}\nconst objectToString = Object.prototype.toString;\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isPlainObject(val) {\n    return objectToString.call(val) === '[object Object]';\n}\nfunction arrayOptions(options) {\n    return Array.isArray(options) ? options : [\n        options\n    ];\n}\nfunction getRemoteEntryInfoFromSnapshot(snapshot) {\n    const defaultRemoteEntryInfo = {\n        url: '',\n        type: 'global',\n        globalName: ''\n    };\n    if (isBrowserEnv()) {\n        return 'remoteEntry' in snapshot ? {\n            url: snapshot.remoteEntry,\n            type: snapshot.remoteEntryType,\n            globalName: snapshot.globalName\n        } : defaultRemoteEntryInfo;\n    }\n    if ('ssrRemoteEntry' in snapshot) {\n        return {\n            url: snapshot.ssrRemoteEntry || defaultRemoteEntryInfo.url,\n            type: snapshot.ssrRemoteEntryType || defaultRemoteEntryInfo.type,\n            globalName: snapshot.globalName\n        };\n    }\n    return defaultRemoteEntryInfo;\n}\n\nfunction _extends$1() {\n    _extends$1 = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends$1.apply(this, arguments);\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst nativeGlobal = (()=>{\n    try {\n        return new Function('return this')();\n    } catch (e) {\n        return globalThis;\n    }\n})();\nconst Global = nativeGlobal;\nfunction definePropertyGlobalVal(target, key, val) {\n    Object.defineProperty(target, key, {\n        value: val,\n        configurable: false,\n        writable: true\n    });\n}\nfunction includeOwnProperty(target, key) {\n    return Object.hasOwnProperty.call(target, key);\n}\n// This section is to prevent encapsulation by certain microfrontend frameworks. Due to reuse policies, sandbox escapes.\n// The sandbox in the microfrontend does not replicate the value of 'configurable'.\n// If there is no loading content on the global object, this section defines the loading object.\nif (!includeOwnProperty(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__')) {\n    definePropertyGlobalVal(globalThis, '__GLOBAL_LOADING_REMOTE_ENTRY__', {});\n}\nconst globalLoading = globalThis.__GLOBAL_LOADING_REMOTE_ENTRY__;\nfunction setGlobalDefaultVal(target) {\n    var _target___FEDERATION__, _target___FEDERATION__1, _target___FEDERATION__2, _target___FEDERATION__3, _target___FEDERATION__4, _target___FEDERATION__5;\n    if (includeOwnProperty(target, '__VMOK__') && !includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', target.__VMOK__);\n    }\n    if (!includeOwnProperty(target, '__FEDERATION__')) {\n        definePropertyGlobalVal(target, '__FEDERATION__', {\n            __GLOBAL_PLUGIN__: [],\n            __INSTANCES__: [],\n            moduleInfo: {},\n            __SHARE__: {},\n            __MANIFEST_LOADING__: {},\n            __PRELOADED_MAP__: new Map()\n        });\n        definePropertyGlobalVal(target, '__VMOK__', target.__FEDERATION__);\n    }\n    var ___GLOBAL_PLUGIN__;\n    (___GLOBAL_PLUGIN__ = (_target___FEDERATION__ = target.__FEDERATION__).__GLOBAL_PLUGIN__) != null ? ___GLOBAL_PLUGIN__ : _target___FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    var ___INSTANCES__;\n    (___INSTANCES__ = (_target___FEDERATION__1 = target.__FEDERATION__).__INSTANCES__) != null ? ___INSTANCES__ : _target___FEDERATION__1.__INSTANCES__ = [];\n    var _moduleInfo;\n    (_moduleInfo = (_target___FEDERATION__2 = target.__FEDERATION__).moduleInfo) != null ? _moduleInfo : _target___FEDERATION__2.moduleInfo = {};\n    var ___SHARE__;\n    (___SHARE__ = (_target___FEDERATION__3 = target.__FEDERATION__).__SHARE__) != null ? ___SHARE__ : _target___FEDERATION__3.__SHARE__ = {};\n    var ___MANIFEST_LOADING__;\n    (___MANIFEST_LOADING__ = (_target___FEDERATION__4 = target.__FEDERATION__).__MANIFEST_LOADING__) != null ? ___MANIFEST_LOADING__ : _target___FEDERATION__4.__MANIFEST_LOADING__ = {};\n    var ___PRELOADED_MAP__;\n    (___PRELOADED_MAP__ = (_target___FEDERATION__5 = target.__FEDERATION__).__PRELOADED_MAP__) != null ? ___PRELOADED_MAP__ : _target___FEDERATION__5.__PRELOADED_MAP__ = new Map();\n}\nsetGlobalDefaultVal(globalThis);\nsetGlobalDefaultVal(nativeGlobal);\nfunction resetFederationGlobalInfo() {\n    globalThis.__FEDERATION__.__GLOBAL_PLUGIN__ = [];\n    globalThis.__FEDERATION__.__INSTANCES__ = [];\n    globalThis.__FEDERATION__.moduleInfo = {};\n    globalThis.__FEDERATION__.__SHARE__ = {};\n    globalThis.__FEDERATION__.__MANIFEST_LOADING__ = {};\n}\nfunction getGlobalFederationInstance(name, version) {\n    const buildId = getBuilderId();\n    return globalThis.__FEDERATION__.__INSTANCES__.find((GMInstance)=>{\n        if (buildId && GMInstance.options.id === getBuilderId()) {\n            return true;\n        }\n        if (GMInstance.options.name === name && !GMInstance.options.version && !version) {\n            return true;\n        }\n        if (GMInstance.options.name === name && version && GMInstance.options.version === version) {\n            return true;\n        }\n        return false;\n    });\n}\nfunction setGlobalFederationInstance(FederationInstance) {\n    globalThis.__FEDERATION__.__INSTANCES__.push(FederationInstance);\n}\nfunction getGlobalFederationConstructor() {\n    return globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__;\n}\nfunction setGlobalFederationConstructor(FederationConstructor, isDebug = isDebugMode()) {\n    if (isDebug) {\n        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR__ = FederationConstructor;\n        globalThis.__FEDERATION__.__DEBUG_CONSTRUCTOR_VERSION__ = \"0.5.2\";\n    }\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction getInfoWithoutType(target, key) {\n    if (typeof key === 'string') {\n        const keyRes = target[key];\n        if (keyRes) {\n            return {\n                value: target[key],\n                key: key\n            };\n        } else {\n            const targetKeys = Object.keys(target);\n            for (const targetKey of targetKeys){\n                const [targetTypeOrName, _] = targetKey.split(':');\n                const nKey = `${targetTypeOrName}:${key}`;\n                const typeWithKeyRes = target[nKey];\n                if (typeWithKeyRes) {\n                    return {\n                        value: typeWithKeyRes,\n                        key: nKey\n                    };\n                }\n            }\n            return {\n                value: undefined,\n                key: key\n            };\n        }\n    } else {\n        throw new Error('key must be string');\n    }\n}\nconst getGlobalSnapshot = ()=>nativeGlobal.__FEDERATION__.moduleInfo;\nconst getTargetSnapshotInfoByModuleInfo = (moduleInfo, snapshot)=>{\n    // Check if the remote is included in the hostSnapshot\n    const moduleKey = getFMId(moduleInfo);\n    const getModuleInfo = getInfoWithoutType(snapshot, moduleKey).value;\n    // The remoteSnapshot might not include a version\n    if (getModuleInfo && !getModuleInfo.version && 'version' in moduleInfo && moduleInfo['version']) {\n        getModuleInfo.version = moduleInfo['version'];\n    }\n    if (getModuleInfo) {\n        return getModuleInfo;\n    }\n    // If the remote is not included in the hostSnapshot, deploy a micro app snapshot\n    if ('version' in moduleInfo && moduleInfo['version']) {\n        const { version } = moduleInfo, resModuleInfo = _object_without_properties_loose(moduleInfo, [\n            \"version\"\n        ]);\n        const moduleKeyWithoutVersion = getFMId(resModuleInfo);\n        const getModuleInfoWithoutVersion = getInfoWithoutType(nativeGlobal.__FEDERATION__.moduleInfo, moduleKeyWithoutVersion).value;\n        if ((getModuleInfoWithoutVersion == null ? void 0 : getModuleInfoWithoutVersion.version) === version) {\n            return getModuleInfoWithoutVersion;\n        }\n    }\n    return;\n};\nconst getGlobalSnapshotInfoByModuleInfo = (moduleInfo)=>getTargetSnapshotInfoByModuleInfo(moduleInfo, nativeGlobal.__FEDERATION__.moduleInfo);\nconst setGlobalSnapshotInfoByModuleInfo = (remoteInfo, moduleDetailInfo)=>{\n    const moduleKey = getFMId(remoteInfo);\n    nativeGlobal.__FEDERATION__.moduleInfo[moduleKey] = moduleDetailInfo;\n    return nativeGlobal.__FEDERATION__.moduleInfo;\n};\nconst addGlobalSnapshot = (moduleInfos)=>{\n    nativeGlobal.__FEDERATION__.moduleInfo = _extends$1({}, nativeGlobal.__FEDERATION__.moduleInfo, moduleInfos);\n    return ()=>{\n        const keys = Object.keys(moduleInfos);\n        for (const key of keys){\n            delete nativeGlobal.__FEDERATION__.moduleInfo[key];\n        }\n    };\n};\nconst getRemoteEntryExports = (name, globalName)=>{\n    const remoteEntryKey = globalName || `__FEDERATION_${name}:custom__`;\n    const entryExports = globalThis[remoteEntryKey];\n    return {\n        remoteEntryKey,\n        entryExports\n    };\n};\n// This function is used to register global plugins.\n// It iterates over the provided plugins and checks if they are already registered.\n// If a plugin is not registered, it is added to the global plugins.\n// If a plugin is already registered, a warning message is logged.\nconst registerGlobalPlugins = (plugins)=>{\n    const { __GLOBAL_PLUGIN__ } = nativeGlobal.__FEDERATION__;\n    plugins.forEach((plugin)=>{\n        if (__GLOBAL_PLUGIN__.findIndex((p)=>p.name === plugin.name) === -1) {\n            __GLOBAL_PLUGIN__.push(plugin);\n        } else {\n            warn(`The plugin ${plugin.name} has been registered.`);\n        }\n    });\n};\nconst getGlobalHostPlugins = ()=>nativeGlobal.__FEDERATION__.__GLOBAL_PLUGIN__;\nconst getPreloaded = (id)=>globalThis.__FEDERATION__.__PRELOADED_MAP__.get(id);\nconst setPreloaded = (id)=>globalThis.__FEDERATION__.__PRELOADED_MAP__.set(id, true);\n\nconst DEFAULT_SCOPE = 'default';\nconst DEFAULT_REMOTE_TYPE = 'global';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// those constants are based on https://www.rubydoc.info/gems/semantic_range/3.0.0/SemanticRange#BUILDIDENTIFIER-constant\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nconst buildIdentifier = '[0-9A-Za-z-]+';\nconst build = `(?:\\\\+(${buildIdentifier}(?:\\\\.${buildIdentifier})*))`;\nconst numericIdentifier = '0|[1-9]\\\\d*';\nconst numericIdentifierLoose = '[0-9]+';\nconst nonNumericIdentifier = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\nconst preReleaseIdentifierLoose = `(?:${numericIdentifierLoose}|${nonNumericIdentifier})`;\nconst preReleaseLoose = `(?:-?(${preReleaseIdentifierLoose}(?:\\\\.${preReleaseIdentifierLoose})*))`;\nconst preReleaseIdentifier = `(?:${numericIdentifier}|${nonNumericIdentifier})`;\nconst preRelease = `(?:-(${preReleaseIdentifier}(?:\\\\.${preReleaseIdentifier})*))`;\nconst xRangeIdentifier = `${numericIdentifier}|x|X|\\\\*`;\nconst xRangePlain = `[v=\\\\s]*(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:\\\\.(${xRangeIdentifier})(?:${preRelease})?${build}?)?)?`;\nconst hyphenRange = `^\\\\s*(${xRangePlain})\\\\s+-\\\\s+(${xRangePlain})\\\\s*$`;\nconst mainVersionLoose = `(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})\\\\.(${numericIdentifierLoose})`;\nconst loosePlain = `[v=\\\\s]*${mainVersionLoose}${preReleaseLoose}?${build}?`;\nconst gtlt = '((?:<|>)?=?)';\nconst comparatorTrim = `(\\\\s*)${gtlt}\\\\s*(${loosePlain}|${xRangePlain})`;\nconst loneTilde = '(?:~>?)';\nconst tildeTrim = `(\\\\s*)${loneTilde}\\\\s+`;\nconst loneCaret = '(?:\\\\^)';\nconst caretTrim = `(\\\\s*)${loneCaret}\\\\s+`;\nconst star = '(<|>)?=?\\\\s*\\\\*';\nconst caret = `^${loneCaret}${xRangePlain}$`;\nconst mainVersion = `(${numericIdentifier})\\\\.(${numericIdentifier})\\\\.(${numericIdentifier})`;\nconst fullPlain = `v?${mainVersion}${preRelease}?${build}?`;\nconst tilde = `^${loneTilde}${xRangePlain}$`;\nconst xRange = `^${gtlt}\\\\s*${xRangePlain}$`;\nconst comparator = `^${gtlt}\\\\s*(${fullPlain})$|^$`;\n// copy from semver package\nconst gte0 = '^\\\\s*>=\\\\s*0.0.0\\\\s*$';\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseRegex(source) {\n    return new RegExp(source);\n}\nfunction isXVersion(version) {\n    return !version || version.toLowerCase() === 'x' || version === '*';\n}\nfunction pipe(...fns) {\n    return (x)=>fns.reduce((v, f)=>f(v), x);\n}\nfunction extractComparator(comparatorString) {\n    return comparatorString.match(parseRegex(comparator));\n}\nfunction combineVersion(major, minor, patch, preRelease) {\n    const mainVersion = `${major}.${minor}.${patch}`;\n    if (preRelease) {\n        return `${mainVersion}-${preRelease}`;\n    }\n    return mainVersion;\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseHyphen(range) {\n    return range.replace(parseRegex(hyphenRange), (_range, from, fromMajor, fromMinor, fromPatch, _fromPreRelease, _fromBuild, to, toMajor, toMinor, toPatch, toPreRelease)=>{\n        if (isXVersion(fromMajor)) {\n            from = '';\n        } else if (isXVersion(fromMinor)) {\n            from = `>=${fromMajor}.0.0`;\n        } else if (isXVersion(fromPatch)) {\n            from = `>=${fromMajor}.${fromMinor}.0`;\n        } else {\n            from = `>=${from}`;\n        }\n        if (isXVersion(toMajor)) {\n            to = '';\n        } else if (isXVersion(toMinor)) {\n            to = `<${Number(toMajor) + 1}.0.0-0`;\n        } else if (isXVersion(toPatch)) {\n            to = `<${toMajor}.${Number(toMinor) + 1}.0-0`;\n        } else if (toPreRelease) {\n            to = `<=${toMajor}.${toMinor}.${toPatch}-${toPreRelease}`;\n        } else {\n            to = `<=${to}`;\n        }\n        return `${from} ${to}`.trim();\n    });\n}\nfunction parseComparatorTrim(range) {\n    return range.replace(parseRegex(comparatorTrim), '$1$2$3');\n}\nfunction parseTildeTrim(range) {\n    return range.replace(parseRegex(tildeTrim), '$1~');\n}\nfunction parseCaretTrim(range) {\n    return range.replace(parseRegex(caretTrim), '$1^');\n}\nfunction parseCarets(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(caret), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                if (major === '0') {\n                    return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n                } else {\n                    return `>=${major}.${minor}.0 <${Number(major) + 1}.0.0-0`;\n                }\n            } else if (preRelease) {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                } else {\n                    return `>=${major}.${minor}.${patch}-${preRelease} <${Number(major) + 1}.0.0-0`;\n                }\n            } else {\n                if (major === '0') {\n                    if (minor === '0') {\n                        return `>=${major}.${minor}.${patch} <${major}.${minor}.${Number(patch) + 1}-0`;\n                    } else {\n                        return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n                    }\n                }\n                return `>=${major}.${minor}.${patch} <${Number(major) + 1}.0.0-0`;\n            }\n        })).join(' ');\n}\nfunction parseTildes(range) {\n    return range.trim().split(/\\s+/).map((rangeVersion)=>rangeVersion.replace(parseRegex(tilde), (_, major, minor, patch, preRelease)=>{\n            if (isXVersion(major)) {\n                return '';\n            } else if (isXVersion(minor)) {\n                return `>=${major}.0.0 <${Number(major) + 1}.0.0-0`;\n            } else if (isXVersion(patch)) {\n                return `>=${major}.${minor}.0 <${major}.${Number(minor) + 1}.0-0`;\n            } else if (preRelease) {\n                return `>=${major}.${minor}.${patch}-${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return `>=${major}.${minor}.${patch} <${major}.${Number(minor) + 1}.0-0`;\n        })).join(' ');\n}\nfunction parseXRanges(range) {\n    return range.split(/\\s+/).map((rangeVersion)=>rangeVersion.trim().replace(parseRegex(xRange), (ret, gtlt, major, minor, patch, preRelease)=>{\n            const isXMajor = isXVersion(major);\n            const isXMinor = isXMajor || isXVersion(minor);\n            const isXPatch = isXMinor || isXVersion(patch);\n            if (gtlt === '=' && isXPatch) {\n                gtlt = '';\n            }\n            preRelease = '';\n            if (isXMajor) {\n                if (gtlt === '>' || gtlt === '<') {\n                    // nothing is allowed\n                    return '<0.0.0-0';\n                } else {\n                    // nothing is forbidden\n                    return '*';\n                }\n            } else if (gtlt && isXPatch) {\n                // replace X with 0\n                if (isXMinor) {\n                    minor = 0;\n                }\n                patch = 0;\n                if (gtlt === '>') {\n                    // >1 => >=2.0.0\n                    // >1.2 => >=1.3.0\n                    gtlt = '>=';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                        minor = 0;\n                        patch = 0;\n                    } else {\n                        minor = Number(minor) + 1;\n                        patch = 0;\n                    }\n                } else if (gtlt === '<=') {\n                    // <=0.7.x is actually <0.8.0, since any 0.7.x should pass\n                    // Similarly, <=7.x is actually <8.0.0, etc.\n                    gtlt = '<';\n                    if (isXMinor) {\n                        major = Number(major) + 1;\n                    } else {\n                        minor = Number(minor) + 1;\n                    }\n                }\n                if (gtlt === '<') {\n                    preRelease = '-0';\n                }\n                return `${gtlt + major}.${minor}.${patch}${preRelease}`;\n            } else if (isXMinor) {\n                return `>=${major}.0.0${preRelease} <${Number(major) + 1}.0.0-0`;\n            } else if (isXPatch) {\n                return `>=${major}.${minor}.0${preRelease} <${major}.${Number(minor) + 1}.0-0`;\n            }\n            return ret;\n        })).join(' ');\n}\nfunction parseStar(range) {\n    return range.trim().replace(parseRegex(star), '');\n}\nfunction parseGTE0(comparatorString) {\n    return comparatorString.trim().replace(parseRegex(gte0), '');\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\n// Copyright (c)\n// vite-plugin-federation is licensed under Mulan PSL v2.\n// You can use this software according to the terms and conditions of the Mulan PSL v2.\n// You may obtain a copy of Mulan PSL v2 at:\n//      http://license.coscl.org.cn/MulanPSL2\n// THIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\n// See the Mulan PSL v2 for more details.\nfunction compareAtom(rangeAtom, versionAtom) {\n    rangeAtom = Number(rangeAtom) || rangeAtom;\n    versionAtom = Number(versionAtom) || versionAtom;\n    if (rangeAtom > versionAtom) {\n        return 1;\n    }\n    if (rangeAtom === versionAtom) {\n        return 0;\n    }\n    return -1;\n}\nfunction comparePreRelease(rangeAtom, versionAtom) {\n    const { preRelease: rangePreRelease } = rangeAtom;\n    const { preRelease: versionPreRelease } = versionAtom;\n    if (rangePreRelease === undefined && Boolean(versionPreRelease)) {\n        return 1;\n    }\n    if (Boolean(rangePreRelease) && versionPreRelease === undefined) {\n        return -1;\n    }\n    if (rangePreRelease === undefined && versionPreRelease === undefined) {\n        return 0;\n    }\n    for(let i = 0, n = rangePreRelease.length; i <= n; i++){\n        const rangeElement = rangePreRelease[i];\n        const versionElement = versionPreRelease[i];\n        if (rangeElement === versionElement) {\n            continue;\n        }\n        if (rangeElement === undefined && versionElement === undefined) {\n            return 0;\n        }\n        if (!rangeElement) {\n            return 1;\n        }\n        if (!versionElement) {\n            return -1;\n        }\n        return compareAtom(rangeElement, versionElement);\n    }\n    return 0;\n}\nfunction compareVersion(rangeAtom, versionAtom) {\n    return compareAtom(rangeAtom.major, versionAtom.major) || compareAtom(rangeAtom.minor, versionAtom.minor) || compareAtom(rangeAtom.patch, versionAtom.patch) || comparePreRelease(rangeAtom, versionAtom);\n}\nfunction eq(rangeAtom, versionAtom) {\n    return rangeAtom.version === versionAtom.version;\n}\nfunction compare(rangeAtom, versionAtom) {\n    switch(rangeAtom.operator){\n        case '':\n        case '=':\n            return eq(rangeAtom, versionAtom);\n        case '>':\n            return compareVersion(rangeAtom, versionAtom) < 0;\n        case '>=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) < 0;\n        case '<':\n            return compareVersion(rangeAtom, versionAtom) > 0;\n        case '<=':\n            return eq(rangeAtom, versionAtom) || compareVersion(rangeAtom, versionAtom) > 0;\n        case undefined:\n            {\n                // mean * or x -> all versions\n                return true;\n            }\n        default:\n            return false;\n    }\n}\n\n// fork from https://github.com/originjs/vite-plugin-federation/blob/v1.1.12/packages/lib/src/utils/semver/index.ts\nfunction parseComparatorString(range) {\n    return pipe(// handle caret\n    // ^ --> * (any, kinda silly)\n    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n    // ^1.2.3 --> >=1.2.3 <2.0.0-0\n    // ^1.2.0 --> >=1.2.0 <2.0.0-0\n    parseCarets, // handle tilde\n    // ~, ~> --> * (any, kinda silly)\n    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n    parseTildes, parseXRanges, parseStar)(range);\n}\nfunction parseRange(range) {\n    return pipe(// handle hyphenRange\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    parseHyphen, // handle trim comparator\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    parseComparatorTrim, // handle trim tilde\n    // `~ 1.2.3` => `~1.2.3`\n    parseTildeTrim, // handle trim caret\n    // `^ 1.2.3` => `^1.2.3`\n    parseCaretTrim)(range.trim()).split(/\\s+/).join(' ');\n}\nfunction satisfy(version, range) {\n    if (!version) {\n        return false;\n    }\n    const parsedRange = parseRange(range);\n    const parsedComparator = parsedRange.split(' ').map((rangeVersion)=>parseComparatorString(rangeVersion)).join(' ');\n    const comparators = parsedComparator.split(/\\s+/).map((comparator)=>parseGTE0(comparator));\n    const extractedVersion = extractComparator(version);\n    if (!extractedVersion) {\n        return false;\n    }\n    const [, versionOperator, , versionMajor, versionMinor, versionPatch, versionPreRelease] = extractedVersion;\n    const versionAtom = {\n        operator: versionOperator,\n        version: combineVersion(versionMajor, versionMinor, versionPatch, versionPreRelease),\n        major: versionMajor,\n        minor: versionMinor,\n        patch: versionPatch,\n        preRelease: versionPreRelease == null ? void 0 : versionPreRelease.split('.')\n    };\n    for (const comparator of comparators){\n        const extractedComparator = extractComparator(comparator);\n        if (!extractedComparator) {\n            return false;\n        }\n        const [, rangeOperator, , rangeMajor, rangeMinor, rangePatch, rangePreRelease] = extractedComparator;\n        const rangeAtom = {\n            operator: rangeOperator,\n            version: combineVersion(rangeMajor, rangeMinor, rangePatch, rangePreRelease),\n            major: rangeMajor,\n            minor: rangeMinor,\n            patch: rangePatch,\n            preRelease: rangePreRelease == null ? void 0 : rangePreRelease.split('.')\n        };\n        if (!compare(rangeAtom, versionAtom)) {\n            return false; // early return\n        }\n    }\n    return true;\n}\n\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction formatShare(shareArgs, from, name, shareStrategy) {\n    let get;\n    if ('get' in shareArgs) {\n        // eslint-disable-next-line prefer-destructuring\n        get = shareArgs.get;\n    } else if ('lib' in shareArgs) {\n        get = ()=>Promise.resolve(shareArgs.lib);\n    } else {\n        get = ()=>Promise.resolve(()=>{\n                throw new Error(`Can not get shared '${name}'!`);\n            });\n    }\n    if (shareArgs.strategy) {\n        warn(`\"shared.strategy is deprecated, please set in initOptions.shareStrategy instead!\"`);\n    }\n    var _shareArgs_version, _shareArgs_scope, _shareArgs_strategy;\n    return _extends({\n        deps: [],\n        useIn: [],\n        from,\n        loading: null\n    }, shareArgs, {\n        shareConfig: _extends({\n            requiredVersion: `^${shareArgs.version}`,\n            singleton: false,\n            eager: false,\n            strictVersion: false\n        }, shareArgs.shareConfig),\n        get,\n        loaded: (shareArgs == null ? void 0 : shareArgs.loaded) || 'lib' in shareArgs ? true : undefined,\n        version: (_shareArgs_version = shareArgs.version) != null ? _shareArgs_version : '0',\n        scope: Array.isArray(shareArgs.scope) ? shareArgs.scope : [\n            (_shareArgs_scope = shareArgs.scope) != null ? _shareArgs_scope : 'default'\n        ],\n        strategy: ((_shareArgs_strategy = shareArgs.strategy) != null ? _shareArgs_strategy : shareStrategy) || 'version-first'\n    });\n}\nfunction formatShareConfigs(globalOptions, userOptions) {\n    const shareArgs = userOptions.shared || {};\n    const from = userOptions.name;\n    const shareInfos = Object.keys(shareArgs).reduce((res, pkgName)=>{\n        const arrayShareArgs = arrayOptions(shareArgs[pkgName]);\n        res[pkgName] = res[pkgName] || [];\n        arrayShareArgs.forEach((shareConfig)=>{\n            res[pkgName].push(formatShare(shareConfig, from, pkgName, userOptions.shareStrategy));\n        });\n        return res;\n    }, {});\n    const shared = _extends({}, globalOptions.shared);\n    Object.keys(shareInfos).forEach((shareKey)=>{\n        if (!shared[shareKey]) {\n            shared[shareKey] = shareInfos[shareKey];\n        } else {\n            shareInfos[shareKey].forEach((newUserSharedOptions)=>{\n                const isSameVersion = shared[shareKey].find((sharedVal)=>sharedVal.version === newUserSharedOptions.version);\n                if (!isSameVersion) {\n                    shared[shareKey].push(newUserSharedOptions);\n                }\n            });\n        }\n    });\n    return {\n        shared,\n        shareInfos\n    };\n}\nfunction versionLt(a, b) {\n    const transformInvalidVersion = (version)=>{\n        const isNumberVersion = !Number.isNaN(Number(version));\n        if (isNumberVersion) {\n            const splitArr = version.split('.');\n            let validVersion = version;\n            for(let i = 0; i < 3 - splitArr.length; i++){\n                validVersion += '.0';\n            }\n            return validVersion;\n        }\n        return version;\n    };\n    if (satisfy(transformInvalidVersion(a), `<=${transformInvalidVersion(b)}`)) {\n        return true;\n    } else {\n        return false;\n    }\n}\nconst findVersion = (shareVersionMap, cb)=>{\n    const callback = cb || function(prev, cur) {\n        return versionLt(prev, cur);\n    };\n    return Object.keys(shareVersionMap).reduce((prev, cur)=>{\n        if (!prev) {\n            return cur;\n        }\n        if (callback(prev, cur)) {\n            return cur;\n        }\n        // default version is '0' https://github.com/webpack/webpack/blob/main/lib/sharing/ProvideSharedModule.js#L136\n        if (prev === '0') {\n            return cur;\n        }\n        return prev;\n    }, 0);\n};\nconst isLoaded = (shared)=>{\n    return Boolean(shared.loaded) || typeof shared.lib === 'function';\n};\nfunction findSingletonVersionOrderByVersion(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        return !isLoaded(versions[prev]) && versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction findSingletonVersionOrderByLoaded(shareScopeMap, scope, pkgName) {\n    const versions = shareScopeMap[scope][pkgName];\n    const callback = function(prev, cur) {\n        if (isLoaded(versions[cur])) {\n            if (isLoaded(versions[prev])) {\n                return Boolean(versionLt(prev, cur));\n            } else {\n                return true;\n            }\n        }\n        if (isLoaded(versions[prev])) {\n            return false;\n        }\n        return versionLt(prev, cur);\n    };\n    return findVersion(shareScopeMap[scope][pkgName], callback);\n}\nfunction getFindShareFunction(strategy) {\n    if (strategy === 'loaded-first') {\n        return findSingletonVersionOrderByLoaded;\n    }\n    return findSingletonVersionOrderByVersion;\n}\nfunction getRegisteredShare(localShareScopeMap, pkgName, shareInfo, resolveShare) {\n    if (!localShareScopeMap) {\n        return;\n    }\n    const { shareConfig, scope = DEFAULT_SCOPE, strategy } = shareInfo;\n    const scopes = Array.isArray(scope) ? scope : [\n        scope\n    ];\n    for (const sc of scopes){\n        if (shareConfig && localShareScopeMap[sc] && localShareScopeMap[sc][pkgName]) {\n            const { requiredVersion } = shareConfig;\n            const findShareFunction = getFindShareFunction(strategy);\n            const maxOrSingletonVersion = findShareFunction(localShareScopeMap, sc, pkgName);\n            //@ts-ignore\n            const defaultResolver = ()=>{\n                if (shareConfig.singleton) {\n                    if (typeof requiredVersion === 'string' && !satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        const msg = `Version ${maxOrSingletonVersion} from ${maxOrSingletonVersion && localShareScopeMap[sc][pkgName][maxOrSingletonVersion].from} of shared singleton module ${pkgName} does not satisfy the requirement of ${shareInfo.from} which needs ${requiredVersion})`;\n                        if (shareConfig.strictVersion) {\n                            error(msg);\n                        } else {\n                            warn(msg);\n                        }\n                    }\n                    return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                } else {\n                    if (requiredVersion === false || requiredVersion === '*') {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    if (satisfy(maxOrSingletonVersion, requiredVersion)) {\n                        return localShareScopeMap[sc][pkgName][maxOrSingletonVersion];\n                    }\n                    for (const [versionKey, versionValue] of Object.entries(localShareScopeMap[sc][pkgName])){\n                        if (satisfy(versionKey, requiredVersion)) {\n                            return versionValue;\n                        }\n                    }\n                }\n            };\n            const params = {\n                shareScopeMap: localShareScopeMap,\n                scope: sc,\n                pkgName,\n                version: maxOrSingletonVersion,\n                GlobalFederation: Global.__FEDERATION__,\n                resolver: defaultResolver\n            };\n            const resolveShared = resolveShare.emit(params) || params;\n            return resolveShared.resolver();\n        }\n    }\n}\nfunction getGlobalShareScope() {\n    return Global.__FEDERATION__.__SHARE__;\n}\nfunction getTargetSharedOptions(options) {\n    const { pkgName, extraOptions, shareInfos } = options;\n    const defaultResolver = (sharedOptions)=>{\n        if (!sharedOptions) {\n            return undefined;\n        }\n        const shareVersionMap = {};\n        sharedOptions.forEach((shared)=>{\n            shareVersionMap[shared.version] = shared;\n        });\n        const callback = function(prev, cur) {\n            return !isLoaded(shareVersionMap[prev]) && versionLt(prev, cur);\n        };\n        const maxVersion = findVersion(shareVersionMap, callback);\n        return shareVersionMap[maxVersion];\n    };\n    var _extraOptions_resolver;\n    const resolver = (_extraOptions_resolver = extraOptions == null ? void 0 : extraOptions.resolver) != null ? _extraOptions_resolver : defaultResolver;\n    return Object.assign({}, resolver(shareInfos[pkgName]), extraOptions == null ? void 0 : extraOptions.customShareInfo);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUvZGlzdC9zaGFyZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLFdBQVcsS0FBa0QsR0FBRyxjQUEyQixHQUFHLENBQUU7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsSUFBSSxZQUFZO0FBQ3REO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxJQUFJLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsSUFBSSxZQUFZO0FBQ3REO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QixhQUFhLElBQUksSUFBSTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCLEdBQUcsbUJBQW1CO0FBQ3hELE1BQU07QUFDTixrQkFBa0IsZ0JBQWdCLEdBQUcsaUJBQWlCO0FBQ3RELE1BQU07QUFDTixrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQStDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUIsT0FBTyxzRkFBc0YsNkJBQTZCLFNBQVMsc0NBQXNDLGdCQUFnQixjQUFjLGdCQUFnQjtBQUM3UjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRTI4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlbW90ZS8uL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vcnVudGltZS9kaXN0L3NoYXJlLmVzbS5qcz8xYWY4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldEJ1aWxkZXJJZCgpIHtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICByZXR1cm4gdHlwZW9mIEZFREVSQVRJT05fQlVJTERfSURFTlRJRklFUiAhPT0gJ3VuZGVmaW5lZCcgPyBGRURFUkFUSU9OX0JVSUxEX0lERU5USUZJRVIgOiAnJztcbn1cbmZ1bmN0aW9uIGlzRGVidWdNb2RlKCkge1xuICAgIHJldHVybiBCb29sZWFuKFwiXCIpO1xufVxuZnVuY3Rpb24gaXNCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuY29uc3QgTE9HX0NBVEVHT1JZID0gJ1sgRmVkZXJhdGlvbiBSdW50aW1lIF0nO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZykge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIGVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgaWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG1zZy5tZXNzYWdlID0gYCR7TE9HX0NBVEVHT1JZfTogJHttc2cubWVzc2FnZX1gO1xuICAgICAgICB0aHJvdyBtc2c7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbn1cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgaWYgKG1zZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIG1zZy5tZXNzYWdlID0gYCR7TE9HX0NBVEVHT1JZfTogJHttc2cubWVzc2FnZX1gO1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7TE9HX0NBVEVHT1JZfTogJHttc2d9YCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIuZmluZEluZGV4KChuYW1lKT0+bmFtZSA9PT0gaXRlbSkgPT09IC0xKSB7XG4gICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gZ2V0Rk1JZChyZW1vdGVJbmZvKSB7XG4gICAgaWYgKCd2ZXJzaW9uJyBpbiByZW1vdGVJbmZvICYmIHJlbW90ZUluZm8udmVyc2lvbikge1xuICAgICAgICByZXR1cm4gYCR7cmVtb3RlSW5mby5uYW1lfToke3JlbW90ZUluZm8udmVyc2lvbn1gO1xuICAgIH0gZWxzZSBpZiAoJ2VudHJ5JyBpbiByZW1vdGVJbmZvICYmIHJlbW90ZUluZm8uZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGAke3JlbW90ZUluZm8ubmFtZX06JHtyZW1vdGVJbmZvLmVudHJ5fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke3JlbW90ZUluZm8ubmFtZX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUmVtb3RlSW5mb1dpdGhFbnRyeShyZW1vdGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHJlbW90ZS5lbnRyeSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1B1cmVSZW1vdGVFbnRyeShyZW1vdGUpIHtcbiAgICByZXR1cm4gIXJlbW90ZS5lbnRyeS5pbmNsdWRlcygnLmpzb24nKSAmJiByZW1vdGUuZW50cnkuaW5jbHVkZXMoJy5qcycpO1xufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhpbmZvKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGluZm8sIG51bGwsIDIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmZ1bmN0aW9uIGFycmF5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob3B0aW9ucykgPyBvcHRpb25zIDogW1xuICAgICAgICBvcHRpb25zXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGdldFJlbW90ZUVudHJ5SW5mb0Zyb21TbmFwc2hvdChzbmFwc2hvdCkge1xuICAgIGNvbnN0IGRlZmF1bHRSZW1vdGVFbnRyeUluZm8gPSB7XG4gICAgICAgIHVybDogJycsXG4gICAgICAgIHR5cGU6ICdnbG9iYWwnLFxuICAgICAgICBnbG9iYWxOYW1lOiAnJ1xuICAgIH07XG4gICAgaWYgKGlzQnJvd3NlckVudigpKSB7XG4gICAgICAgIHJldHVybiAncmVtb3RlRW50cnknIGluIHNuYXBzaG90ID8ge1xuICAgICAgICAgICAgdXJsOiBzbmFwc2hvdC5yZW1vdGVFbnRyeSxcbiAgICAgICAgICAgIHR5cGU6IHNuYXBzaG90LnJlbW90ZUVudHJ5VHlwZSxcbiAgICAgICAgICAgIGdsb2JhbE5hbWU6IHNuYXBzaG90Lmdsb2JhbE5hbWVcbiAgICAgICAgfSA6IGRlZmF1bHRSZW1vdGVFbnRyeUluZm87XG4gICAgfVxuICAgIGlmICgnc3NyUmVtb3RlRW50cnknIGluIHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHNuYXBzaG90LnNzclJlbW90ZUVudHJ5IHx8IGRlZmF1bHRSZW1vdGVFbnRyeUluZm8udXJsLFxuICAgICAgICAgICAgdHlwZTogc25hcHNob3Quc3NyUmVtb3RlRW50cnlUeXBlIHx8IGRlZmF1bHRSZW1vdGVFbnRyeUluZm8udHlwZSxcbiAgICAgICAgICAgIGdsb2JhbE5hbWU6IHNuYXBzaG90Lmdsb2JhbE5hbWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZW1vdGVFbnRyeUluZm87XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzJDEoKSB7XG4gICAgX2V4dGVuZHMkMSA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuICAgIHJldHVybiBfZXh0ZW5kcyQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuICAgIGZvcihpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3QgbmF0aXZlR2xvYmFsID0gKCgpPT57XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgfVxufSkoKTtcbmNvbnN0IEdsb2JhbCA9IG5hdGl2ZUdsb2JhbDtcbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVPd25Qcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgIHJldHVybiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSk7XG59XG4vLyBUaGlzIHNlY3Rpb24gaXMgdG8gcHJldmVudCBlbmNhcHN1bGF0aW9uIGJ5IGNlcnRhaW4gbWljcm9mcm9udGVuZCBmcmFtZXdvcmtzLiBEdWUgdG8gcmV1c2UgcG9saWNpZXMsIHNhbmRib3ggZXNjYXBlcy5cbi8vIFRoZSBzYW5kYm94IGluIHRoZSBtaWNyb2Zyb250ZW5kIGRvZXMgbm90IHJlcGxpY2F0ZSB0aGUgdmFsdWUgb2YgJ2NvbmZpZ3VyYWJsZScuXG4vLyBJZiB0aGVyZSBpcyBubyBsb2FkaW5nIGNvbnRlbnQgb24gdGhlIGdsb2JhbCBvYmplY3QsIHRoaXMgc2VjdGlvbiBkZWZpbmVzIHRoZSBsb2FkaW5nIG9iamVjdC5cbmlmICghaW5jbHVkZU93blByb3BlcnR5KGdsb2JhbFRoaXMsICdfX0dMT0JBTF9MT0FESU5HX1JFTU9URV9FTlRSWV9fJykpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbChnbG9iYWxUaGlzLCAnX19HTE9CQUxfTE9BRElOR19SRU1PVEVfRU5UUllfXycsIHt9KTtcbn1cbmNvbnN0IGdsb2JhbExvYWRpbmcgPSBnbG9iYWxUaGlzLl9fR0xPQkFMX0xPQURJTkdfUkVNT1RFX0VOVFJZX187XG5mdW5jdGlvbiBzZXRHbG9iYWxEZWZhdWx0VmFsKHRhcmdldCkge1xuICAgIHZhciBfdGFyZ2V0X19fRkVERVJBVElPTl9fLCBfdGFyZ2V0X19fRkVERVJBVElPTl9fMSwgX3RhcmdldF9fX0ZFREVSQVRJT05fXzIsIF90YXJnZXRfX19GRURFUkFUSU9OX18zLCBfdGFyZ2V0X19fRkVERVJBVElPTl9fNCwgX3RhcmdldF9fX0ZFREVSQVRJT05fXzU7XG4gICAgaWYgKGluY2x1ZGVPd25Qcm9wZXJ0eSh0YXJnZXQsICdfX1ZNT0tfXycpICYmICFpbmNsdWRlT3duUHJvcGVydHkodGFyZ2V0LCAnX19GRURFUkFUSU9OX18nKSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eUdsb2JhbFZhbCh0YXJnZXQsICdfX0ZFREVSQVRJT05fXycsIHRhcmdldC5fX1ZNT0tfXyk7XG4gICAgfVxuICAgIGlmICghaW5jbHVkZU93blByb3BlcnR5KHRhcmdldCwgJ19fRkVERVJBVElPTl9fJykpIHtcbiAgICAgICAgZGVmaW5lUHJvcGVydHlHbG9iYWxWYWwodGFyZ2V0LCAnX19GRURFUkFUSU9OX18nLCB7XG4gICAgICAgICAgICBfX0dMT0JBTF9QTFVHSU5fXzogW10sXG4gICAgICAgICAgICBfX0lOU1RBTkNFU19fOiBbXSxcbiAgICAgICAgICAgIG1vZHVsZUluZm86IHt9LFxuICAgICAgICAgICAgX19TSEFSRV9fOiB7fSxcbiAgICAgICAgICAgIF9fTUFOSUZFU1RfTE9BRElOR19fOiB7fSxcbiAgICAgICAgICAgIF9fUFJFTE9BREVEX01BUF9fOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZmluZVByb3BlcnR5R2xvYmFsVmFsKHRhcmdldCwgJ19fVk1PS19fJywgdGFyZ2V0Ll9fRkVERVJBVElPTl9fKTtcbiAgICB9XG4gICAgdmFyIF9fX0dMT0JBTF9QTFVHSU5fXztcbiAgICAoX19fR0xPQkFMX1BMVUdJTl9fID0gKF90YXJnZXRfX19GRURFUkFUSU9OX18gPSB0YXJnZXQuX19GRURFUkFUSU9OX18pLl9fR0xPQkFMX1BMVUdJTl9fKSAhPSBudWxsID8gX19fR0xPQkFMX1BMVUdJTl9fIDogX3RhcmdldF9fX0ZFREVSQVRJT05fXy5fX0dMT0JBTF9QTFVHSU5fXyA9IFtdO1xuICAgIHZhciBfX19JTlNUQU5DRVNfXztcbiAgICAoX19fSU5TVEFOQ0VTX18gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXzEgPSB0YXJnZXQuX19GRURFUkFUSU9OX18pLl9fSU5TVEFOQ0VTX18pICE9IG51bGwgPyBfX19JTlNUQU5DRVNfXyA6IF90YXJnZXRfX19GRURFUkFUSU9OX18xLl9fSU5TVEFOQ0VTX18gPSBbXTtcbiAgICB2YXIgX21vZHVsZUluZm87XG4gICAgKF9tb2R1bGVJbmZvID0gKF90YXJnZXRfX19GRURFUkFUSU9OX18yID0gdGFyZ2V0Ll9fRkVERVJBVElPTl9fKS5tb2R1bGVJbmZvKSAhPSBudWxsID8gX21vZHVsZUluZm8gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fMi5tb2R1bGVJbmZvID0ge307XG4gICAgdmFyIF9fX1NIQVJFX187XG4gICAgKF9fX1NIQVJFX18gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXzMgPSB0YXJnZXQuX19GRURFUkFUSU9OX18pLl9fU0hBUkVfXykgIT0gbnVsbCA/IF9fX1NIQVJFX18gOiBfdGFyZ2V0X19fRkVERVJBVElPTl9fMy5fX1NIQVJFX18gPSB7fTtcbiAgICB2YXIgX19fTUFOSUZFU1RfTE9BRElOR19fO1xuICAgIChfX19NQU5JRkVTVF9MT0FESU5HX18gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXzQgPSB0YXJnZXQuX19GRURFUkFUSU9OX18pLl9fTUFOSUZFU1RfTE9BRElOR19fKSAhPSBudWxsID8gX19fTUFOSUZFU1RfTE9BRElOR19fIDogX3RhcmdldF9fX0ZFREVSQVRJT05fXzQuX19NQU5JRkVTVF9MT0FESU5HX18gPSB7fTtcbiAgICB2YXIgX19fUFJFTE9BREVEX01BUF9fO1xuICAgIChfX19QUkVMT0FERURfTUFQX18gPSAoX3RhcmdldF9fX0ZFREVSQVRJT05fXzUgPSB0YXJnZXQuX19GRURFUkFUSU9OX18pLl9fUFJFTE9BREVEX01BUF9fKSAhPSBudWxsID8gX19fUFJFTE9BREVEX01BUF9fIDogX3RhcmdldF9fX0ZFREVSQVRJT05fXzUuX19QUkVMT0FERURfTUFQX18gPSBuZXcgTWFwKCk7XG59XG5zZXRHbG9iYWxEZWZhdWx0VmFsKGdsb2JhbFRoaXMpO1xuc2V0R2xvYmFsRGVmYXVsdFZhbChuYXRpdmVHbG9iYWwpO1xuZnVuY3Rpb24gcmVzZXRGZWRlcmF0aW9uR2xvYmFsSW5mbygpIHtcbiAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fR0xPQkFMX1BMVUdJTl9fID0gW107XG4gICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fID0gW107XG4gICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvID0ge307XG4gICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX1NIQVJFX18gPSB7fTtcbiAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fTUFOSUZFU1RfTE9BRElOR19fID0ge307XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UobmFtZSwgdmVyc2lvbikge1xuICAgIGNvbnN0IGJ1aWxkSWQgPSBnZXRCdWlsZGVySWQoKTtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLmZpbmQoKEdNSW5zdGFuY2UpPT57XG4gICAgICAgIGlmIChidWlsZElkICYmIEdNSW5zdGFuY2Uub3B0aW9ucy5pZCA9PT0gZ2V0QnVpbGRlcklkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChHTUluc3RhbmNlLm9wdGlvbnMubmFtZSA9PT0gbmFtZSAmJiAhR01JbnN0YW5jZS5vcHRpb25zLnZlcnNpb24gJiYgIXZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChHTUluc3RhbmNlLm9wdGlvbnMubmFtZSA9PT0gbmFtZSAmJiB2ZXJzaW9uICYmIEdNSW5zdGFuY2Uub3B0aW9ucy52ZXJzaW9uID09PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxGZWRlcmF0aW9uSW5zdGFuY2UoRmVkZXJhdGlvbkluc3RhbmNlKSB7XG4gICAgZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0lOU1RBTkNFU19fLnB1c2goRmVkZXJhdGlvbkluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbEZlZGVyYXRpb25Db25zdHJ1Y3RvcigpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5fX0ZFREVSQVRJT05fXy5fX0RFQlVHX0NPTlNUUlVDVE9SX187XG59XG5mdW5jdGlvbiBzZXRHbG9iYWxGZWRlcmF0aW9uQ29uc3RydWN0b3IoRmVkZXJhdGlvbkNvbnN0cnVjdG9yLCBpc0RlYnVnID0gaXNEZWJ1Z01vZGUoKSkge1xuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgIGdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19ERUJVR19DT05TVFJVQ1RPUl9fID0gRmVkZXJhdGlvbkNvbnN0cnVjdG9yO1xuICAgICAgICBnbG9iYWxUaGlzLl9fRkVERVJBVElPTl9fLl9fREVCVUdfQ09OU1RSVUNUT1JfVkVSU0lPTl9fID0gXCIwLjUuMlwiO1xuICAgIH1cbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBnZXRJbmZvV2l0aG91dFR5cGUodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qga2V5UmVzID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChrZXlSZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRhcmdldFtrZXldLFxuICAgICAgICAgICAgICAgIGtleToga2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhcmdldEtleSBvZiB0YXJnZXRLZXlzKXtcbiAgICAgICAgICAgICAgICBjb25zdCBbdGFyZ2V0VHlwZU9yTmFtZSwgX10gPSB0YXJnZXRLZXkuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuS2V5ID0gYCR7dGFyZ2V0VHlwZU9yTmFtZX06JHtrZXl9YDtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlV2l0aEtleVJlcyA9IHRhcmdldFtuS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZVdpdGhLZXlSZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlV2l0aEtleVJlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbktleVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgfVxufVxuY29uc3QgZ2V0R2xvYmFsU25hcHNob3QgPSAoKT0+bmF0aXZlR2xvYmFsLl9fRkVERVJBVElPTl9fLm1vZHVsZUluZm87XG5jb25zdCBnZXRUYXJnZXRTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gPSAobW9kdWxlSW5mbywgc25hcHNob3QpPT57XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBpbmNsdWRlZCBpbiB0aGUgaG9zdFNuYXBzaG90XG4gICAgY29uc3QgbW9kdWxlS2V5ID0gZ2V0Rk1JZChtb2R1bGVJbmZvKTtcbiAgICBjb25zdCBnZXRNb2R1bGVJbmZvID0gZ2V0SW5mb1dpdGhvdXRUeXBlKHNuYXBzaG90LCBtb2R1bGVLZXkpLnZhbHVlO1xuICAgIC8vIFRoZSByZW1vdGVTbmFwc2hvdCBtaWdodCBub3QgaW5jbHVkZSBhIHZlcnNpb25cbiAgICBpZiAoZ2V0TW9kdWxlSW5mbyAmJiAhZ2V0TW9kdWxlSW5mby52ZXJzaW9uICYmICd2ZXJzaW9uJyBpbiBtb2R1bGVJbmZvICYmIG1vZHVsZUluZm9bJ3ZlcnNpb24nXSkge1xuICAgICAgICBnZXRNb2R1bGVJbmZvLnZlcnNpb24gPSBtb2R1bGVJbmZvWyd2ZXJzaW9uJ107XG4gICAgfVxuICAgIGlmIChnZXRNb2R1bGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBnZXRNb2R1bGVJbmZvO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgcmVtb3RlIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgaG9zdFNuYXBzaG90LCBkZXBsb3kgYSBtaWNybyBhcHAgc25hcHNob3RcbiAgICBpZiAoJ3ZlcnNpb24nIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mb1sndmVyc2lvbiddKSB7XG4gICAgICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gbW9kdWxlSW5mbywgcmVzTW9kdWxlSW5mbyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKG1vZHVsZUluZm8sIFtcbiAgICAgICAgICAgIFwidmVyc2lvblwiXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBtb2R1bGVLZXlXaXRob3V0VmVyc2lvbiA9IGdldEZNSWQocmVzTW9kdWxlSW5mbyk7XG4gICAgICAgIGNvbnN0IGdldE1vZHVsZUluZm9XaXRob3V0VmVyc2lvbiA9IGdldEluZm9XaXRob3V0VHlwZShuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbywgbW9kdWxlS2V5V2l0aG91dFZlcnNpb24pLnZhbHVlO1xuICAgICAgICBpZiAoKGdldE1vZHVsZUluZm9XaXRob3V0VmVyc2lvbiA9PSBudWxsID8gdm9pZCAwIDogZ2V0TW9kdWxlSW5mb1dpdGhvdXRWZXJzaW9uLnZlcnNpb24pID09PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TW9kdWxlSW5mb1dpdGhvdXRWZXJzaW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5jb25zdCBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gPSAobW9kdWxlSW5mbyk9PmdldFRhcmdldFNuYXBzaG90SW5mb0J5TW9kdWxlSW5mbyhtb2R1bGVJbmZvLCBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbyk7XG5jb25zdCBzZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gPSAocmVtb3RlSW5mbywgbW9kdWxlRGV0YWlsSW5mbyk9PntcbiAgICBjb25zdCBtb2R1bGVLZXkgPSBnZXRGTUlkKHJlbW90ZUluZm8pO1xuICAgIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvW21vZHVsZUtleV0gPSBtb2R1bGVEZXRhaWxJbmZvO1xuICAgIHJldHVybiBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbztcbn07XG5jb25zdCBhZGRHbG9iYWxTbmFwc2hvdCA9IChtb2R1bGVJbmZvcyk9PntcbiAgICBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX18ubW9kdWxlSW5mbyA9IF9leHRlbmRzJDEoe30sIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvLCBtb2R1bGVJbmZvcyk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb2R1bGVJbmZvcyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpe1xuICAgICAgICAgICAgZGVsZXRlIG5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5tb2R1bGVJbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmNvbnN0IGdldFJlbW90ZUVudHJ5RXhwb3J0cyA9IChuYW1lLCBnbG9iYWxOYW1lKT0+e1xuICAgIGNvbnN0IHJlbW90ZUVudHJ5S2V5ID0gZ2xvYmFsTmFtZSB8fCBgX19GRURFUkFUSU9OXyR7bmFtZX06Y3VzdG9tX19gO1xuICAgIGNvbnN0IGVudHJ5RXhwb3J0cyA9IGdsb2JhbFRoaXNbcmVtb3RlRW50cnlLZXldO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlbW90ZUVudHJ5S2V5LFxuICAgICAgICBlbnRyeUV4cG9ydHNcbiAgICB9O1xufTtcbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZWdpc3RlciBnbG9iYWwgcGx1Z2lucy5cbi8vIEl0IGl0ZXJhdGVzIG92ZXIgdGhlIHByb3ZpZGVkIHBsdWdpbnMgYW5kIGNoZWNrcyBpZiB0aGV5IGFyZSBhbHJlYWR5IHJlZ2lzdGVyZWQuXG4vLyBJZiBhIHBsdWdpbiBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaXMgYWRkZWQgdG8gdGhlIGdsb2JhbCBwbHVnaW5zLlxuLy8gSWYgYSBwbHVnaW4gaXMgYWxyZWFkeSByZWdpc3RlcmVkLCBhIHdhcm5pbmcgbWVzc2FnZSBpcyBsb2dnZWQuXG5jb25zdCByZWdpc3Rlckdsb2JhbFBsdWdpbnMgPSAocGx1Z2lucyk9PntcbiAgICBjb25zdCB7IF9fR0xPQkFMX1BMVUdJTl9fIH0gPSBuYXRpdmVHbG9iYWwuX19GRURFUkFUSU9OX187XG4gICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pPT57XG4gICAgICAgIGlmIChfX0dMT0JBTF9QTFVHSU5fXy5maW5kSW5kZXgoKHApPT5wLm5hbWUgPT09IHBsdWdpbi5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIF9fR0xPQkFMX1BMVUdJTl9fLnB1c2gocGx1Z2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYFRoZSBwbHVnaW4gJHtwbHVnaW4ubmFtZX0gaGFzIGJlZW4gcmVnaXN0ZXJlZC5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IGdldEdsb2JhbEhvc3RQbHVnaW5zID0gKCk9Pm5hdGl2ZUdsb2JhbC5fX0ZFREVSQVRJT05fXy5fX0dMT0JBTF9QTFVHSU5fXztcbmNvbnN0IGdldFByZWxvYWRlZCA9IChpZCk9Pmdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19QUkVMT0FERURfTUFQX18uZ2V0KGlkKTtcbmNvbnN0IHNldFByZWxvYWRlZCA9IChpZCk9Pmdsb2JhbFRoaXMuX19GRURFUkFUSU9OX18uX19QUkVMT0FERURfTUFQX18uc2V0KGlkLCB0cnVlKTtcblxuY29uc3QgREVGQVVMVF9TQ09QRSA9ICdkZWZhdWx0JztcbmNvbnN0IERFRkFVTFRfUkVNT1RFX1RZUEUgPSAnZ2xvYmFsJztcblxuLy8gZm9yayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmlnaW5qcy92aXRlLXBsdWdpbi1mZWRlcmF0aW9uL2Jsb2IvdjEuMS4xMi9wYWNrYWdlcy9saWIvc3JjL3V0aWxzL3NlbXZlci9pbmRleC50c1xuLy8gdGhvc2UgY29uc3RhbnRzIGFyZSBiYXNlZCBvbiBodHRwczovL3d3dy5ydWJ5ZG9jLmluZm8vZ2Vtcy9zZW1hbnRpY19yYW5nZS8zLjAuMC9TZW1hbnRpY1JhbmdlI0JVSUxESURFTlRJRklFUi1jb25zdGFudFxuLy8gQ29weXJpZ2h0IChjKVxuLy8gdml0ZS1wbHVnaW4tZmVkZXJhdGlvbiBpcyBsaWNlbnNlZCB1bmRlciBNdWxhbiBQU0wgdjIuXG4vLyBZb3UgY2FuIHVzZSB0aGlzIHNvZnR3YXJlIGFjY29yZGluZyB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhlIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiBNdWxhbiBQU0wgdjIgYXQ6XG4vLyAgICAgIGh0dHA6Ly9saWNlbnNlLmNvc2NsLm9yZy5jbi9NdWxhblBTTDJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgT04gQU4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT0YgQU5ZIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gTk9OLUlORlJJTkdFTUVOVCwgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVCBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuXG4vLyBTZWUgdGhlIE11bGFuIFBTTCB2MiBmb3IgbW9yZSBkZXRhaWxzLlxuY29uc3QgYnVpbGRJZGVudGlmaWVyID0gJ1swLTlBLVphLXotXSsnO1xuY29uc3QgYnVpbGQgPSBgKD86XFxcXCsoJHtidWlsZElkZW50aWZpZXJ9KD86XFxcXC4ke2J1aWxkSWRlbnRpZmllcn0pKikpYDtcbmNvbnN0IG51bWVyaWNJZGVudGlmaWVyID0gJzB8WzEtOV1cXFxcZConO1xuY29uc3QgbnVtZXJpY0lkZW50aWZpZXJMb29zZSA9ICdbMC05XSsnO1xuY29uc3Qgbm9uTnVtZXJpY0lkZW50aWZpZXIgPSAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKic7XG5jb25zdCBwcmVSZWxlYXNlSWRlbnRpZmllckxvb3NlID0gYCg/OiR7bnVtZXJpY0lkZW50aWZpZXJMb29zZX18JHtub25OdW1lcmljSWRlbnRpZmllcn0pYDtcbmNvbnN0IHByZVJlbGVhc2VMb29zZSA9IGAoPzotPygke3ByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2V9KD86XFxcXC4ke3ByZVJlbGVhc2VJZGVudGlmaWVyTG9vc2V9KSopKWA7XG5jb25zdCBwcmVSZWxlYXNlSWRlbnRpZmllciA9IGAoPzoke251bWVyaWNJZGVudGlmaWVyfXwke25vbk51bWVyaWNJZGVudGlmaWVyfSlgO1xuY29uc3QgcHJlUmVsZWFzZSA9IGAoPzotKCR7cHJlUmVsZWFzZUlkZW50aWZpZXJ9KD86XFxcXC4ke3ByZVJlbGVhc2VJZGVudGlmaWVyfSkqKSlgO1xuY29uc3QgeFJhbmdlSWRlbnRpZmllciA9IGAke251bWVyaWNJZGVudGlmaWVyfXx4fFh8XFxcXCpgO1xuY29uc3QgeFJhbmdlUGxhaW4gPSBgW3Y9XFxcXHNdKigke3hSYW5nZUlkZW50aWZpZXJ9KSg/OlxcXFwuKCR7eFJhbmdlSWRlbnRpZmllcn0pKD86XFxcXC4oJHt4UmFuZ2VJZGVudGlmaWVyfSkoPzoke3ByZVJlbGVhc2V9KT8ke2J1aWxkfT8pPyk/YDtcbmNvbnN0IGh5cGhlblJhbmdlID0gYF5cXFxccyooJHt4UmFuZ2VQbGFpbn0pXFxcXHMrLVxcXFxzKygke3hSYW5nZVBsYWlufSlcXFxccyokYDtcbmNvbnN0IG1haW5WZXJzaW9uTG9vc2UgPSBgKCR7bnVtZXJpY0lkZW50aWZpZXJMb29zZX0pXFxcXC4oJHtudW1lcmljSWRlbnRpZmllckxvb3NlfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyTG9vc2V9KWA7XG5jb25zdCBsb29zZVBsYWluID0gYFt2PVxcXFxzXSoke21haW5WZXJzaW9uTG9vc2V9JHtwcmVSZWxlYXNlTG9vc2V9PyR7YnVpbGR9P2A7XG5jb25zdCBndGx0ID0gJygoPzo8fD4pPz0/KSc7XG5jb25zdCBjb21wYXJhdG9yVHJpbSA9IGAoXFxcXHMqKSR7Z3RsdH1cXFxccyooJHtsb29zZVBsYWlufXwke3hSYW5nZVBsYWlufSlgO1xuY29uc3QgbG9uZVRpbGRlID0gJyg/On4+PyknO1xuY29uc3QgdGlsZGVUcmltID0gYChcXFxccyopJHtsb25lVGlsZGV9XFxcXHMrYDtcbmNvbnN0IGxvbmVDYXJldCA9ICcoPzpcXFxcXiknO1xuY29uc3QgY2FyZXRUcmltID0gYChcXFxccyopJHtsb25lQ2FyZXR9XFxcXHMrYDtcbmNvbnN0IHN0YXIgPSAnKDx8Pik/PT9cXFxccypcXFxcKic7XG5jb25zdCBjYXJldCA9IGBeJHtsb25lQ2FyZXR9JHt4UmFuZ2VQbGFpbn0kYDtcbmNvbnN0IG1haW5WZXJzaW9uID0gYCgke251bWVyaWNJZGVudGlmaWVyfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyfSlcXFxcLigke251bWVyaWNJZGVudGlmaWVyfSlgO1xuY29uc3QgZnVsbFBsYWluID0gYHY/JHttYWluVmVyc2lvbn0ke3ByZVJlbGVhc2V9PyR7YnVpbGR9P2A7XG5jb25zdCB0aWxkZSA9IGBeJHtsb25lVGlsZGV9JHt4UmFuZ2VQbGFpbn0kYDtcbmNvbnN0IHhSYW5nZSA9IGBeJHtndGx0fVxcXFxzKiR7eFJhbmdlUGxhaW59JGA7XG5jb25zdCBjb21wYXJhdG9yID0gYF4ke2d0bHR9XFxcXHMqKCR7ZnVsbFBsYWlufSkkfF4kYDtcbi8vIGNvcHkgZnJvbSBzZW12ZXIgcGFja2FnZVxuY29uc3QgZ3RlMCA9ICdeXFxcXHMqPj1cXFxccyowLjAuMFxcXFxzKiQnO1xuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSk7XG59XG5mdW5jdGlvbiBpc1hWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gIXZlcnNpb24gfHwgdmVyc2lvbi50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgdmVyc2lvbiA9PT0gJyonO1xufVxuZnVuY3Rpb24gcGlwZSguLi5mbnMpIHtcbiAgICByZXR1cm4gKHgpPT5mbnMucmVkdWNlKCh2LCBmKT0+Zih2KSwgeCk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q29tcGFyYXRvcihjb21wYXJhdG9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvbXBhcmF0b3JTdHJpbmcubWF0Y2gocGFyc2VSZWdleChjb21wYXJhdG9yKSk7XG59XG5mdW5jdGlvbiBjb21iaW5lVmVyc2lvbihtYWpvciwgbWlub3IsIHBhdGNoLCBwcmVSZWxlYXNlKSB7XG4gICAgY29uc3QgbWFpblZlcnNpb24gPSBgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH1gO1xuICAgIGlmIChwcmVSZWxlYXNlKSB7XG4gICAgICAgIHJldHVybiBgJHttYWluVmVyc2lvbn0tJHtwcmVSZWxlYXNlfWA7XG4gICAgfVxuICAgIHJldHVybiBtYWluVmVyc2lvbjtcbn1cblxuLy8gZm9yayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmlnaW5qcy92aXRlLXBsdWdpbi1mZWRlcmF0aW9uL2Jsb2IvdjEuMS4xMi9wYWNrYWdlcy9saWIvc3JjL3V0aWxzL3NlbXZlci9pbmRleC50c1xuZnVuY3Rpb24gcGFyc2VIeXBoZW4ocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UucmVwbGFjZShwYXJzZVJlZ2V4KGh5cGhlblJhbmdlKSwgKF9yYW5nZSwgZnJvbSwgZnJvbU1ham9yLCBmcm9tTWlub3IsIGZyb21QYXRjaCwgX2Zyb21QcmVSZWxlYXNlLCBfZnJvbUJ1aWxkLCB0bywgdG9NYWpvciwgdG9NaW5vciwgdG9QYXRjaCwgdG9QcmVSZWxlYXNlKT0+e1xuICAgICAgICBpZiAoaXNYVmVyc2lvbihmcm9tTWFqb3IpKSB7XG4gICAgICAgICAgICBmcm9tID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihmcm9tTWlub3IpKSB7XG4gICAgICAgICAgICBmcm9tID0gYD49JHtmcm9tTWFqb3J9LjAuMGA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbihmcm9tUGF0Y2gpKSB7XG4gICAgICAgICAgICBmcm9tID0gYD49JHtmcm9tTWFqb3J9LiR7ZnJvbU1pbm9yfS4wYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBgPj0ke2Zyb219YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNYVmVyc2lvbih0b01ham9yKSkge1xuICAgICAgICAgICAgdG8gPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHRvTWlub3IpKSB7XG4gICAgICAgICAgICB0byA9IGA8JHtOdW1iZXIodG9NYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNYVmVyc2lvbih0b1BhdGNoKSkge1xuICAgICAgICAgICAgdG8gPSBgPCR7dG9NYWpvcn0uJHtOdW1iZXIodG9NaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICB9IGVsc2UgaWYgKHRvUHJlUmVsZWFzZSkge1xuICAgICAgICAgICAgdG8gPSBgPD0ke3RvTWFqb3J9LiR7dG9NaW5vcn0uJHt0b1BhdGNofS0ke3RvUHJlUmVsZWFzZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG8gPSBgPD0ke3RvfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Zyb219ICR7dG99YC50cmltKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3JUcmltKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnJlcGxhY2UocGFyc2VSZWdleChjb21wYXJhdG9yVHJpbSksICckMSQyJDMnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGlsZGVUcmltKHJhbmdlKSB7XG4gICAgcmV0dXJuIHJhbmdlLnJlcGxhY2UocGFyc2VSZWdleCh0aWxkZVRyaW0pLCAnJDF+Jyk7XG59XG5mdW5jdGlvbiBwYXJzZUNhcmV0VHJpbShyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS5yZXBsYWNlKHBhcnNlUmVnZXgoY2FyZXRUcmltKSwgJyQxXicpO1xufVxuZnVuY3Rpb24gcGFyc2VDYXJldHMocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChyYW5nZVZlcnNpb24pPT5yYW5nZVZlcnNpb24ucmVwbGFjZShwYXJzZVJlZ2V4KGNhcmV0KSwgKF8sIG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpPT57XG4gICAgICAgICAgICBpZiAoaXNYVmVyc2lvbihtYWpvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24obWlub3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LjAuMCA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHBhdGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChtYWpvciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4wIDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4wIDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVSZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ham9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbm9yID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofS0ke3ByZVJlbGVhc2V9IDwke21ham9yfS4ke21pbm9yfS4ke051bWJlcihwYXRjaCkgKyAxfS0wYDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofS0ke3ByZVJlbGVhc2V9IDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7TnVtYmVyKG1ham9yKSArIDF9LjAuMC0wYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtYWpvciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5vciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0gPCR7bWFqb3J9LiR7bWlub3J9LiR7TnVtYmVyKHBhdGNoKSArIDF9LTBgO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9IDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4ke3BhdGNofSA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSkuam9pbignICcpO1xufVxuZnVuY3Rpb24gcGFyc2VUaWxkZXMocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChyYW5nZVZlcnNpb24pPT5yYW5nZVZlcnNpb24ucmVwbGFjZShwYXJzZVJlZ2V4KHRpbGRlKSwgKF8sIG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpPT57XG4gICAgICAgICAgICBpZiAoaXNYVmVyc2lvbihtYWpvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFZlcnNpb24obWlub3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LjAuMCA8JHtOdW1iZXIobWFqb3IpICsgMX0uMC4wLTBgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1hWZXJzaW9uKHBhdGNoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4ke21pbm9yfS4wIDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmVSZWxlYXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LiR7cGF0Y2h9LSR7cHJlUmVsZWFzZX0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYD49JHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH0gPCR7bWFqb3J9LiR7TnVtYmVyKG1pbm9yKSArIDF9LjAtMGA7XG4gICAgICAgIH0pKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBwYXJzZVhSYW5nZXMocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2Uuc3BsaXQoL1xccysvKS5tYXAoKHJhbmdlVmVyc2lvbik9PnJhbmdlVmVyc2lvbi50cmltKCkucmVwbGFjZShwYXJzZVJlZ2V4KHhSYW5nZSksIChyZXQsIGd0bHQsIG1ham9yLCBtaW5vciwgcGF0Y2gsIHByZVJlbGVhc2UpPT57XG4gICAgICAgICAgICBjb25zdCBpc1hNYWpvciA9IGlzWFZlcnNpb24obWFqb3IpO1xuICAgICAgICAgICAgY29uc3QgaXNYTWlub3IgPSBpc1hNYWpvciB8fCBpc1hWZXJzaW9uKG1pbm9yKTtcbiAgICAgICAgICAgIGNvbnN0IGlzWFBhdGNoID0gaXNYTWlub3IgfHwgaXNYVmVyc2lvbihwYXRjaCk7XG4gICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGlzWFBhdGNoKSB7XG4gICAgICAgICAgICAgICAgZ3RsdCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlUmVsZWFzZSA9ICcnO1xuICAgICAgICAgICAgaWYgKGlzWE1ham9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPDAuMC4wLTAnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChndGx0ICYmIGlzWFBhdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBYIHdpdGggMFxuICAgICAgICAgICAgICAgIGlmIChpc1hNaW5vcikge1xuICAgICAgICAgICAgICAgICAgICBtaW5vciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGNoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgICAgICAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgICAgICAgICAgICAgIGd0bHQgPSAnPj0nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNYTWlub3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ham9yID0gTnVtYmVyKG1ham9yKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5vciA9IE51bWJlcihtaW5vcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkIHBhc3NcbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgZ3RsdCA9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWE1pbm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWpvciA9IE51bWJlcihtYWpvcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlub3IgPSBOdW1iZXIobWlub3IpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZ3RsdCA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVJlbGVhc2UgPSAnLTAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7Z3RsdCArIG1ham9yfS4ke21pbm9yfS4ke3BhdGNofSR7cHJlUmVsZWFzZX1gO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1hNaW5vcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgPj0ke21ham9yfS4wLjAke3ByZVJlbGVhc2V9IDwke051bWJlcihtYWpvcikgKyAxfS4wLjAtMGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzWFBhdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA+PSR7bWFqb3J9LiR7bWlub3J9LjAke3ByZVJlbGVhc2V9IDwke21ham9yfS4ke051bWJlcihtaW5vcikgKyAxfS4wLTBgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSkpLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RhcihyYW5nZSkge1xuICAgIHJldHVybiByYW5nZS50cmltKCkucmVwbGFjZShwYXJzZVJlZ2V4KHN0YXIpLCAnJyk7XG59XG5mdW5jdGlvbiBwYXJzZUdURTAoY29tcGFyYXRvclN0cmluZykge1xuICAgIHJldHVybiBjb21wYXJhdG9yU3RyaW5nLnRyaW0oKS5yZXBsYWNlKHBhcnNlUmVnZXgoZ3RlMCksICcnKTtcbn1cblxuLy8gZm9yayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vcmlnaW5qcy92aXRlLXBsdWdpbi1mZWRlcmF0aW9uL2Jsb2IvdjEuMS4xMi9wYWNrYWdlcy9saWIvc3JjL3V0aWxzL3NlbXZlci9pbmRleC50c1xuLy8gQ29weXJpZ2h0IChjKVxuLy8gdml0ZS1wbHVnaW4tZmVkZXJhdGlvbiBpcyBsaWNlbnNlZCB1bmRlciBNdWxhbiBQU0wgdjIuXG4vLyBZb3UgY2FuIHVzZSB0aGlzIHNvZnR3YXJlIGFjY29yZGluZyB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhlIE11bGFuIFBTTCB2Mi5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiBNdWxhbiBQU0wgdjIgYXQ6XG4vLyAgICAgIGh0dHA6Ly9saWNlbnNlLmNvc2NsLm9yZy5jbi9NdWxhblBTTDJcbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgT04gQU4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT0YgQU5ZIEtJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gTk9OLUlORlJJTkdFTUVOVCwgTUVSQ0hBTlRBQklMSVRZIE9SIEZJVCBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuXG4vLyBTZWUgdGhlIE11bGFuIFBTTCB2MiBmb3IgbW9yZSBkZXRhaWxzLlxuZnVuY3Rpb24gY29tcGFyZUF0b20ocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkge1xuICAgIHJhbmdlQXRvbSA9IE51bWJlcihyYW5nZUF0b20pIHx8IHJhbmdlQXRvbTtcbiAgICB2ZXJzaW9uQXRvbSA9IE51bWJlcih2ZXJzaW9uQXRvbSkgfHwgdmVyc2lvbkF0b207XG4gICAgaWYgKHJhbmdlQXRvbSA+IHZlcnNpb25BdG9tKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAocmFuZ2VBdG9tID09PSB2ZXJzaW9uQXRvbSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gY29tcGFyZVByZVJlbGVhc2UocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkge1xuICAgIGNvbnN0IHsgcHJlUmVsZWFzZTogcmFuZ2VQcmVSZWxlYXNlIH0gPSByYW5nZUF0b207XG4gICAgY29uc3QgeyBwcmVSZWxlYXNlOiB2ZXJzaW9uUHJlUmVsZWFzZSB9ID0gdmVyc2lvbkF0b207XG4gICAgaWYgKHJhbmdlUHJlUmVsZWFzZSA9PT0gdW5kZWZpbmVkICYmIEJvb2xlYW4odmVyc2lvblByZVJlbGVhc2UpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoQm9vbGVhbihyYW5nZVByZVJlbGVhc2UpICYmIHZlcnNpb25QcmVSZWxlYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAocmFuZ2VQcmVSZWxlYXNlID09PSB1bmRlZmluZWQgJiYgdmVyc2lvblByZVJlbGVhc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMCwgbiA9IHJhbmdlUHJlUmVsZWFzZS5sZW5ndGg7IGkgPD0gbjsgaSsrKXtcbiAgICAgICAgY29uc3QgcmFuZ2VFbGVtZW50ID0gcmFuZ2VQcmVSZWxlYXNlW2ldO1xuICAgICAgICBjb25zdCB2ZXJzaW9uRWxlbWVudCA9IHZlcnNpb25QcmVSZWxlYXNlW2ldO1xuICAgICAgICBpZiAocmFuZ2VFbGVtZW50ID09PSB2ZXJzaW9uRWxlbWVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIHZlcnNpb25FbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2VFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZlcnNpb25FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBdG9tKHJhbmdlRWxlbWVudCwgdmVyc2lvbkVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHtcbiAgICByZXR1cm4gY29tcGFyZUF0b20ocmFuZ2VBdG9tLm1ham9yLCB2ZXJzaW9uQXRvbS5tYWpvcikgfHwgY29tcGFyZUF0b20ocmFuZ2VBdG9tLm1pbm9yLCB2ZXJzaW9uQXRvbS5taW5vcikgfHwgY29tcGFyZUF0b20ocmFuZ2VBdG9tLnBhdGNoLCB2ZXJzaW9uQXRvbS5wYXRjaCkgfHwgY29tcGFyZVByZVJlbGVhc2UocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSk7XG59XG5mdW5jdGlvbiBlcShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgcmV0dXJuIHJhbmdlQXRvbS52ZXJzaW9uID09PSB2ZXJzaW9uQXRvbS52ZXJzaW9uO1xufVxuZnVuY3Rpb24gY29tcGFyZShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB7XG4gICAgc3dpdGNoKHJhbmdlQXRvbS5vcGVyYXRvcil7XG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgcmV0dXJuIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pO1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlVmVyc2lvbihyYW5nZUF0b20sIHZlcnNpb25BdG9tKSA8IDA7XG4gICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIHJldHVybiBlcShyYW5nZUF0b20sIHZlcnNpb25BdG9tKSB8fCBjb21wYXJlVmVyc2lvbihyYW5nZUF0b20sIHZlcnNpb25BdG9tKSA8IDA7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pID4gMDtcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgcmV0dXJuIGVxKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pIHx8IGNvbXBhcmVWZXJzaW9uKHJhbmdlQXRvbSwgdmVyc2lvbkF0b20pID4gMDtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gbWVhbiAqIG9yIHggLT4gYWxsIHZlcnNpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBmb3JrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29yaWdpbmpzL3ZpdGUtcGx1Z2luLWZlZGVyYXRpb24vYmxvYi92MS4xLjEyL3BhY2thZ2VzL2xpYi9zcmMvdXRpbHMvc2VtdmVyL2luZGV4LnRzXG5mdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3JTdHJpbmcocmFuZ2UpIHtcbiAgICByZXR1cm4gcGlwZSgvLyBoYW5kbGUgY2FyZXRcbiAgICAvLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuICAgIC8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbiAgICAvLyBeMi4wLCBeMi4wLnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbiAgICAvLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbiAgICAvLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbiAgICAvLyBeMS4yLjAgLS0+ID49MS4yLjAgPDIuMC4wLTBcbiAgICBwYXJzZUNhcmV0cywgLy8gaGFuZGxlIHRpbGRlXG4gICAgLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4gICAgLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4gICAgLy8gfjIuMCwgfjIuMC54LCB+PjIuMCwgfj4yLjAueCAtLT4gPj0yLjAuMCA8Mi4xLjAtMFxuICAgIC8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbiAgICAvLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbiAgICAvLyB+MS4yLjAsIH4+MS4yLjAgLS0+ID49MS4yLjAgPDEuMy4wLTBcbiAgICBwYXJzZVRpbGRlcywgcGFyc2VYUmFuZ2VzLCBwYXJzZVN0YXIpKHJhbmdlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmFuZ2UocmFuZ2UpIHtcbiAgICByZXR1cm4gcGlwZSgvLyBoYW5kbGUgaHlwaGVuUmFuZ2VcbiAgICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgICBwYXJzZUh5cGhlbiwgLy8gaGFuZGxlIHRyaW0gY29tcGFyYXRvclxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHBhcnNlQ29tcGFyYXRvclRyaW0sIC8vIGhhbmRsZSB0cmltIHRpbGRlXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcGFyc2VUaWxkZVRyaW0sIC8vIGhhbmRsZSB0cmltIGNhcmV0XG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcGFyc2VDYXJldFRyaW0pKHJhbmdlLnRyaW0oKSkuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBzYXRpc2Z5KHZlcnNpb24sIHJhbmdlKSB7XG4gICAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkUmFuZ2UgPSBwYXJzZVJhbmdlKHJhbmdlKTtcbiAgICBjb25zdCBwYXJzZWRDb21wYXJhdG9yID0gcGFyc2VkUmFuZ2Uuc3BsaXQoJyAnKS5tYXAoKHJhbmdlVmVyc2lvbik9PnBhcnNlQ29tcGFyYXRvclN0cmluZyhyYW5nZVZlcnNpb24pKS5qb2luKCcgJyk7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSBwYXJzZWRDb21wYXJhdG9yLnNwbGl0KC9cXHMrLykubWFwKChjb21wYXJhdG9yKT0+cGFyc2VHVEUwKGNvbXBhcmF0b3IpKTtcbiAgICBjb25zdCBleHRyYWN0ZWRWZXJzaW9uID0gZXh0cmFjdENvbXBhcmF0b3IodmVyc2lvbik7XG4gICAgaWYgKCFleHRyYWN0ZWRWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgWywgdmVyc2lvbk9wZXJhdG9yLCAsIHZlcnNpb25NYWpvciwgdmVyc2lvbk1pbm9yLCB2ZXJzaW9uUGF0Y2gsIHZlcnNpb25QcmVSZWxlYXNlXSA9IGV4dHJhY3RlZFZlcnNpb247XG4gICAgY29uc3QgdmVyc2lvbkF0b20gPSB7XG4gICAgICAgIG9wZXJhdG9yOiB2ZXJzaW9uT3BlcmF0b3IsXG4gICAgICAgIHZlcnNpb246IGNvbWJpbmVWZXJzaW9uKHZlcnNpb25NYWpvciwgdmVyc2lvbk1pbm9yLCB2ZXJzaW9uUGF0Y2gsIHZlcnNpb25QcmVSZWxlYXNlKSxcbiAgICAgICAgbWFqb3I6IHZlcnNpb25NYWpvcixcbiAgICAgICAgbWlub3I6IHZlcnNpb25NaW5vcixcbiAgICAgICAgcGF0Y2g6IHZlcnNpb25QYXRjaCxcbiAgICAgICAgcHJlUmVsZWFzZTogdmVyc2lvblByZVJlbGVhc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHZlcnNpb25QcmVSZWxlYXNlLnNwbGl0KCcuJylcbiAgICB9O1xuICAgIGZvciAoY29uc3QgY29tcGFyYXRvciBvZiBjb21wYXJhdG9ycyl7XG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZENvbXBhcmF0b3IgPSBleHRyYWN0Q29tcGFyYXRvcihjb21wYXJhdG9yKTtcbiAgICAgICAgaWYgKCFleHRyYWN0ZWRDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgcmFuZ2VPcGVyYXRvciwgLCByYW5nZU1ham9yLCByYW5nZU1pbm9yLCByYW5nZVBhdGNoLCByYW5nZVByZVJlbGVhc2VdID0gZXh0cmFjdGVkQ29tcGFyYXRvcjtcbiAgICAgICAgY29uc3QgcmFuZ2VBdG9tID0ge1xuICAgICAgICAgICAgb3BlcmF0b3I6IHJhbmdlT3BlcmF0b3IsXG4gICAgICAgICAgICB2ZXJzaW9uOiBjb21iaW5lVmVyc2lvbihyYW5nZU1ham9yLCByYW5nZU1pbm9yLCByYW5nZVBhdGNoLCByYW5nZVByZVJlbGVhc2UpLFxuICAgICAgICAgICAgbWFqb3I6IHJhbmdlTWFqb3IsXG4gICAgICAgICAgICBtaW5vcjogcmFuZ2VNaW5vcixcbiAgICAgICAgICAgIHBhdGNoOiByYW5nZVBhdGNoLFxuICAgICAgICAgICAgcHJlUmVsZWFzZTogcmFuZ2VQcmVSZWxlYXNlID09IG51bGwgPyB2b2lkIDAgOiByYW5nZVByZVJlbGVhc2Uuc3BsaXQoJy4nKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWNvbXBhcmUocmFuZ2VBdG9tLCB2ZXJzaW9uQXRvbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZWFybHkgcmV0dXJuXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBmb3JtYXRTaGFyZShzaGFyZUFyZ3MsIGZyb20sIG5hbWUsIHNoYXJlU3RyYXRlZ3kpIHtcbiAgICBsZXQgZ2V0O1xuICAgIGlmICgnZ2V0JyBpbiBzaGFyZUFyZ3MpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIGdldCA9IHNoYXJlQXJncy5nZXQ7XG4gICAgfSBlbHNlIGlmICgnbGliJyBpbiBzaGFyZUFyZ3MpIHtcbiAgICAgICAgZ2V0ID0gKCk9PlByb21pc2UucmVzb2x2ZShzaGFyZUFyZ3MubGliKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXQgPSAoKT0+UHJvbWlzZS5yZXNvbHZlKCgpPT57XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGdldCBzaGFyZWQgJyR7bmFtZX0nIWApO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzaGFyZUFyZ3Muc3RyYXRlZ3kpIHtcbiAgICAgICAgd2FybihgXCJzaGFyZWQuc3RyYXRlZ3kgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHNldCBpbiBpbml0T3B0aW9ucy5zaGFyZVN0cmF0ZWd5IGluc3RlYWQhXCJgKTtcbiAgICB9XG4gICAgdmFyIF9zaGFyZUFyZ3NfdmVyc2lvbiwgX3NoYXJlQXJnc19zY29wZSwgX3NoYXJlQXJnc19zdHJhdGVneTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBkZXBzOiBbXSxcbiAgICAgICAgdXNlSW46IFtdLFxuICAgICAgICBmcm9tLFxuICAgICAgICBsb2FkaW5nOiBudWxsXG4gICAgfSwgc2hhcmVBcmdzLCB7XG4gICAgICAgIHNoYXJlQ29uZmlnOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICByZXF1aXJlZFZlcnNpb246IGBeJHtzaGFyZUFyZ3MudmVyc2lvbn1gLFxuICAgICAgICAgICAgc2luZ2xldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIGVhZ2VyOiBmYWxzZSxcbiAgICAgICAgICAgIHN0cmljdFZlcnNpb246IGZhbHNlXG4gICAgICAgIH0sIHNoYXJlQXJncy5zaGFyZUNvbmZpZyksXG4gICAgICAgIGdldCxcbiAgICAgICAgbG9hZGVkOiAoc2hhcmVBcmdzID09IG51bGwgPyB2b2lkIDAgOiBzaGFyZUFyZ3MubG9hZGVkKSB8fCAnbGliJyBpbiBzaGFyZUFyZ3MgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgICAgICB2ZXJzaW9uOiAoX3NoYXJlQXJnc192ZXJzaW9uID0gc2hhcmVBcmdzLnZlcnNpb24pICE9IG51bGwgPyBfc2hhcmVBcmdzX3ZlcnNpb24gOiAnMCcsXG4gICAgICAgIHNjb3BlOiBBcnJheS5pc0FycmF5KHNoYXJlQXJncy5zY29wZSkgPyBzaGFyZUFyZ3Muc2NvcGUgOiBbXG4gICAgICAgICAgICAoX3NoYXJlQXJnc19zY29wZSA9IHNoYXJlQXJncy5zY29wZSkgIT0gbnVsbCA/IF9zaGFyZUFyZ3Nfc2NvcGUgOiAnZGVmYXVsdCdcbiAgICAgICAgXSxcbiAgICAgICAgc3RyYXRlZ3k6ICgoX3NoYXJlQXJnc19zdHJhdGVneSA9IHNoYXJlQXJncy5zdHJhdGVneSkgIT0gbnVsbCA/IF9zaGFyZUFyZ3Nfc3RyYXRlZ3kgOiBzaGFyZVN0cmF0ZWd5KSB8fCAndmVyc2lvbi1maXJzdCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFNoYXJlQ29uZmlncyhnbG9iYWxPcHRpb25zLCB1c2VyT3B0aW9ucykge1xuICAgIGNvbnN0IHNoYXJlQXJncyA9IHVzZXJPcHRpb25zLnNoYXJlZCB8fCB7fTtcbiAgICBjb25zdCBmcm9tID0gdXNlck9wdGlvbnMubmFtZTtcbiAgICBjb25zdCBzaGFyZUluZm9zID0gT2JqZWN0LmtleXMoc2hhcmVBcmdzKS5yZWR1Y2UoKHJlcywgcGtnTmFtZSk9PntcbiAgICAgICAgY29uc3QgYXJyYXlTaGFyZUFyZ3MgPSBhcnJheU9wdGlvbnMoc2hhcmVBcmdzW3BrZ05hbWVdKTtcbiAgICAgICAgcmVzW3BrZ05hbWVdID0gcmVzW3BrZ05hbWVdIHx8IFtdO1xuICAgICAgICBhcnJheVNoYXJlQXJncy5mb3JFYWNoKChzaGFyZUNvbmZpZyk9PntcbiAgICAgICAgICAgIHJlc1twa2dOYW1lXS5wdXNoKGZvcm1hdFNoYXJlKHNoYXJlQ29uZmlnLCBmcm9tLCBwa2dOYW1lLCB1c2VyT3B0aW9ucy5zaGFyZVN0cmF0ZWd5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBzaGFyZWQgPSBfZXh0ZW5kcyh7fSwgZ2xvYmFsT3B0aW9ucy5zaGFyZWQpO1xuICAgIE9iamVjdC5rZXlzKHNoYXJlSW5mb3MpLmZvckVhY2goKHNoYXJlS2V5KT0+e1xuICAgICAgICBpZiAoIXNoYXJlZFtzaGFyZUtleV0pIHtcbiAgICAgICAgICAgIHNoYXJlZFtzaGFyZUtleV0gPSBzaGFyZUluZm9zW3NoYXJlS2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNoYXJlSW5mb3Nbc2hhcmVLZXldLmZvckVhY2goKG5ld1VzZXJTaGFyZWRPcHRpb25zKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2FtZVZlcnNpb24gPSBzaGFyZWRbc2hhcmVLZXldLmZpbmQoKHNoYXJlZFZhbCk9PnNoYXJlZFZhbC52ZXJzaW9uID09PSBuZXdVc2VyU2hhcmVkT3B0aW9ucy52ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU2FtZVZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkW3NoYXJlS2V5XS5wdXNoKG5ld1VzZXJTaGFyZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNoYXJlZCxcbiAgICAgICAgc2hhcmVJbmZvc1xuICAgIH07XG59XG5mdW5jdGlvbiB2ZXJzaW9uTHQoYSwgYikge1xuICAgIGNvbnN0IHRyYW5zZm9ybUludmFsaWRWZXJzaW9uID0gKHZlcnNpb24pPT57XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyVmVyc2lvbiA9ICFOdW1iZXIuaXNOYU4oTnVtYmVyKHZlcnNpb24pKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyVmVyc2lvbikge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRBcnIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBsZXQgdmFsaWRWZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAzIC0gc3BsaXRBcnIubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhbGlkVmVyc2lvbiArPSAnLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICB9O1xuICAgIGlmIChzYXRpc2Z5KHRyYW5zZm9ybUludmFsaWRWZXJzaW9uKGEpLCBgPD0ke3RyYW5zZm9ybUludmFsaWRWZXJzaW9uKGIpfWApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBmaW5kVmVyc2lvbiA9IChzaGFyZVZlcnNpb25NYXAsIGNiKT0+e1xuICAgIGNvbnN0IGNhbGxiYWNrID0gY2IgfHwgZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uTHQocHJldiwgY3VyKTtcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzaGFyZVZlcnNpb25NYXApLnJlZHVjZSgocHJldiwgY3VyKT0+e1xuICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKHByZXYsIGN1cikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVmYXVsdCB2ZXJzaW9uIGlzICcwJyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2IvbWFpbi9saWIvc2hhcmluZy9Qcm92aWRlU2hhcmVkTW9kdWxlLmpzI0wxMzZcbiAgICAgICAgaWYgKHByZXYgPT09ICcwJykge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCAwKTtcbn07XG5jb25zdCBpc0xvYWRlZCA9IChzaGFyZWQpPT57XG4gICAgcmV0dXJuIEJvb2xlYW4oc2hhcmVkLmxvYWRlZCkgfHwgdHlwZW9mIHNoYXJlZC5saWIgPT09ICdmdW5jdGlvbic7XG59O1xuZnVuY3Rpb24gZmluZFNpbmdsZXRvblZlcnNpb25PcmRlckJ5VmVyc2lvbihzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSkge1xuICAgIGNvbnN0IHZlcnNpb25zID0gc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0xvYWRlZCh2ZXJzaW9uc1twcmV2XSkgJiYgdmVyc2lvbkx0KHByZXYsIGN1cik7XG4gICAgfTtcbiAgICByZXR1cm4gZmluZFZlcnNpb24oc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV0sIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeUxvYWRlZChzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSkge1xuICAgIGNvbnN0IHZlcnNpb25zID0gc2hhcmVTY29wZU1hcFtzY29wZV1bcGtnTmFtZV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICAgICAgaWYgKGlzTG9hZGVkKHZlcnNpb25zW2N1cl0pKSB7XG4gICAgICAgICAgICBpZiAoaXNMb2FkZWQodmVyc2lvbnNbcHJldl0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odmVyc2lvbkx0KHByZXYsIGN1cikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2FkZWQodmVyc2lvbnNbcHJldl0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcnNpb25MdChwcmV2LCBjdXIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbmRWZXJzaW9uKHNoYXJlU2NvcGVNYXBbc2NvcGVdW3BrZ05hbWVdLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiBnZXRGaW5kU2hhcmVGdW5jdGlvbihzdHJhdGVneSkge1xuICAgIGlmIChzdHJhdGVneSA9PT0gJ2xvYWRlZC1maXJzdCcpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeUxvYWRlZDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmRTaW5nbGV0b25WZXJzaW9uT3JkZXJCeVZlcnNpb247XG59XG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkU2hhcmUobG9jYWxTaGFyZVNjb3BlTWFwLCBwa2dOYW1lLCBzaGFyZUluZm8sIHJlc29sdmVTaGFyZSkge1xuICAgIGlmICghbG9jYWxTaGFyZVNjb3BlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzaGFyZUNvbmZpZywgc2NvcGUgPSBERUZBVUxUX1NDT1BFLCBzdHJhdGVneSB9ID0gc2hhcmVJbmZvO1xuICAgIGNvbnN0IHNjb3BlcyA9IEFycmF5LmlzQXJyYXkoc2NvcGUpID8gc2NvcGUgOiBbXG4gICAgICAgIHNjb3BlXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IHNjIG9mIHNjb3Blcyl7XG4gICAgICAgIGlmIChzaGFyZUNvbmZpZyAmJiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdICYmIGxvY2FsU2hhcmVTY29wZU1hcFtzY11bcGtnTmFtZV0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWlyZWRWZXJzaW9uIH0gPSBzaGFyZUNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IGZpbmRTaGFyZUZ1bmN0aW9uID0gZ2V0RmluZFNoYXJlRnVuY3Rpb24oc3RyYXRlZ3kpO1xuICAgICAgICAgICAgY29uc3QgbWF4T3JTaW5nbGV0b25WZXJzaW9uID0gZmluZFNoYXJlRnVuY3Rpb24obG9jYWxTaGFyZVNjb3BlTWFwLCBzYywgcGtnTmFtZSk7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRSZXNvbHZlciA9ICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNoYXJlQ29uZmlnLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVpcmVkVmVyc2lvbiA9PT0gJ3N0cmluZycgJiYgIXNhdGlzZnkobWF4T3JTaW5nbGV0b25WZXJzaW9uLCByZXF1aXJlZFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVmVyc2lvbiAke21heE9yU2luZ2xldG9uVmVyc2lvbn0gZnJvbSAke21heE9yU2luZ2xldG9uVmVyc2lvbiAmJiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW21heE9yU2luZ2xldG9uVmVyc2lvbl0uZnJvbX0gb2Ygc2hhcmVkIHNpbmdsZXRvbiBtb2R1bGUgJHtwa2dOYW1lfSBkb2VzIG5vdCBzYXRpc2Z5IHRoZSByZXF1aXJlbWVudCBvZiAke3NoYXJlSW5mby5mcm9tfSB3aGljaCBuZWVkcyAke3JlcXVpcmVkVmVyc2lvbn0pYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFyZUNvbmZpZy5zdHJpY3RWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW21heE9yU2luZ2xldG9uVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkVmVyc2lvbiA9PT0gZmFsc2UgfHwgcmVxdWlyZWRWZXJzaW9uID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbFNoYXJlU2NvcGVNYXBbc2NdW3BrZ05hbWVdW21heE9yU2luZ2xldG9uVmVyc2lvbl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhdGlzZnkobWF4T3JTaW5nbGV0b25WZXJzaW9uLCByZXF1aXJlZFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXVttYXhPclNpbmdsZXRvblZlcnNpb25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3ZlcnNpb25LZXksIHZlcnNpb25WYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobG9jYWxTaGFyZVNjb3BlTWFwW3NjXVtwa2dOYW1lXSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhdGlzZnkodmVyc2lvbktleSwgcmVxdWlyZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHNoYXJlU2NvcGVNYXA6IGxvY2FsU2hhcmVTY29wZU1hcCxcbiAgICAgICAgICAgICAgICBzY29wZTogc2MsXG4gICAgICAgICAgICAgICAgcGtnTmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBtYXhPclNpbmdsZXRvblZlcnNpb24sXG4gICAgICAgICAgICAgICAgR2xvYmFsRmVkZXJhdGlvbjogR2xvYmFsLl9fRkVERVJBVElPTl9fLFxuICAgICAgICAgICAgICAgIHJlc29sdmVyOiBkZWZhdWx0UmVzb2x2ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlU2hhcmVkID0gcmVzb2x2ZVNoYXJlLmVtaXQocGFyYW1zKSB8fCBwYXJhbXM7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVNoYXJlZC5yZXNvbHZlcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0R2xvYmFsU2hhcmVTY29wZSgpIHtcbiAgICByZXR1cm4gR2xvYmFsLl9fRkVERVJBVElPTl9fLl9fU0hBUkVfXztcbn1cbmZ1bmN0aW9uIGdldFRhcmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcGtnTmFtZSwgZXh0cmFPcHRpb25zLCBzaGFyZUluZm9zIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRlZmF1bHRSZXNvbHZlciA9IChzaGFyZWRPcHRpb25zKT0+e1xuICAgICAgICBpZiAoIXNoYXJlZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhcmVWZXJzaW9uTWFwID0ge307XG4gICAgICAgIHNoYXJlZE9wdGlvbnMuZm9yRWFjaCgoc2hhcmVkKT0+e1xuICAgICAgICAgICAgc2hhcmVWZXJzaW9uTWFwW3NoYXJlZC52ZXJzaW9uXSA9IHNoYXJlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlzTG9hZGVkKHNoYXJlVmVyc2lvbk1hcFtwcmV2XSkgJiYgdmVyc2lvbkx0KHByZXYsIGN1cik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heFZlcnNpb24gPSBmaW5kVmVyc2lvbihzaGFyZVZlcnNpb25NYXAsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHNoYXJlVmVyc2lvbk1hcFttYXhWZXJzaW9uXTtcbiAgICB9O1xuICAgIHZhciBfZXh0cmFPcHRpb25zX3Jlc29sdmVyO1xuICAgIGNvbnN0IHJlc29sdmVyID0gKF9leHRyYU9wdGlvbnNfcmVzb2x2ZXIgPSBleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5yZXNvbHZlcikgIT0gbnVsbCA/IF9leHRyYU9wdGlvbnNfcmVzb2x2ZXIgOiBkZWZhdWx0UmVzb2x2ZXI7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc29sdmVyKHNoYXJlSW5mb3NbcGtnTmFtZV0pLCBleHRyYU9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dHJhT3B0aW9ucy5jdXN0b21TaGFyZUluZm8pO1xufVxuXG5leHBvcnQgeyBnZXRHbG9iYWxTaGFyZVNjb3BlIGFzIEEsIGFkZFVuaXF1ZUl0ZW0gYXMgQiwgZ2V0QnVpbGRlcklkIGFzIEMsIERFRkFVTFRfUkVNT1RFX1RZUEUgYXMgRCwgc2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yIGFzIEUsIGdldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZSBhcyBGLCBHbG9iYWwgYXMgRywgZ2V0R2xvYmFsRmVkZXJhdGlvbkNvbnN0cnVjdG9yIGFzIEgsIHNldEdsb2JhbEZlZGVyYXRpb25JbnN0YW5jZSBhcyBJLCByZWdpc3Rlckdsb2JhbFBsdWdpbnMgYXMgSiwgbmF0aXZlR2xvYmFsIGFzIEssIHJlc2V0RmVkZXJhdGlvbkdsb2JhbEluZm8gYXMgTCwgZ2V0VGFyZ2V0U25hcHNob3RJbmZvQnlNb2R1bGVJbmZvIGFzIE0sIGdsb2JhbExvYWRpbmcgYXMgYSwgREVGQVVMVF9TQ09QRSBhcyBiLCBnZXRSZW1vdGVFbnRyeUV4cG9ydHMgYXMgYywgYXNzZXJ0IGFzIGQsIGdldEZNSWQgYXMgZSwgZXJyb3IgYXMgZiwgZ2V0R2xvYmFsSG9zdFBsdWdpbnMgYXMgZywgaXNQbGFpbk9iamVjdCBhcyBoLCBpc09iamVjdCBhcyBpLCBpc1JlbW90ZUluZm9XaXRoRW50cnkgYXMgaiwgaXNQdXJlUmVtb3RlRW50cnkgYXMgaywgZ2V0UmVtb3RlRW50cnlJbmZvRnJvbVNuYXBzaG90IGFzIGwsIGlzQnJvd3NlckVudiBhcyBtLCBnZXRJbmZvV2l0aG91dFR5cGUgYXMgbiwgZ2V0UHJlbG9hZGVkIGFzIG8sIHNldFByZWxvYWRlZCBhcyBwLCBnZXRSZWdpc3RlcmVkU2hhcmUgYXMgcSwgYXJyYXlPcHRpb25zIGFzIHIsIHNhZmVUb1N0cmluZyBhcyBzLCBnZXRHbG9iYWxTbmFwc2hvdEluZm9CeU1vZHVsZUluZm8gYXMgdCwgYWRkR2xvYmFsU25hcHNob3QgYXMgdSwgc2V0R2xvYmFsU25hcHNob3RJbmZvQnlNb2R1bGVJbmZvIGFzIHYsIHdhcm4gYXMgdywgZ2V0R2xvYmFsU25hcHNob3QgYXMgeCwgZm9ybWF0U2hhcmVDb25maWdzIGFzIHksIGdldFRhcmdldFNoYXJlZE9wdGlvbnMgYXMgeiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/runtime/dist/share.esm.js\n"));

/***/ }),

/***/ "./node_modules/@module-federation/sdk/dist/index.cjs.js":
/*!***************************************************************!*\
  !*** ./node_modules/@module-federation/sdk/dist/index.cjs.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst FederationModuleManifest = 'federation-manifest.json';\nconst MANIFEST_EXT = '.json';\nconst BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nconst BROWSER_LOG_VALUE = '1';\nconst NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nconst NameTransformMap = {\n    [NameTransformSymbol.AT]: 'scope_',\n    [NameTransformSymbol.HYPHEN]: '_',\n    [NameTransformSymbol.SLASH]: '__'\n};\nconst EncodedNameTransformMap = {\n    [NameTransformMap[NameTransformSymbol.AT]]: NameTransformSymbol.AT,\n    [NameTransformMap[NameTransformSymbol.HYPHEN]]: NameTransformSymbol.HYPHEN,\n    [NameTransformMap[NameTransformSymbol.SLASH]]: NameTransformSymbol.SLASH\n};\nconst SEPARATOR = ':';\nconst ManifestFileName = 'mf-manifest.json';\nconst StatsFileName = 'mf-stats.json';\nconst MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nconst MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\nconst ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';\nconst TEMP_DIR = '.federation';\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    return typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG);\n}\nconst getProcessEnv = function() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nconst DEBUG_LOG = '[ FEDERATION DEBUG ]';\nfunction safeGetLocalStorageItem() {\n    try {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n        }\n    } catch (error) {\n        return typeof document !== 'undefined';\n    }\n    return false;\n}\nlet Logger = class Logger {\n    info(msg, info) {\n        if (this.enable) {\n            const argsToString = safeToString(info) || '';\n            if (isBrowserEnv()) {\n                console.info(`%c ${this.identifier}: ${msg} ${argsToString}`, 'color:#3300CC');\n            } else {\n                console.info('\\x1b[34m%s', `${this.identifier}: ${msg} ${argsToString ? `\\n${argsToString}` : ''}`);\n            }\n        }\n    }\n    logOriginalInfo(...args) {\n        if (this.enable) {\n            if (isBrowserEnv()) {\n                console.info(`%c ${this.identifier}: OriginalInfo`, 'color:#3300CC');\n                console.log(...args);\n            } else {\n                console.info(`%c ${this.identifier}: OriginalInfo`, 'color:#3300CC');\n                console.log(...args);\n            }\n        }\n    }\n    constructor(identifier){\n        this.enable = false;\n        this.identifier = identifier || DEBUG_LOG;\n        if (isBrowserEnv() && safeGetLocalStorageItem()) {\n            this.enable = true;\n        } else if (isDebugMode()) {\n            this.enable = true;\n        }\n    }\n};\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nconst parseEntry = (str, devVerOrUrl, separator = SEPARATOR)=>{\n    const strSplit = str.split(separator);\n    const devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    const defaultVersion = '*';\n    const isEntry = (s)=>s.startsWith('http') || s.includes(MANIFEST_EXT);\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        let [name, ...versionOrEntryArr] = strSplit;\n        if (str.startsWith(separator)) {\n            versionOrEntryArr = [\n                devVersionOrUrl || strSplit.slice(-1)[0]\n            ];\n            name = strSplit.slice(0, -1).join(separator);\n        }\n        let versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        const [name] = strSplit;\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw `Invalid entry value: ${str}`;\n    }\n};\nconst logger = new Logger();\nconst composeKeyWithSeparator =  function(...args) {\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce((sum, cur)=>{\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return `${sum}${SEPARATOR}${cur}`;\n    }, '');\n};\nconst encodeName =  function(name, prefix = '', withExt = false) {\n    try {\n        const ext = withExt ? '.js' : '';\n        return `${prefix}${name.replace(new RegExp(`${NameTransformSymbol.AT}`, 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(`${NameTransformSymbol.HYPHEN}`, 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(`${NameTransformSymbol.SLASH}`, 'g'), NameTransformMap[NameTransformSymbol.SLASH])}${ext}`;\n    } catch (err) {\n        throw err;\n    }\n};\nconst decodeName =  function(name, prefix, withExt) {\n    try {\n        let decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(`${NameTransformMap[NameTransformSymbol.AT]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.SLASH]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.HYPHEN]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nconst generateExposeFilename =  (exposeName, withExt)=>{\n    if (!exposeName) {\n        return '';\n    }\n    let expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nconst generateShareFilename =  (pkgName, withExt)=>{\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nconst getResourceUrl = (module, sourceUrl)=>{\n    if ('getPublicPath' in module) {\n        let publicPath;\n        if (!module.getPublicPath.startsWith('function')) {\n            publicPath = new Function(module.getPublicPath)();\n        } else {\n            publicPath = new Function('return ' + module.getPublicPath)()();\n        }\n        return `${publicPath}${sourceUrl}`;\n    } else if ('publicPath' in module) {\n        return `${module.publicPath}${sourceUrl}`;\n    } else {\n        console.warn('Cannot get resource URL. If in debug mode, please ignore.', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst assert = (condition, msg)=>{\n    if (!condition) {\n        error(msg);\n    }\n};\nconst error = (msg)=>{\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n};\nconst warn = (msg)=>{\n    console.warn(`${LOG_CATEGORY}: ${msg}`);\n};\n\nfunction _extends() {\n    _extends = Object.assign || function assign(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\nconst simpleJoinRemoteEntry = (rPath, rName)=>{\n    if (!rPath) {\n        return rName;\n    }\n    const transformPath = (str)=>{\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            const strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    const transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return `${transformedPath}${rName}`;\n    }\n    return `${transformedPath}/${rName}`;\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest, options = {}) {\n    var _manifest_metaData, _manifest_metaData1;\n    const { remotes = {}, overrides = {}, version } = options;\n    let remoteSnapshot;\n    const getPublicPath = ()=>{\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    const overridesKeys = Object.keys(overrides);\n    let remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) == null ? void 0 : _manifest_remotes.reduce((res, next)=>{\n            let matchedVersion;\n            const name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach((key)=>remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        });\n    const { remoteEntry: { path: remoteEntryPath, name: remoteEntryName, type: remoteEntryType }, types: remoteTypes, buildInfo: { buildVersion }, globalName, ssrRemoteEntry } = manifest.metaData;\n    const { exposes } = manifest;\n    let basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion,\n        globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo,\n        shared: manifest == null ? void 0 : manifest.shared.map((item)=>({\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            })),\n        modules: exposes == null ? void 0 : exposes.map((expose)=>({\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            }))\n    };\n    if ((_manifest_metaData = manifest.metaData) == null ? void 0 : _manifest_metaData.prefetchInterface) {\n        const prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) == null ? void 0 : _manifest_metaData1.prefetchEntry) {\n        const { path, name, type } = manifest.metaData.prefetchEntry;\n        basicRemoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            publicPath: getPublicPath()\n        });\n    } else {\n        remoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            getPublicPath: getPublicPath()\n        });\n    }\n    if (ssrRemoteEntry) {\n        const fullSSRRemoteEntry = simpleJoinRemoteEntry(ssrRemoteEntry.path, ssrRemoteEntry.name);\n        remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;\n        remoteSnapshot.ssrRemoteEntryType = 'commonjs-module';\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function safeWrapper(callback, disableWarn) {\n    try {\n        const res = await callback();\n        return res;\n    } catch (e) {\n        !disableWarn && warn(e);\n        return;\n    }\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    const REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    const relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    const relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(info) {\n    // Retrieve the existing script element by its src attribute\n    let script = null;\n    let needAttach = true;\n    let timeout = 20000;\n    let timeoutId;\n    const scripts = document.getElementsByTagName('script');\n    for(let i = 0; i < scripts.length; i++){\n        const s = scripts[i];\n        const scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = info.url;\n        let createScriptRes = undefined;\n        if (info.createScriptHook) {\n            createScriptRes = info.createScriptHook(info.url, info.attrs);\n            if (createScriptRes instanceof HTMLScriptElement) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if ('script' in createScriptRes && createScriptRes.script) {\n                    script = createScriptRes.script;\n                }\n                if ('timeout' in createScriptRes && createScriptRes.timeout) {\n                    timeout = createScriptRes.timeout;\n                }\n            }\n        }\n        const attrs = info.attrs;\n        if (attrs && !createScriptRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (script) {\n                    if (name === 'async' || name === 'defer') {\n                        script[name] = attrs[name];\n                    // Attributes that do not exist are considered overridden\n                    } else if (!script.getAttribute(name)) {\n                        script.setAttribute(name, attrs[name]);\n                    }\n                }\n            });\n        }\n    }\n    const onScriptComplete = (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        var _info_cb;\n        clearTimeout(timeoutId);\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteScript = true } = info;\n                if (needDeleteScript) {\n                    (script == null ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n                }\n            });\n            if (prev) {\n                var _info_cb1;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const res = prev(event);\n                info == null ? void 0 : (_info_cb1 = info.cb) == null ? void 0 : _info_cb1.call(info);\n                return res;\n            }\n        }\n        info == null ? void 0 : (_info_cb = info.cb) == null ? void 0 : _info_cb.call(info);\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(()=>{\n        onScriptComplete(null, new Error(`Remote script \"${info.url}\" time-outed.`));\n    }, timeout);\n    return {\n        script,\n        needAttach\n    };\n}\nfunction createLink(info) {\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    let link = null;\n    let needAttach = true;\n    const links = document.getElementsByTagName('link');\n    for(let i = 0; i < links.length; i++){\n        const l = links[i];\n        const linkHref = l.getAttribute('href');\n        const linkRef = l.getAttribute('ref');\n        if (linkHref && isStaticResourcesEqual(linkHref, info.url) && linkRef === info.attrs['ref']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', info.url);\n        let createLinkRes = undefined;\n        const attrs = info.attrs;\n        if (info.createLinkHook) {\n            createLinkRes = info.createLinkHook(info.url, attrs);\n            if (createLinkRes instanceof HTMLLinkElement) {\n                link = createLinkRes;\n            }\n        }\n        if (attrs && !createLinkRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (link && !link.getAttribute(name)) {\n                    link.setAttribute(name, attrs[name]);\n                }\n            });\n        }\n    }\n    const onLinkComplete = (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteLink = true } = info;\n                if (needDeleteLink) {\n                    (link == null ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n                }\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const res = prev(event);\n                info.cb();\n                return res;\n            }\n        }\n        info.cb();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link,\n        needAttach\n    };\n}\nfunction loadScript(url, info) {\n    const { attrs = {}, createScriptHook } = info;\n    return new Promise((resolve, _reject)=>{\n        const { script, needAttach } = createScript({\n            url,\n            cb: resolve,\n            attrs: _extends({\n                fetchpriority: 'high'\n            }, attrs),\n            createScriptHook,\n            needDeleteScript: true\n        });\n        needAttach && document.head.appendChild(script);\n    });\n}\n\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    const importModule = new Function('name', `return import(name)`);\n    return importModule(name).then((res)=>res).catch((error)=>{\n        console.error(`Error importing module ${name}:`, error);\n        throw error;\n    });\n}\nconst loadNodeFetch = async ()=>{\n    const fetchModule = await importNodeModule('node-fetch');\n    return fetchModule.default || fetchModule;\n};\nconst lazyLoaderHookFetch = async (input, init)=>{\n    // @ts-ignore\n    const loaderHooks = __webpack_require__.federation.instance.loaderHook;\n    const hook = (url, init)=>{\n        return loaderHooks.lifecycle.fetch.emit(url, init);\n    };\n    const res = await hook(input, init || {});\n    if (!res || !(res instanceof Response)) {\n        const fetchFunction = typeof fetch === 'undefined' ? await loadNodeFetch() : fetch;\n        return fetchFunction(input, init || {});\n    }\n    return res;\n};\nfunction createScriptNode(url, cb, attrs, createScriptHook) {\n    if (createScriptHook) {\n        const hookResult = createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    let urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(`Invalid URL: ${e}`));\n        return;\n    }\n    const getFetch = async ()=>{\n        //@ts-ignore\n        if (true) {\n            try {\n                //@ts-ignore\n                const loaderHooks = __webpack_require__.federation.instance.loaderHook;\n                if (loaderHooks.lifecycle.fetch) {\n                    return lazyLoaderHookFetch;\n                }\n            } catch (e) {\n                console.warn('federation.instance.loaderHook.lifecycle.fetch failed:', e);\n            }\n        }\n        return typeof fetch === 'undefined' ? loadNodeFetch() : fetch;\n    };\n    const handleScriptFetch = async (f, urlObj)=>{\n        try {\n            var _vm_constants;\n            const res = await f(urlObj.href);\n            const data = await res.text();\n            const [path, vm] = await Promise.all([\n                importNodeModule('path'),\n                importNodeModule('vm')\n            ]);\n            const scriptContext = {\n                exports: {},\n                module: {\n                    exports: {}\n                }\n            };\n            const urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n            const filename = path.basename(urlObj.pathname);\n            var _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER;\n            const script = new vm.Script(`(function(exports, module, require, __dirname, __filename) {${data}\\n})`, {\n                filename,\n                importModuleDynamically: (_vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER = (_vm_constants = vm.constants) == null ? void 0 : _vm_constants.USE_MAIN_CONTEXT_DEFAULT_LOADER) != null ? _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER : importNodeModule\n            });\n            script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n            const exportedInterface = scriptContext.module.exports || scriptContext.exports;\n            if (attrs && exportedInterface && attrs['globalName']) {\n                const container = exportedInterface[attrs['globalName']] || exportedInterface;\n                cb(undefined, container);\n                return;\n            }\n            cb(undefined, exportedInterface);\n        } catch (e) {\n            cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));\n        }\n    };\n    getFetch().then((f)=>handleScriptFetch(f, urlObj)).catch((err)=>{\n        cb(err);\n    });\n}\nfunction loadScriptNode(url, info) {\n    return new Promise((resolve, reject)=>{\n        createScriptNode(url, (error, scriptContext)=>{\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                const remoteEntryKey = (info == null ? void 0 : (_info_attrs = info.attrs) == null ? void 0 : _info_attrs['globalName']) || `__FEDERATION_${info == null ? void 0 : (_info_attrs1 = info.attrs) == null ? void 0 : _info_attrs1['name']}:custom__`;\n                const entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.createScriptHook);\n    });\n}\n\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return _extends({}, defaultOptions, options);\n        }\n        throw new Error(`Unexpected type for \\`${key}\\`, expect boolean/undefined/object, got: ${typeof options}`);\n    };\n}\n\nexports.BROWSER_LOG_KEY = BROWSER_LOG_KEY;\nexports.BROWSER_LOG_VALUE = BROWSER_LOG_VALUE;\nexports.ENCODE_NAME_PREFIX = ENCODE_NAME_PREFIX;\nexports.EncodedNameTransformMap = EncodedNameTransformMap;\nexports.FederationModuleManifest = FederationModuleManifest;\nexports.Logger = Logger;\nexports.MANIFEST_EXT = MANIFEST_EXT;\nexports.MFModuleType = MFModuleType;\nexports.MODULE_DEVTOOL_IDENTIFIER = MODULE_DEVTOOL_IDENTIFIER;\nexports.ManifestFileName = ManifestFileName;\nexports.NameTransformMap = NameTransformMap;\nexports.NameTransformSymbol = NameTransformSymbol;\nexports.SEPARATOR = SEPARATOR;\nexports.StatsFileName = StatsFileName;\nexports.TEMP_DIR = TEMP_DIR;\nexports.assert = assert;\nexports.composeKeyWithSeparator = composeKeyWithSeparator;\nexports.containerPlugin = ContainerPlugin;\nexports.containerReferencePlugin = ContainerReferencePlugin;\nexports.createLink = createLink;\nexports.createScript = createScript;\nexports.createScriptNode = createScriptNode;\nexports.decodeName = decodeName;\nexports.encodeName = encodeName;\nexports.error = error;\nexports.generateExposeFilename = generateExposeFilename;\nexports.generateShareFilename = generateShareFilename;\nexports.generateSnapshotFromManifest = generateSnapshotFromManifest;\nexports.getProcessEnv = getProcessEnv;\nexports.getResourceUrl = getResourceUrl;\nexports.inferAutoPublicPath = inferAutoPublicPath;\nexports.isBrowserEnv = isBrowserEnv;\nexports.isDebugMode = isDebugMode;\nexports.isManifestProvider = isManifestProvider;\nexports.isStaticResourcesEqual = isStaticResourcesEqual;\nexports.loadScript = loadScript;\nexports.loadScriptNode = loadScriptNode;\nexports.logger = logger;\nexports.moduleFederationPlugin = ModuleFederationPlugin;\nexports.normalizeOptions = normalizeOptions;\nexports.parseEntry = parseEntry;\nexports.safeWrapper = safeWrapper;\nexports.sharePlugin = SharePlugin;\nexports.simpleJoinRemoteEntry = simpleJoinRemoteEntry;\nexports.warn = warn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3Nkay9kaXN0L2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPLG9CQUFvQixPQUFPLFFBQVEsT0FBTztBQUNoRSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPLG9CQUFvQixPQUFPLE9BQU8sT0FBTztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0IsSUFBSSxLQUFLLEVBQUUsYUFBYTtBQUMzRSxjQUFjO0FBQ2QsOENBQThDLGdCQUFnQixJQUFJLEtBQUssRUFBRSxvQkFBb0IsYUFBYSxPQUFPO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQSxjQUFjO0FBQ2QsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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L25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vc2RrL2Rpc3QvaW5kZXguY2pzLmpzPzEwYzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSAnZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uJztcbmNvbnN0IE1BTklGRVNUX0VYVCA9ICcuanNvbic7XG5jb25zdCBCUk9XU0VSX0xPR19LRVkgPSAnRkVERVJBVElPTl9ERUJVRyc7XG5jb25zdCBCUk9XU0VSX0xPR19WQUxVRSA9ICcxJztcbmNvbnN0IE5hbWVUcmFuc2Zvcm1TeW1ib2wgPSB7XG4gICAgQVQ6ICdAJyxcbiAgICBIWVBIRU46ICctJyxcbiAgICBTTEFTSDogJy8nXG59O1xuY29uc3QgTmFtZVRyYW5zZm9ybU1hcCA9IHtcbiAgICBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF06ICdzY29wZV8nLFxuICAgIFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl06ICdfJyxcbiAgICBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF06ICdfXydcbn07XG5jb25zdCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcCA9IHtcbiAgICBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXV06IE5hbWVUcmFuc2Zvcm1TeW1ib2wuQVQsXG4gICAgW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dXTogTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU4sXG4gICAgW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF1dOiBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXG59O1xuY29uc3QgU0VQQVJBVE9SID0gJzonO1xuY29uc3QgTWFuaWZlc3RGaWxlTmFtZSA9ICdtZi1tYW5pZmVzdC5qc29uJztcbmNvbnN0IFN0YXRzRmlsZU5hbWUgPSAnbWYtc3RhdHMuanNvbic7XG5jb25zdCBNRk1vZHVsZVR5cGUgPSB7XG4gICAgTlBNOiAnbnBtJyxcbiAgICBBUFA6ICdhcHAnXG59O1xuY29uc3QgTU9EVUxFX0RFVlRPT0xfSURFTlRJRklFUiA9ICdfX01GX0RFVlRPT0xTX01PRFVMRV9JTkZPX18nO1xuY29uc3QgRU5DT0RFX05BTUVfUFJFRklYID0gJ0VOQ09ERV9OQU1FX1BSRUZJWCc7XG5jb25zdCBURU1QX0RJUiA9ICcuZmVkZXJhdGlvbic7XG5cbnZhciBDb250YWluZXJQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBNb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG52YXIgU2hhcmVQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0RlYnVnTW9kZSgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52WydGRURFUkFUSU9OX0RFQlVHJ10pIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgRkVERVJBVElPTl9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgQm9vbGVhbihGRURFUkFUSU9OX0RFQlVHKTtcbn1cbmNvbnN0IGdldFByb2Nlc3NFbnYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ID8gcHJvY2Vzcy5lbnYgOiB7fTtcbn07XG5cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhpbmZvKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGluZm8sIG51bGwsIDIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmNvbnN0IERFQlVHX0xPRyA9ICdbIEZFREVSQVRJT04gREVCVUcgXSc7XG5mdW5jdGlvbiBzYWZlR2V0TG9jYWxTdG9yYWdlSXRlbSgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKEJST1dTRVJfTE9HX0tFWSkgPT09IEJST1dTRVJfTE9HX1ZBTFVFO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmxldCBMb2dnZXIgPSBjbGFzcyBMb2dnZXIge1xuICAgIGluZm8obXNnLCBpbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgYXJnc1RvU3RyaW5nID0gc2FmZVRvU3RyaW5nKGluZm8pIHx8ICcnO1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGAlYyAke3RoaXMuaWRlbnRpZmllcn06ICR7bXNnfSAke2FyZ3NUb1N0cmluZ31gLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ1xceDFiWzM0bSVzJywgYCR7dGhpcy5pZGVudGlmaWVyfTogJHttc2d9ICR7YXJnc1RvU3RyaW5nID8gYFxcbiR7YXJnc1RvU3RyaW5nfWAgOiAnJ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2dPcmlnaW5hbEluZm8oLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5lbmFibGUpIHtcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgJWMgJHt0aGlzLmlkZW50aWZpZXJ9OiBPcmlnaW5hbEluZm9gLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYCVjICR7dGhpcy5pZGVudGlmaWVyfTogT3JpZ2luYWxJbmZvYCwgJ2NvbG9yOiMzMzAwQ0MnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpZGVudGlmaWVyKXtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllciB8fCBERUJVR19MT0c7XG4gICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSAmJiBzYWZlR2V0TG9jYWxTdG9yYWdlSXRlbSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWJ1Z01vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgTE9HX0NBVEVHT1JZID0gJ1sgRmVkZXJhdGlvbiBSdW50aW1lIF0nO1xuLy8gZW50cnk6IG5hbWU6dmVyc2lvbiAgIHZlcnNpb24gOiAxLjAuMCB8IF4xLjIuM1xuLy8gZW50cnk6IG5hbWU6ZW50cnkgIGVudHJ5OiAgaHR0cHM6Ly9sb2NhbGhvc3Q6OTAwMC9mZWRlcmF0aW9uLW1hbmlmZXN0Lmpzb25cbmNvbnN0IHBhcnNlRW50cnkgPSAoc3RyLCBkZXZWZXJPclVybCwgc2VwYXJhdG9yID0gU0VQQVJBVE9SKT0+e1xuICAgIGNvbnN0IHN0clNwbGl0ID0gc3RyLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgY29uc3QgZGV2VmVyc2lvbk9yVXJsID0gZ2V0UHJvY2Vzc0VudigpWydOT0RFX0VOViddID09PSAnZGV2ZWxvcG1lbnQnICYmIGRldlZlck9yVXJsO1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9uID0gJyonO1xuICAgIGNvbnN0IGlzRW50cnkgPSAocyk9PnMuc3RhcnRzV2l0aCgnaHR0cCcpIHx8IHMuaW5jbHVkZXMoTUFOSUZFU1RfRVhUKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgdHlwZVxuICAgIGlmIChzdHJTcGxpdC5sZW5ndGggPj0gMikge1xuICAgICAgICBsZXQgW25hbWUsIC4uLnZlcnNpb25PckVudHJ5QXJyXSA9IHN0clNwbGl0O1xuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgdmVyc2lvbk9yRW50cnlBcnIgPSBbXG4gICAgICAgICAgICAgICAgZGV2VmVyc2lvbk9yVXJsIHx8IHN0clNwbGl0LnNsaWNlKC0xKVswXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG5hbWUgPSBzdHJTcGxpdC5zbGljZSgwLCAtMSkuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2ZXJzaW9uT3JFbnRyeSA9IGRldlZlcnNpb25PclVybCB8fCB2ZXJzaW9uT3JFbnRyeUFyci5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpc0VudHJ5KHZlcnNpb25PckVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGVudHJ5OiB2ZXJzaW9uT3JFbnRyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IHZlcnNpb24gcnVsZVxuICAgICAgICAgICAgLy8gZGV2VmVyc2lvbk9yVXJsID0+IGlucHV0VmVyc2lvbiA9PiBkZWZhdWx0VmVyc2lvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25PckVudHJ5IHx8IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJTcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgW25hbWVdID0gc3RyU3BsaXQ7XG4gICAgICAgIGlmIChkZXZWZXJzaW9uT3JVcmwgJiYgaXNFbnRyeShkZXZWZXJzaW9uT3JVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZW50cnk6IGRldlZlcnNpb25PclVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZlcnNpb246IGRldlZlcnNpb25PclVybCB8fCBkZWZhdWx0VmVyc2lvblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGBJbnZhbGlkIGVudHJ5IHZhbHVlOiAke3N0cn1gO1xuICAgIH1cbn07XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5jb25zdCBjb21wb3NlS2V5V2l0aFNlcGFyYXRvciA9ICBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3VtLCBjdXIpPT57XG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VtKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtzdW19JHtTRVBBUkFUT1J9JHtjdXJ9YDtcbiAgICB9LCAnJyk7XG59O1xuY29uc3QgZW5jb2RlTmFtZSA9ICBmdW5jdGlvbihuYW1lLCBwcmVmaXggPSAnJywgd2l0aEV4dCA9IGZhbHNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0ID0gd2l0aEV4dCA/ICcuanMnIDogJyc7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUfWAsICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF0pLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTn1gLCAnZycpLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXSkucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0h9YCwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSl9JHtleHR9YDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVOYW1lID0gIGZ1bmN0aW9uKG5hbWUsIHByZWZpeCwgd2l0aEV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBkZWNvZGVkTmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICghZGVjb2RlZE5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAocHJlZml4LCAnZycpLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7TmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXX1gLCAnZycpLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdXSkucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF19YCwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXV0pLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXX1gLCAnZycpLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXV0pO1xuICAgICAgICBpZiAod2l0aEV4dCkge1xuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKCcuanMnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbmNvbnN0IGdlbmVyYXRlRXhwb3NlRmlsZW5hbWUgPSAgKGV4cG9zZU5hbWUsIHdpdGhFeHQpPT57XG4gICAgaWYgKCFleHBvc2VOYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IGV4cG9zZSA9IGV4cG9zZU5hbWU7XG4gICAgaWYgKGV4cG9zZSA9PT0gJy4nKSB7XG4gICAgICAgIGV4cG9zZSA9ICdkZWZhdWx0X2V4cG9ydCc7XG4gICAgfVxuICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICBleHBvc2UgPSBleHBvc2UucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKGV4cG9zZSwgJ19fZmVkZXJhdGlvbl9leHBvc2VfJywgd2l0aEV4dCk7XG59O1xuY29uc3QgZ2VuZXJhdGVTaGFyZUZpbGVuYW1lID0gIChwa2dOYW1lLCB3aXRoRXh0KT0+e1xuICAgIGlmICghcGtnTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKHBrZ05hbWUsICdfX2ZlZGVyYXRpb25fc2hhcmVkXycsIHdpdGhFeHQpO1xufTtcbmNvbnN0IGdldFJlc291cmNlVXJsID0gKG1vZHVsZSwgc291cmNlVXJsKT0+e1xuICAgIGlmICgnZ2V0UHVibGljUGF0aCcgaW4gbW9kdWxlKSB7XG4gICAgICAgIGxldCBwdWJsaWNQYXRoO1xuICAgICAgICBpZiAoIW1vZHVsZS5nZXRQdWJsaWNQYXRoLnN0YXJ0c1dpdGgoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHB1YmxpY1BhdGggPSBuZXcgRnVuY3Rpb24obW9kdWxlLmdldFB1YmxpY1BhdGgpKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdWJsaWNQYXRoID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIG1vZHVsZS5nZXRQdWJsaWNQYXRoKSgpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3B1YmxpY1BhdGh9JHtzb3VyY2VVcmx9YDtcbiAgICB9IGVsc2UgaWYgKCdwdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIGAke21vZHVsZS5wdWJsaWNQYXRofSR7c291cmNlVXJsfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgZ2V0IHJlc291cmNlIFVSTC4gSWYgaW4gZGVidWcgbW9kZSwgcGxlYXNlIGlnbm9yZS4nLCBtb2R1bGUsIHNvdXJjZVVybCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmNvbnN0IGFzc2VydCA9IChjb25kaXRpb24sIG1zZyk9PntcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBlcnJvcihtc2cpO1xuICAgIH1cbn07XG5jb25zdCBlcnJvciA9IChtc2cpPT57XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke0xPR19DQVRFR09SWX06ICR7bXNnfWApO1xufTtcbmNvbnN0IHdhcm4gPSAobXNnKT0+e1xuICAgIGNvbnNvbGUud2FybihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSlpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmNvbnN0IHNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IChyUGF0aCwgck5hbWUpPT57XG4gICAgaWYgKCFyUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVBhdGggPSAoc3RyKT0+e1xuICAgICAgICBpZiAoc3RyID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cldpdGhvdXRTbGFzaCA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChzdHJXaXRob3V0U2xhc2guZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2guc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRTbGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNmb3JtZWRQYXRoID0gdHJhbnNmb3JtUGF0aChyUGF0aCk7XG4gICAgaWYgKCF0cmFuc2Zvcm1lZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJOYW1lO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3RyYW5zZm9ybWVkUGF0aH0ke3JOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHt0cmFuc2Zvcm1lZFBhdGh9LyR7ck5hbWV9YDtcbn07XG5mdW5jdGlvbiBpbmZlckF1dG9QdWJsaWNQYXRoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvIy4qJC8sICcnKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnLycpO1xufVxuLy8gUHJpb3JpdHk6IG92ZXJyaWRlcyA+IHJlbW90ZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG5mdW5jdGlvbiBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhLCBfbWFuaWZlc3RfbWV0YURhdGExO1xuICAgIGNvbnN0IHsgcmVtb3RlcyA9IHt9LCBvdmVycmlkZXMgPSB7fSwgdmVyc2lvbiB9ID0gb3B0aW9ucztcbiAgICBsZXQgcmVtb3RlU25hcHNob3Q7XG4gICAgY29uc3QgZ2V0UHVibGljUGF0aCA9ICgpPT57XG4gICAgICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdC5tZXRhRGF0YS5wdWJsaWNQYXRoID09PSAnYXV0bycgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHB1YmxpY1BhdGggYXV0byBydW50aW1lIG1vZHVsZSBpbXBsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZmVyQXV0b1B1YmxpY1BhdGgodmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5tZXRhRGF0YS5nZXRQdWJsaWNQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvdmVycmlkZXNLZXlzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKTtcbiAgICBsZXQgcmVtb3Rlc0luZm8gPSB7fTtcbiAgICAvLyBJZiByZW1vdGVzIGFyZSBub3QgcHJvdmlkZWQsIG9ubHkgdGhlIHJlbW90ZXMgaW4gdGhlIG1hbmlmZXN0IHdpbGwgYmUgcmVhZFxuICAgIGlmICghT2JqZWN0LmtleXMocmVtb3RlcykubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfbWFuaWZlc3RfcmVtb3RlcztcbiAgICAgICAgcmVtb3Rlc0luZm8gPSAoKF9tYW5pZmVzdF9yZW1vdGVzID0gbWFuaWZlc3QucmVtb3RlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9yZW1vdGVzLnJlZHVjZSgocmVzLCBuZXh0KT0+e1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRWZXJzaW9uO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5leHQuZmVkZXJhdGlvbkNvbnRhaW5lck5hbWU7XG4gICAgICAgICAgICAvLyBvdmVycmlkZXMgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXNLZXlzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgndmVyc2lvbicgaW4gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQuZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwge30pKSB8fCB7fTtcbiAgICB9XG4gICAgLy8gSWYgcmVtb3RlcyAoZGVwbG95IHNjZW5hcmlvKSBhcmUgc3BlY2lmaWVkLCB0aGV5IG5lZWQgdG8gYmUgdHJhdmVyc2VkIGFnYWluXG4gICAgT2JqZWN0LmtleXMocmVtb3RlcykuZm9yRWFjaCgoa2V5KT0+cmVtb3Rlc0luZm9ba2V5XSA9IHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlcyB3aWxsIG92ZXJyaWRlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246IG92ZXJyaWRlc0tleXMuaW5jbHVkZXMoa2V5KSA/IG92ZXJyaWRlc1trZXldIDogcmVtb3Rlc1trZXldXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHsgcmVtb3RlRW50cnk6IHsgcGF0aDogcmVtb3RlRW50cnlQYXRoLCBuYW1lOiByZW1vdGVFbnRyeU5hbWUsIHR5cGU6IHJlbW90ZUVudHJ5VHlwZSB9LCB0eXBlczogcmVtb3RlVHlwZXMsIGJ1aWxkSW5mbzogeyBidWlsZFZlcnNpb24gfSwgZ2xvYmFsTmFtZSwgc3NyUmVtb3RlRW50cnkgfSA9IG1hbmlmZXN0Lm1ldGFEYXRhO1xuICAgIGNvbnN0IHsgZXhwb3NlcyB9ID0gbWFuaWZlc3Q7XG4gICAgbGV0IGJhc2ljUmVtb3RlU25hcHNob3QgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24gPyB2ZXJzaW9uIDogJycsXG4gICAgICAgIGJ1aWxkVmVyc2lvbixcbiAgICAgICAgZ2xvYmFsTmFtZSxcbiAgICAgICAgcmVtb3RlRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVFbnRyeVBhdGgsIHJlbW90ZUVudHJ5TmFtZSksXG4gICAgICAgIHJlbW90ZUVudHJ5VHlwZSxcbiAgICAgICAgcmVtb3RlVHlwZXM6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVUeXBlcy5wYXRoLCByZW1vdGVUeXBlcy5uYW1lKSxcbiAgICAgICAgcmVtb3RlVHlwZXNaaXA6IHJlbW90ZVR5cGVzLnppcCB8fCAnJyxcbiAgICAgICAgcmVtb3RlVHlwZXNBUEk6IHJlbW90ZVR5cGVzLmFwaSB8fCAnJyxcbiAgICAgICAgcmVtb3Rlc0luZm8sXG4gICAgICAgIHNoYXJlZDogbWFuaWZlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IG1hbmlmZXN0LnNoYXJlZC5tYXAoKGl0ZW0pPT4oe1xuICAgICAgICAgICAgICAgIGFzc2V0czogaXRlbS5hc3NldHMsXG4gICAgICAgICAgICAgICAgc2hhcmVkTmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGl0ZW0udmVyc2lvblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBtb2R1bGVzOiBleHBvc2VzID09IG51bGwgPyB2b2lkIDAgOiBleHBvc2VzLm1hcCgoZXhwb3NlKT0+KHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBleHBvc2UubmFtZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVQYXRoOiBleHBvc2UucGF0aCxcbiAgICAgICAgICAgICAgICBhc3NldHM6IGV4cG9zZS5hc3NldHNcbiAgICAgICAgICAgIH0pKVxuICAgIH07XG4gICAgaWYgKChfbWFuaWZlc3RfbWV0YURhdGEgPSBtYW5pZmVzdC5tZXRhRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZSkge1xuICAgICAgICBjb25zdCBwcmVmZXRjaEludGVyZmFjZSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gX2V4dGVuZHMoe30sIGJhc2ljUmVtb3RlU25hcHNob3QsIHtcbiAgICAgICAgICAgIHByZWZldGNoSW50ZXJmYWNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKF9tYW5pZmVzdF9tZXRhRGF0YTEgPSBtYW5pZmVzdC5tZXRhRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YTEucHJlZmV0Y2hFbnRyeSkge1xuICAgICAgICBjb25zdCB7IHBhdGgsIG5hbWUsIHR5cGUgfSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoRW50cnk7XG4gICAgICAgIGJhc2ljUmVtb3RlU25hcHNob3QgPSBfZXh0ZW5kcyh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCwge1xuICAgICAgICAgICAgcHJlZmV0Y2hFbnRyeTogc2ltcGxlSm9pblJlbW90ZUVudHJ5KHBhdGgsIG5hbWUpLFxuICAgICAgICAgICAgcHJlZmV0Y2hFbnRyeVR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgcmVtb3RlU25hcHNob3QgPSBfZXh0ZW5kcyh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCwge1xuICAgICAgICAgICAgcHVibGljUGF0aDogZ2V0UHVibGljUGF0aCgpXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90ID0gX2V4dGVuZHMoe30sIGJhc2ljUmVtb3RlU25hcHNob3QsIHtcbiAgICAgICAgICAgIGdldFB1YmxpY1BhdGg6IGdldFB1YmxpY1BhdGgoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNzclJlbW90ZUVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGZ1bGxTU1JSZW1vdGVFbnRyeSA9IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShzc3JSZW1vdGVFbnRyeS5wYXRoLCBzc3JSZW1vdGVFbnRyeS5uYW1lKTtcbiAgICAgICAgcmVtb3RlU25hcHNob3Quc3NyUmVtb3RlRW50cnkgPSBmdWxsU1NSUmVtb3RlRW50cnk7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90LnNzclJlbW90ZUVudHJ5VHlwZSA9ICdjb21tb25qcy1tb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlU25hcHNob3Q7XG59XG5mdW5jdGlvbiBpc01hbmlmZXN0UHJvdmlkZXIobW9kdWxlSW5mbykge1xuICAgIGlmICgncmVtb3RlRW50cnknIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mby5yZW1vdGVFbnRyeS5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5hc3luYyBmdW5jdGlvbiBzYWZlV3JhcHBlcihjYWxsYmFjaywgZGlzYWJsZVdhcm4pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgIWRpc2FibGVXYXJuICYmIHdhcm4oZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKHVybDEsIHVybDIpIHtcbiAgICBjb25zdCBSRUdfRVhQID0gL14oaHR0cHM/Oik/XFwvXFwvL2k7XG4gICAgLy8gVHJhbnNmb3JtIHVybDEgYW5kIHVybDIgaW50byByZWxhdGl2ZSBwYXRoc1xuICAgIGNvbnN0IHJlbGF0aXZlVXJsMSA9IHVybDEucmVwbGFjZShSRUdfRVhQLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICBjb25zdCByZWxhdGl2ZVVybDIgPSB1cmwyLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbGF0aXZlIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICByZXR1cm4gcmVsYXRpdmVVcmwxID09PSByZWxhdGl2ZVVybDI7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHQoaW5mbykge1xuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIGxldCBzY3JpcHQgPSBudWxsO1xuICAgIGxldCBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICBsZXQgdGltZW91dCA9IDIwMDAwO1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3Qgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHMgPSBzY3JpcHRzW2ldO1xuICAgICAgICBjb25zdCBzY3JpcHRTcmMgPSBzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIGlmIChzY3JpcHRTcmMgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChzY3JpcHRTcmMsIGluZm8udXJsKSkge1xuICAgICAgICAgICAgc2NyaXB0ID0gcztcbiAgICAgICAgICAgIG5lZWRBdHRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuc3JjID0gaW5mby51cmw7XG4gICAgICAgIGxldCBjcmVhdGVTY3JpcHRSZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpbmZvLmNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFJlcyA9IGluZm8uY3JlYXRlU2NyaXB0SG9vayhpbmZvLnVybCwgaW5mby5hdHRycyk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlU2NyaXB0UmVzIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjcmVhdGVTY3JpcHRSZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzY3JpcHQnIGluIGNyZWF0ZVNjcmlwdFJlcyAmJiBjcmVhdGVTY3JpcHRSZXMuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGNyZWF0ZVNjcmlwdFJlcy5zY3JpcHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgndGltZW91dCcgaW4gY3JlYXRlU2NyaXB0UmVzICYmIGNyZWF0ZVNjcmlwdFJlcy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBjcmVhdGVTY3JpcHRSZXMudGltZW91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cnMgPSBpbmZvLmF0dHJzO1xuICAgICAgICBpZiAoYXR0cnMgJiYgIWNyZWF0ZVNjcmlwdFJlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKG5hbWUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2FzeW5jJyB8fCBuYW1lID09PSAnZGVmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRbbmFtZV0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlcyB0aGF0IGRvIG5vdCBleGlzdCBhcmUgY29uc2lkZXJlZCBvdmVycmlkZGVuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNjcmlwdC5nZXRBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb25TY3JpcHRDb21wbGV0ZSA9IChwcmV2LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGV2ZW50KT0+e1xuICAgICAgICB2YXIgX2luZm9fY2I7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRS5cbiAgICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBzYWZlV3JhcHBlcigoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmVlZERlbGV0ZVNjcmlwdCA9IHRydWUgfSA9IGluZm87XG4gICAgICAgICAgICAgICAgaWYgKG5lZWREZWxldGVTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKHNjcmlwdCA9PSBudWxsID8gdm9pZCAwIDogc2NyaXB0LnBhcmVudE5vZGUpICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIHZhciBfaW5mb19jYjE7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX2luZm9fY2IxID0gaW5mby5jYikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbmZvX2NiMS5jYWxsKGluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5mbyA9PSBudWxsID8gdm9pZCAwIDogKF9pbmZvX2NiID0gaW5mby5jYikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbmZvX2NiLmNhbGwoaW5mbyk7XG4gICAgfTtcbiAgICBzY3JpcHQub25lcnJvciA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25lcnJvcik7XG4gICAgc2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25sb2FkKTtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgIG9uU2NyaXB0Q29tcGxldGUobnVsbCwgbmV3IEVycm9yKGBSZW1vdGUgc2NyaXB0IFwiJHtpbmZvLnVybH1cIiB0aW1lLW91dGVkLmApKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY3JpcHQsXG4gICAgICAgIG5lZWRBdHRhY2hcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTGluayhpbmZvKSB7XG4gICAgLy8gPGxpbmsgcmVsPVwicHJlbG9hZFwiIGhyZWY9XCJzY3JpcHQuanNcIiBhcz1cInNjcmlwdFwiPlxuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIGxldCBsaW5rID0gbnVsbDtcbiAgICBsZXQgbmVlZEF0dGFjaCA9IHRydWU7XG4gICAgY29uc3QgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGwgPSBsaW5rc1tpXTtcbiAgICAgICAgY29uc3QgbGlua0hyZWYgPSBsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICBjb25zdCBsaW5rUmVmID0gbC5nZXRBdHRyaWJ1dGUoJ3JlZicpO1xuICAgICAgICBpZiAobGlua0hyZWYgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChsaW5rSHJlZiwgaW5mby51cmwpICYmIGxpbmtSZWYgPT09IGluZm8uYXR0cnNbJ3JlZiddKSB7XG4gICAgICAgICAgICBsaW5rID0gbDtcbiAgICAgICAgICAgIG5lZWRBdHRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIGluZm8udXJsKTtcbiAgICAgICAgbGV0IGNyZWF0ZUxpbmtSZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gaW5mby5hdHRycztcbiAgICAgICAgaWYgKGluZm8uY3JlYXRlTGlua0hvb2spIHtcbiAgICAgICAgICAgIGNyZWF0ZUxpbmtSZXMgPSBpbmZvLmNyZWF0ZUxpbmtIb29rKGluZm8udXJsLCBhdHRycyk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlTGlua1JlcyBpbnN0YW5jZW9mIEhUTUxMaW5rRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGxpbmsgPSBjcmVhdGVMaW5rUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyAmJiAhY3JlYXRlTGlua1Jlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKG5hbWUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgJiYgIWxpbmsuZ2V0QXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvbkxpbmtDb21wbGV0ZSA9IChwcmV2LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGV2ZW50KT0+e1xuICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRS5cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsaW5rLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBzYWZlV3JhcHBlcigoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmVlZERlbGV0ZUxpbmsgPSB0cnVlIH0gPSBpbmZvO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkRGVsZXRlTGluaykge1xuICAgICAgICAgICAgICAgICAgICAobGluayA9PSBudWxsID8gdm9pZCAwIDogbGluay5wYXJlbnROb2RlKSAmJiBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gcHJldihldmVudCk7XG4gICAgICAgICAgICAgICAgaW5mby5jYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5jYigpO1xuICAgIH07XG4gICAgbGluay5vbmVycm9yID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9uZXJyb3IpO1xuICAgIGxpbmsub25sb2FkID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9ubG9hZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluayxcbiAgICAgICAgbmVlZEF0dGFjaFxuICAgIH07XG59XG5mdW5jdGlvbiBsb2FkU2NyaXB0KHVybCwgaW5mbykge1xuICAgIGNvbnN0IHsgYXR0cnMgPSB7fSwgY3JlYXRlU2NyaXB0SG9vayB9ID0gaW5mbztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHsgc2NyaXB0LCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVTY3JpcHQoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgY2I6IHJlc29sdmUsXG4gICAgICAgICAgICBhdHRyczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGZldGNocHJpb3JpdHk6ICdoaWdoJ1xuICAgICAgICAgICAgfSwgYXR0cnMpLFxuICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vayxcbiAgICAgICAgICAgIG5lZWREZWxldGVTY3JpcHQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG5lZWRBdHRhY2ggJiYgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbXBvcnROb2RlTW9kdWxlKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbXBvcnQgc3BlY2lmaWVyIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGltcG9ydE1vZHVsZSA9IG5ldyBGdW5jdGlvbignbmFtZScsIGByZXR1cm4gaW1wb3J0KG5hbWUpYCk7XG4gICAgcmV0dXJuIGltcG9ydE1vZHVsZShuYW1lKS50aGVuKChyZXMpPT5yZXMpLmNhdGNoKChlcnJvcik9PntcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW1wb3J0aW5nIG1vZHVsZSAke25hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5jb25zdCBsb2FkTm9kZUZldGNoID0gYXN5bmMgKCk9PntcbiAgICBjb25zdCBmZXRjaE1vZHVsZSA9IGF3YWl0IGltcG9ydE5vZGVNb2R1bGUoJ25vZGUtZmV0Y2gnKTtcbiAgICByZXR1cm4gZmV0Y2hNb2R1bGUuZGVmYXVsdCB8fCBmZXRjaE1vZHVsZTtcbn07XG5jb25zdCBsYXp5TG9hZGVySG9va0ZldGNoID0gYXN5bmMgKGlucHV0LCBpbml0KT0+e1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBsb2FkZXJIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YW5jZS5sb2FkZXJIb29rO1xuICAgIGNvbnN0IGhvb2sgPSAodXJsLCBpbml0KT0+e1xuICAgICAgICByZXR1cm4gbG9hZGVySG9va3MubGlmZWN5Y2xlLmZldGNoLmVtaXQodXJsLCBpbml0KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGhvb2soaW5wdXQsIGluaXQgfHwge30pO1xuICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIGNvbnN0IGZldGNoRnVuY3Rpb24gPSB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnID8gYXdhaXQgbG9hZE5vZGVGZXRjaCgpIDogZmV0Y2g7XG4gICAgICAgIHJldHVybiBmZXRjaEZ1bmN0aW9uKGlucHV0LCBpbml0IHx8IHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHROb2RlKHVybCwgY2IsIGF0dHJzLCBjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgaWYgKGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgY29uc3QgaG9va1Jlc3VsdCA9IGNyZWF0ZVNjcmlwdEhvb2sodXJsKTtcbiAgICAgICAgaWYgKGhvb2tSZXN1bHQgJiYgdHlwZW9mIGhvb2tSZXN1bHQgPT09ICdvYmplY3QnICYmICd1cmwnIGluIGhvb2tSZXN1bHQpIHtcbiAgICAgICAgICAgIHVybCA9IGhvb2tSZXN1bHQudXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB1cmxPYmo7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29uc3RydWN0aW5nIFVSTDonLCBlKTtcbiAgICAgICAgY2IobmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHtlfWApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnZXRGZXRjaCA9IGFzeW5jICgpPT57XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBpZiAodHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlckhvb2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbmNlLmxvYWRlckhvb2s7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlckhvb2tzLmxpZmVjeWNsZS5mZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGF6eUxvYWRlckhvb2tGZXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdmZWRlcmF0aW9uLmluc3RhbmNlLmxvYWRlckhvb2subGlmZWN5Y2xlLmZldGNoIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJyA/IGxvYWROb2RlRmV0Y2goKSA6IGZldGNoO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU2NyaXB0RmV0Y2ggPSBhc3luYyAoZiwgdXJsT2JqKT0+e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF92bV9jb25zdGFudHM7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmKHVybE9iai5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgY29uc3QgW3BhdGgsIHZtXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCdwYXRoJyksXG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgndm0nKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHRDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgIG1vZHVsZToge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cmxEaXJuYW1lID0gdXJsT2JqLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh1cmxPYmoucGF0aG5hbWUpO1xuICAgICAgICAgICAgdmFyIF92bV9jb25zdGFudHNfVVNFX01BSU5fQ09OVEVYVF9ERUZBVUxUX0xPQURFUjtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IG5ldyB2bS5TY3JpcHQoYChmdW5jdGlvbihleHBvcnRzLCBtb2R1bGUsIHJlcXVpcmUsIF9fZGlybmFtZSwgX19maWxlbmFtZSkgeyR7ZGF0YX1cXG59KWAsIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBpbXBvcnRNb2R1bGVEeW5hbWljYWxseTogKF92bV9jb25zdGFudHNfVVNFX01BSU5fQ09OVEVYVF9ERUZBVUxUX0xPQURFUiA9IChfdm1fY29uc3RhbnRzID0gdm0uY29uc3RhbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX3ZtX2NvbnN0YW50cy5VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSKSAhPSBudWxsID8gX3ZtX2NvbnN0YW50c19VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSIDogaW1wb3J0Tm9kZU1vZHVsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY3JpcHQucnVuSW5UaGlzQ29udGV4dCgpKHNjcmlwdENvbnRleHQuZXhwb3J0cywgc2NyaXB0Q29udGV4dC5tb2R1bGUsIGV2YWwoJ3JlcXVpcmUnKSwgdXJsRGlybmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRJbnRlcmZhY2UgPSBzY3JpcHRDb250ZXh0Lm1vZHVsZS5leHBvcnRzIHx8IHNjcmlwdENvbnRleHQuZXhwb3J0cztcbiAgICAgICAgICAgIGlmIChhdHRycyAmJiBleHBvcnRlZEludGVyZmFjZSAmJiBhdHRyc1snZ2xvYmFsTmFtZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZXhwb3J0ZWRJbnRlcmZhY2VbYXR0cnNbJ2dsb2JhbE5hbWUnXV0gfHwgZXhwb3J0ZWRJbnRlcmZhY2U7XG4gICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHVuZGVmaW5lZCwgZXhwb3J0ZWRJbnRlcmZhY2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYihlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKGBTY3JpcHQgZXhlY3V0aW9uIGVycm9yOiAke2V9YCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBnZXRGZXRjaCgpLnRoZW4oKGYpPT5oYW5kbGVTY3JpcHRGZXRjaChmLCB1cmxPYmopKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBjYihlcnIpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdE5vZGUodXJsLCBpbmZvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNyZWF0ZVNjcmlwdE5vZGUodXJsLCAoZXJyb3IsIHNjcmlwdENvbnRleHQpPT57XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luZm9fYXR0cnMsIF9pbmZvX2F0dHJzMTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeUtleSA9IChpbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnNbJ2dsb2JhbE5hbWUnXSkgfHwgYF9fRkVERVJBVElPTl8ke2luZm8gPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5mb19hdHRyczEgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnMxWyduYW1lJ119OmN1c3RvbV9fYDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeUV4cG9ydHMgPSBnbG9iYWxUaGlzW3JlbW90ZUVudHJ5S2V5XSA9IHNjcmlwdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbmZvLmF0dHJzLCBpbmZvLmNyZWF0ZVNjcmlwdEhvb2spO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGVuYWJsZURlZmF1bHQsIGRlZmF1bHRPcHRpb25zLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgLCBleHBlY3QgYm9vbGVhbi91bmRlZmluZWQvb2JqZWN0LCBnb3Q6ICR7dHlwZW9mIG9wdGlvbnN9YCk7XG4gICAgfTtcbn1cblxuZXhwb3J0cy5CUk9XU0VSX0xPR19LRVkgPSBCUk9XU0VSX0xPR19LRVk7XG5leHBvcnRzLkJST1dTRVJfTE9HX1ZBTFVFID0gQlJPV1NFUl9MT0dfVkFMVUU7XG5leHBvcnRzLkVOQ09ERV9OQU1FX1BSRUZJWCA9IEVOQ09ERV9OQU1FX1BSRUZJWDtcbmV4cG9ydHMuRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXAgPSBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcDtcbmV4cG9ydHMuRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0ID0gRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0O1xuZXhwb3J0cy5Mb2dnZXIgPSBMb2dnZXI7XG5leHBvcnRzLk1BTklGRVNUX0VYVCA9IE1BTklGRVNUX0VYVDtcbmV4cG9ydHMuTUZNb2R1bGVUeXBlID0gTUZNb2R1bGVUeXBlO1xuZXhwb3J0cy5NT0RVTEVfREVWVE9PTF9JREVOVElGSUVSID0gTU9EVUxFX0RFVlRPT0xfSURFTlRJRklFUjtcbmV4cG9ydHMuTWFuaWZlc3RGaWxlTmFtZSA9IE1hbmlmZXN0RmlsZU5hbWU7XG5leHBvcnRzLk5hbWVUcmFuc2Zvcm1NYXAgPSBOYW1lVHJhbnNmb3JtTWFwO1xuZXhwb3J0cy5OYW1lVHJhbnNmb3JtU3ltYm9sID0gTmFtZVRyYW5zZm9ybVN5bWJvbDtcbmV4cG9ydHMuU0VQQVJBVE9SID0gU0VQQVJBVE9SO1xuZXhwb3J0cy5TdGF0c0ZpbGVOYW1lID0gU3RhdHNGaWxlTmFtZTtcbmV4cG9ydHMuVEVNUF9ESVIgPSBURU1QX0RJUjtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5jb21wb3NlS2V5V2l0aFNlcGFyYXRvciA9IGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yO1xuZXhwb3J0cy5jb250YWluZXJQbHVnaW4gPSBDb250YWluZXJQbHVnaW47XG5leHBvcnRzLmNvbnRhaW5lclJlZmVyZW5jZVBsdWdpbiA9IENvbnRhaW5lclJlZmVyZW5jZVBsdWdpbjtcbmV4cG9ydHMuY3JlYXRlTGluayA9IGNyZWF0ZUxpbms7XG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGNyZWF0ZVNjcmlwdDtcbmV4cG9ydHMuY3JlYXRlU2NyaXB0Tm9kZSA9IGNyZWF0ZVNjcmlwdE5vZGU7XG5leHBvcnRzLmRlY29kZU5hbWUgPSBkZWNvZGVOYW1lO1xuZXhwb3J0cy5lbmNvZGVOYW1lID0gZW5jb2RlTmFtZTtcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmV4cG9ydHMuZ2VuZXJhdGVFeHBvc2VGaWxlbmFtZSA9IGdlbmVyYXRlRXhwb3NlRmlsZW5hbWU7XG5leHBvcnRzLmdlbmVyYXRlU2hhcmVGaWxlbmFtZSA9IGdlbmVyYXRlU2hhcmVGaWxlbmFtZTtcbmV4cG9ydHMuZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCA9IGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3Q7XG5leHBvcnRzLmdldFByb2Nlc3NFbnYgPSBnZXRQcm9jZXNzRW52O1xuZXhwb3J0cy5nZXRSZXNvdXJjZVVybCA9IGdldFJlc291cmNlVXJsO1xuZXhwb3J0cy5pbmZlckF1dG9QdWJsaWNQYXRoID0gaW5mZXJBdXRvUHVibGljUGF0aDtcbmV4cG9ydHMuaXNCcm93c2VyRW52ID0gaXNCcm93c2VyRW52O1xuZXhwb3J0cy5pc0RlYnVnTW9kZSA9IGlzRGVidWdNb2RlO1xuZXhwb3J0cy5pc01hbmlmZXN0UHJvdmlkZXIgPSBpc01hbmlmZXN0UHJvdmlkZXI7XG5leHBvcnRzLmlzU3RhdGljUmVzb3VyY2VzRXF1YWwgPSBpc1N0YXRpY1Jlc291cmNlc0VxdWFsO1xuZXhwb3J0cy5sb2FkU2NyaXB0ID0gbG9hZFNjcmlwdDtcbmV4cG9ydHMubG9hZFNjcmlwdE5vZGUgPSBsb2FkU2NyaXB0Tm9kZTtcbmV4cG9ydHMubG9nZ2VyID0gbG9nZ2VyO1xuZXhwb3J0cy5tb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gTW9kdWxlRmVkZXJhdGlvblBsdWdpbjtcbmV4cG9ydHMubm9ybWFsaXplT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnM7XG5leHBvcnRzLnBhcnNlRW50cnkgPSBwYXJzZUVudHJ5O1xuZXhwb3J0cy5zYWZlV3JhcHBlciA9IHNhZmVXcmFwcGVyO1xuZXhwb3J0cy5zaGFyZVBsdWdpbiA9IFNoYXJlUGx1Z2luO1xuZXhwb3J0cy5zaW1wbGVKb2luUmVtb3RlRW50cnkgPSBzaW1wbGVKb2luUmVtb3RlRW50cnk7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/sdk/dist/index.cjs.js\n"));

/***/ }),

/***/ "./node_modules/@module-federation/sdk/dist/index.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@module-federation/sdk/dist/index.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BROWSER_LOG_KEY: function() { return /* binding */ BROWSER_LOG_KEY; },\n/* harmony export */   BROWSER_LOG_VALUE: function() { return /* binding */ BROWSER_LOG_VALUE; },\n/* harmony export */   ENCODE_NAME_PREFIX: function() { return /* binding */ ENCODE_NAME_PREFIX; },\n/* harmony export */   EncodedNameTransformMap: function() { return /* binding */ EncodedNameTransformMap; },\n/* harmony export */   FederationModuleManifest: function() { return /* binding */ FederationModuleManifest; },\n/* harmony export */   Logger: function() { return /* binding */ Logger; },\n/* harmony export */   MANIFEST_EXT: function() { return /* binding */ MANIFEST_EXT; },\n/* harmony export */   MFModuleType: function() { return /* binding */ MFModuleType; },\n/* harmony export */   MODULE_DEVTOOL_IDENTIFIER: function() { return /* binding */ MODULE_DEVTOOL_IDENTIFIER; },\n/* harmony export */   ManifestFileName: function() { return /* binding */ ManifestFileName; },\n/* harmony export */   NameTransformMap: function() { return /* binding */ NameTransformMap; },\n/* harmony export */   NameTransformSymbol: function() { return /* binding */ NameTransformSymbol; },\n/* harmony export */   SEPARATOR: function() { return /* binding */ SEPARATOR; },\n/* harmony export */   StatsFileName: function() { return /* binding */ StatsFileName; },\n/* harmony export */   TEMP_DIR: function() { return /* binding */ TEMP_DIR; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   composeKeyWithSeparator: function() { return /* binding */ composeKeyWithSeparator; },\n/* harmony export */   containerPlugin: function() { return /* binding */ ContainerPlugin; },\n/* harmony export */   containerReferencePlugin: function() { return /* binding */ ContainerReferencePlugin; },\n/* harmony export */   createLink: function() { return /* binding */ createLink; },\n/* harmony export */   createScript: function() { return /* binding */ createScript; },\n/* harmony export */   createScriptNode: function() { return /* binding */ createScriptNode; },\n/* harmony export */   decodeName: function() { return /* binding */ decodeName; },\n/* harmony export */   encodeName: function() { return /* binding */ encodeName; },\n/* harmony export */   error: function() { return /* binding */ error; },\n/* harmony export */   generateExposeFilename: function() { return /* binding */ generateExposeFilename; },\n/* harmony export */   generateShareFilename: function() { return /* binding */ generateShareFilename; },\n/* harmony export */   generateSnapshotFromManifest: function() { return /* binding */ generateSnapshotFromManifest; },\n/* harmony export */   getProcessEnv: function() { return /* binding */ getProcessEnv; },\n/* harmony export */   getResourceUrl: function() { return /* binding */ getResourceUrl; },\n/* harmony export */   inferAutoPublicPath: function() { return /* binding */ inferAutoPublicPath; },\n/* harmony export */   isBrowserEnv: function() { return /* binding */ isBrowserEnv; },\n/* harmony export */   isDebugMode: function() { return /* binding */ isDebugMode; },\n/* harmony export */   isManifestProvider: function() { return /* binding */ isManifestProvider; },\n/* harmony export */   isStaticResourcesEqual: function() { return /* binding */ isStaticResourcesEqual; },\n/* harmony export */   loadScript: function() { return /* binding */ loadScript; },\n/* harmony export */   loadScriptNode: function() { return /* binding */ loadScriptNode; },\n/* harmony export */   logger: function() { return /* binding */ logger; },\n/* harmony export */   moduleFederationPlugin: function() { return /* binding */ ModuleFederationPlugin; },\n/* harmony export */   normalizeOptions: function() { return /* binding */ normalizeOptions; },\n/* harmony export */   parseEntry: function() { return /* binding */ parseEntry; },\n/* harmony export */   safeWrapper: function() { return /* binding */ safeWrapper; },\n/* harmony export */   sharePlugin: function() { return /* binding */ SharePlugin; },\n/* harmony export */   simpleJoinRemoteEntry: function() { return /* binding */ simpleJoinRemoteEntry; },\n/* harmony export */   warn: function() { return /* binding */ warn; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\nconst FederationModuleManifest = 'federation-manifest.json';\nconst MANIFEST_EXT = '.json';\nconst BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nconst BROWSER_LOG_VALUE = '1';\nconst NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nconst NameTransformMap = {\n    [NameTransformSymbol.AT]: 'scope_',\n    [NameTransformSymbol.HYPHEN]: '_',\n    [NameTransformSymbol.SLASH]: '__'\n};\nconst EncodedNameTransformMap = {\n    [NameTransformMap[NameTransformSymbol.AT]]: NameTransformSymbol.AT,\n    [NameTransformMap[NameTransformSymbol.HYPHEN]]: NameTransformSymbol.HYPHEN,\n    [NameTransformMap[NameTransformSymbol.SLASH]]: NameTransformSymbol.SLASH\n};\nconst SEPARATOR = ':';\nconst ManifestFileName = 'mf-manifest.json';\nconst StatsFileName = 'mf-stats.json';\nconst MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nconst MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\nconst ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';\nconst TEMP_DIR = '.federation';\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    return typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG);\n}\nconst getProcessEnv = function() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\nconst DEBUG_LOG = '[ FEDERATION DEBUG ]';\nfunction safeGetLocalStorageItem() {\n    try {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n        }\n    } catch (error) {\n        return typeof document !== 'undefined';\n    }\n    return false;\n}\nlet Logger = class Logger {\n    info(msg, info) {\n        if (this.enable) {\n            const argsToString = safeToString(info) || '';\n            if (isBrowserEnv()) {\n                console.info(`%c ${this.identifier}: ${msg} ${argsToString}`, 'color:#3300CC');\n            } else {\n                console.info('\\x1b[34m%s', `${this.identifier}: ${msg} ${argsToString ? `\\n${argsToString}` : ''}`);\n            }\n        }\n    }\n    logOriginalInfo(...args) {\n        if (this.enable) {\n            if (isBrowserEnv()) {\n                console.info(`%c ${this.identifier}: OriginalInfo`, 'color:#3300CC');\n                console.log(...args);\n            } else {\n                console.info(`%c ${this.identifier}: OriginalInfo`, 'color:#3300CC');\n                console.log(...args);\n            }\n        }\n    }\n    constructor(identifier){\n        this.enable = false;\n        this.identifier = identifier || DEBUG_LOG;\n        if (isBrowserEnv() && safeGetLocalStorageItem()) {\n            this.enable = true;\n        } else if (isDebugMode()) {\n            this.enable = true;\n        }\n    }\n};\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nconst parseEntry = (str, devVerOrUrl, separator = SEPARATOR)=>{\n    const strSplit = str.split(separator);\n    const devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    const defaultVersion = '*';\n    const isEntry = (s)=>s.startsWith('http') || s.includes(MANIFEST_EXT);\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        let [name, ...versionOrEntryArr] = strSplit;\n        if (str.startsWith(separator)) {\n            versionOrEntryArr = [\n                devVersionOrUrl || strSplit.slice(-1)[0]\n            ];\n            name = strSplit.slice(0, -1).join(separator);\n        }\n        let versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        const [name] = strSplit;\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw `Invalid entry value: ${str}`;\n    }\n};\nconst logger = new Logger();\nconst composeKeyWithSeparator =  function(...args) {\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce((sum, cur)=>{\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return `${sum}${SEPARATOR}${cur}`;\n    }, '');\n};\nconst encodeName =  function(name, prefix = '', withExt = false) {\n    try {\n        const ext = withExt ? '.js' : '';\n        return `${prefix}${name.replace(new RegExp(`${NameTransformSymbol.AT}`, 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(`${NameTransformSymbol.HYPHEN}`, 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(`${NameTransformSymbol.SLASH}`, 'g'), NameTransformMap[NameTransformSymbol.SLASH])}${ext}`;\n    } catch (err) {\n        throw err;\n    }\n};\nconst decodeName =  function(name, prefix, withExt) {\n    try {\n        let decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(`${NameTransformMap[NameTransformSymbol.AT]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.SLASH]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.HYPHEN]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nconst generateExposeFilename =  (exposeName, withExt)=>{\n    if (!exposeName) {\n        return '';\n    }\n    let expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nconst generateShareFilename =  (pkgName, withExt)=>{\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nconst getResourceUrl = (module, sourceUrl)=>{\n    if ('getPublicPath' in module) {\n        let publicPath;\n        if (!module.getPublicPath.startsWith('function')) {\n            publicPath = new Function(module.getPublicPath)();\n        } else {\n            publicPath = new Function('return ' + module.getPublicPath)()();\n        }\n        return `${publicPath}${sourceUrl}`;\n    } else if ('publicPath' in module) {\n        return `${module.publicPath}${sourceUrl}`;\n    } else {\n        console.warn('Cannot get resource URL. If in debug mode, please ignore.', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst assert = (condition, msg)=>{\n    if (!condition) {\n        error(msg);\n    }\n};\nconst error = (msg)=>{\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n};\nconst warn = (msg)=>{\n    console.warn(`${LOG_CATEGORY}: ${msg}`);\n};\n\nfunction _extends() {\n    _extends = Object.assign || function assign(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\nconst simpleJoinRemoteEntry = (rPath, rName)=>{\n    if (!rPath) {\n        return rName;\n    }\n    const transformPath = (str)=>{\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            const strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    const transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return `${transformedPath}${rName}`;\n    }\n    return `${transformedPath}/${rName}`;\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest, options = {}) {\n    var _manifest_metaData, _manifest_metaData1;\n    const { remotes = {}, overrides = {}, version } = options;\n    let remoteSnapshot;\n    const getPublicPath = ()=>{\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    const overridesKeys = Object.keys(overrides);\n    let remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) == null ? void 0 : _manifest_remotes.reduce((res, next)=>{\n            let matchedVersion;\n            const name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach((key)=>remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        });\n    const { remoteEntry: { path: remoteEntryPath, name: remoteEntryName, type: remoteEntryType }, types: remoteTypes, buildInfo: { buildVersion }, globalName, ssrRemoteEntry } = manifest.metaData;\n    const { exposes } = manifest;\n    let basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion,\n        globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo,\n        shared: manifest == null ? void 0 : manifest.shared.map((item)=>({\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            })),\n        modules: exposes == null ? void 0 : exposes.map((expose)=>({\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            }))\n    };\n    if ((_manifest_metaData = manifest.metaData) == null ? void 0 : _manifest_metaData.prefetchInterface) {\n        const prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) == null ? void 0 : _manifest_metaData1.prefetchEntry) {\n        const { path, name, type } = manifest.metaData.prefetchEntry;\n        basicRemoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            publicPath: getPublicPath()\n        });\n    } else {\n        remoteSnapshot = _extends({}, basicRemoteSnapshot, {\n            getPublicPath: getPublicPath()\n        });\n    }\n    if (ssrRemoteEntry) {\n        const fullSSRRemoteEntry = simpleJoinRemoteEntry(ssrRemoteEntry.path, ssrRemoteEntry.name);\n        remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;\n        remoteSnapshot.ssrRemoteEntryType = 'commonjs-module';\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function safeWrapper(callback, disableWarn) {\n    try {\n        const res = await callback();\n        return res;\n    } catch (e) {\n        !disableWarn && warn(e);\n        return;\n    }\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    const REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    const relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    const relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(info) {\n    // Retrieve the existing script element by its src attribute\n    let script = null;\n    let needAttach = true;\n    let timeout = 20000;\n    let timeoutId;\n    const scripts = document.getElementsByTagName('script');\n    for(let i = 0; i < scripts.length; i++){\n        const s = scripts[i];\n        const scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = info.url;\n        let createScriptRes = undefined;\n        if (info.createScriptHook) {\n            createScriptRes = info.createScriptHook(info.url, info.attrs);\n            if (createScriptRes instanceof HTMLScriptElement) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if ('script' in createScriptRes && createScriptRes.script) {\n                    script = createScriptRes.script;\n                }\n                if ('timeout' in createScriptRes && createScriptRes.timeout) {\n                    timeout = createScriptRes.timeout;\n                }\n            }\n        }\n        const attrs = info.attrs;\n        if (attrs && !createScriptRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (script) {\n                    if (name === 'async' || name === 'defer') {\n                        script[name] = attrs[name];\n                    // Attributes that do not exist are considered overridden\n                    } else if (!script.getAttribute(name)) {\n                        script.setAttribute(name, attrs[name]);\n                    }\n                }\n            });\n        }\n    }\n    const onScriptComplete = (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        var _info_cb;\n        clearTimeout(timeoutId);\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteScript = true } = info;\n                if (needDeleteScript) {\n                    (script == null ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n                }\n            });\n            if (prev) {\n                var _info_cb1;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const res = prev(event);\n                info == null ? void 0 : (_info_cb1 = info.cb) == null ? void 0 : _info_cb1.call(info);\n                return res;\n            }\n        }\n        info == null ? void 0 : (_info_cb = info.cb) == null ? void 0 : _info_cb.call(info);\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(()=>{\n        onScriptComplete(null, new Error(`Remote script \"${info.url}\" time-outed.`));\n    }, timeout);\n    return {\n        script,\n        needAttach\n    };\n}\nfunction createLink(info) {\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    let link = null;\n    let needAttach = true;\n    const links = document.getElementsByTagName('link');\n    for(let i = 0; i < links.length; i++){\n        const l = links[i];\n        const linkHref = l.getAttribute('href');\n        const linkRef = l.getAttribute('ref');\n        if (linkHref && isStaticResourcesEqual(linkHref, info.url) && linkRef === info.attrs['ref']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', info.url);\n        let createLinkRes = undefined;\n        const attrs = info.attrs;\n        if (info.createLinkHook) {\n            createLinkRes = info.createLinkHook(info.url, attrs);\n            if (createLinkRes instanceof HTMLLinkElement) {\n                link = createLinkRes;\n            }\n        }\n        if (attrs && !createLinkRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (link && !link.getAttribute(name)) {\n                    link.setAttribute(name, attrs[name]);\n                }\n            });\n        }\n    }\n    const onLinkComplete = (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteLink = true } = info;\n                if (needDeleteLink) {\n                    (link == null ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n                }\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const res = prev(event);\n                info.cb();\n                return res;\n            }\n        }\n        info.cb();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link,\n        needAttach\n    };\n}\nfunction loadScript(url, info) {\n    const { attrs = {}, createScriptHook } = info;\n    return new Promise((resolve, _reject)=>{\n        const { script, needAttach } = createScript({\n            url,\n            cb: resolve,\n            attrs: _extends({\n                fetchpriority: 'high'\n            }, attrs),\n            createScriptHook,\n            needDeleteScript: true\n        });\n        needAttach && document.head.appendChild(script);\n    });\n}\n\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    const importModule = new Function('name', `return import(name)`);\n    return importModule(name).then((res)=>res).catch((error)=>{\n        console.error(`Error importing module ${name}:`, error);\n        throw error;\n    });\n}\nconst loadNodeFetch = async ()=>{\n    const fetchModule = await importNodeModule('node-fetch');\n    return fetchModule.default || fetchModule;\n};\nconst lazyLoaderHookFetch = async (input, init)=>{\n    // @ts-ignore\n    const loaderHooks = __webpack_require__.federation.instance.loaderHook;\n    const hook = (url, init)=>{\n        return loaderHooks.lifecycle.fetch.emit(url, init);\n    };\n    const res = await hook(input, init || {});\n    if (!res || !(res instanceof Response)) {\n        const fetchFunction = typeof fetch === 'undefined' ? await loadNodeFetch() : fetch;\n        return fetchFunction(input, init || {});\n    }\n    return res;\n};\nfunction createScriptNode(url, cb, attrs, createScriptHook) {\n    if (createScriptHook) {\n        const hookResult = createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    let urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(`Invalid URL: ${e}`));\n        return;\n    }\n    const getFetch = async ()=>{\n        //@ts-ignore\n        if (true) {\n            try {\n                //@ts-ignore\n                const loaderHooks = __webpack_require__.federation.instance.loaderHook;\n                if (loaderHooks.lifecycle.fetch) {\n                    return lazyLoaderHookFetch;\n                }\n            } catch (e) {\n                console.warn('federation.instance.loaderHook.lifecycle.fetch failed:', e);\n            }\n        }\n        return typeof fetch === 'undefined' ? loadNodeFetch() : fetch;\n    };\n    const handleScriptFetch = async (f, urlObj)=>{\n        try {\n            var _vm_constants;\n            const res = await f(urlObj.href);\n            const data = await res.text();\n            const [path, vm] = await Promise.all([\n                importNodeModule('path'),\n                importNodeModule('vm')\n            ]);\n            const scriptContext = {\n                exports: {},\n                module: {\n                    exports: {}\n                }\n            };\n            const urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n            const filename = path.basename(urlObj.pathname);\n            var _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER;\n            const script = new vm.Script(`(function(exports, module, require, __dirname, __filename) {${data}\\n})`, {\n                filename,\n                importModuleDynamically: (_vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER = (_vm_constants = vm.constants) == null ? void 0 : _vm_constants.USE_MAIN_CONTEXT_DEFAULT_LOADER) != null ? _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER : importNodeModule\n            });\n            script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n            const exportedInterface = scriptContext.module.exports || scriptContext.exports;\n            if (attrs && exportedInterface && attrs['globalName']) {\n                const container = exportedInterface[attrs['globalName']] || exportedInterface;\n                cb(undefined, container);\n                return;\n            }\n            cb(undefined, exportedInterface);\n        } catch (e) {\n            cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));\n        }\n    };\n    getFetch().then((f)=>handleScriptFetch(f, urlObj)).catch((err)=>{\n        cb(err);\n    });\n}\nfunction loadScriptNode(url, info) {\n    return new Promise((resolve, reject)=>{\n        createScriptNode(url, (error, scriptContext)=>{\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                const remoteEntryKey = (info == null ? void 0 : (_info_attrs = info.attrs) == null ? void 0 : _info_attrs['globalName']) || `__FEDERATION_${info == null ? void 0 : (_info_attrs1 = info.attrs) == null ? void 0 : _info_attrs1['name']}:custom__`;\n                const entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.createScriptHook);\n    });\n}\n\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return _extends({}, defaultOptions, options);\n        }\n        throw new Error(`Unexpected type for \\`${key}\\`, expect boolean/undefined/object, got: ${typeof options}`);\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3Nkay9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTyxvQkFBb0IsT0FBTyxRQUFRLE9BQU87QUFDaEUsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTyxvQkFBb0IsT0FBTyxPQUFPLE9BQU87QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCLElBQUksS0FBSyxFQUFFLGFBQWE7QUFDM0UsY0FBYztBQUNkLDhDQUE4QyxnQkFBZ0IsSUFBSSxLQUFLLEVBQUUsb0JBQW9CLGFBQWEsT0FBTztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0EsY0FBYztBQUNkLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztB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QUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxFQUFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLDRKQUE0Siw0RkFBNEY7QUFDeFA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsaURBQWlELElBQUksNENBQTRDLGVBQWU7QUFDaEg7QUFDQTs7QUFFeTFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVtb3RlLy4vbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9pbmRleC5lc20uanM/MzliZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSAnZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uJztcbmNvbnN0IE1BTklGRVNUX0VYVCA9ICcuanNvbic7XG5jb25zdCBCUk9XU0VSX0xPR19LRVkgPSAnRkVERVJBVElPTl9ERUJVRyc7XG5jb25zdCBCUk9XU0VSX0xPR19WQUxVRSA9ICcxJztcbmNvbnN0IE5hbWVUcmFuc2Zvcm1TeW1ib2wgPSB7XG4gICAgQVQ6ICdAJyxcbiAgICBIWVBIRU46ICctJyxcbiAgICBTTEFTSDogJy8nXG59O1xuY29uc3QgTmFtZVRyYW5zZm9ybU1hcCA9IHtcbiAgICBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF06ICdzY29wZV8nLFxuICAgIFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl06ICdfJyxcbiAgICBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF06ICdfXydcbn07XG5jb25zdCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcCA9IHtcbiAgICBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXV06IE5hbWVUcmFuc2Zvcm1TeW1ib2wuQVQsXG4gICAgW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dXTogTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU4sXG4gICAgW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF1dOiBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXG59O1xuY29uc3QgU0VQQVJBVE9SID0gJzonO1xuY29uc3QgTWFuaWZlc3RGaWxlTmFtZSA9ICdtZi1tYW5pZmVzdC5qc29uJztcbmNvbnN0IFN0YXRzRmlsZU5hbWUgPSAnbWYtc3RhdHMuanNvbic7XG5jb25zdCBNRk1vZHVsZVR5cGUgPSB7XG4gICAgTlBNOiAnbnBtJyxcbiAgICBBUFA6ICdhcHAnXG59O1xuY29uc3QgTU9EVUxFX0RFVlRPT0xfSURFTlRJRklFUiA9ICdfX01GX0RFVlRPT0xTX01PRFVMRV9JTkZPX18nO1xuY29uc3QgRU5DT0RFX05BTUVfUFJFRklYID0gJ0VOQ09ERV9OQU1FX1BSRUZJWCc7XG5jb25zdCBURU1QX0RJUiA9ICcuZmVkZXJhdGlvbic7XG5cbnZhciBDb250YWluZXJQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBNb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG52YXIgU2hhcmVQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0RlYnVnTW9kZSgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52WydGRURFUkFUSU9OX0RFQlVHJ10pIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgRkVERVJBVElPTl9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgQm9vbGVhbihGRURFUkFUSU9OX0RFQlVHKTtcbn1cbmNvbnN0IGdldFByb2Nlc3NFbnYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ID8gcHJvY2Vzcy5lbnYgOiB7fTtcbn07XG5cbmZ1bmN0aW9uIHNhZmVUb1N0cmluZyhpbmZvKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGluZm8sIG51bGwsIDIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmNvbnN0IERFQlVHX0xPRyA9ICdbIEZFREVSQVRJT04gREVCVUcgXSc7XG5mdW5jdGlvbiBzYWZlR2V0TG9jYWxTdG9yYWdlSXRlbSgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKEJST1dTRVJfTE9HX0tFWSkgPT09IEJST1dTRVJfTE9HX1ZBTFVFO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmxldCBMb2dnZXIgPSBjbGFzcyBMb2dnZXIge1xuICAgIGluZm8obXNnLCBpbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgYXJnc1RvU3RyaW5nID0gc2FmZVRvU3RyaW5nKGluZm8pIHx8ICcnO1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlckVudigpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGAlYyAke3RoaXMuaWRlbnRpZmllcn06ICR7bXNnfSAke2FyZ3NUb1N0cmluZ31gLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ1xceDFiWzM0bSVzJywgYCR7dGhpcy5pZGVudGlmaWVyfTogJHttc2d9ICR7YXJnc1RvU3RyaW5nID8gYFxcbiR7YXJnc1RvU3RyaW5nfWAgOiAnJ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2dPcmlnaW5hbEluZm8oLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5lbmFibGUpIHtcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhgJWMgJHt0aGlzLmlkZW50aWZpZXJ9OiBPcmlnaW5hbEluZm9gLCAnY29sb3I6IzMzMDBDQycpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYCVjICR7dGhpcy5pZGVudGlmaWVyfTogT3JpZ2luYWxJbmZvYCwgJ2NvbG9yOiMzMzAwQ0MnKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpZGVudGlmaWVyKXtcbiAgICAgICAgdGhpcy5lbmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllciB8fCBERUJVR19MT0c7XG4gICAgICAgIGlmIChpc0Jyb3dzZXJFbnYoKSAmJiBzYWZlR2V0TG9jYWxTdG9yYWdlSXRlbSgpKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWJ1Z01vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgTE9HX0NBVEVHT1JZID0gJ1sgRmVkZXJhdGlvbiBSdW50aW1lIF0nO1xuLy8gZW50cnk6IG5hbWU6dmVyc2lvbiAgIHZlcnNpb24gOiAxLjAuMCB8IF4xLjIuM1xuLy8gZW50cnk6IG5hbWU6ZW50cnkgIGVudHJ5OiAgaHR0cHM6Ly9sb2NhbGhvc3Q6OTAwMC9mZWRlcmF0aW9uLW1hbmlmZXN0Lmpzb25cbmNvbnN0IHBhcnNlRW50cnkgPSAoc3RyLCBkZXZWZXJPclVybCwgc2VwYXJhdG9yID0gU0VQQVJBVE9SKT0+e1xuICAgIGNvbnN0IHN0clNwbGl0ID0gc3RyLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgY29uc3QgZGV2VmVyc2lvbk9yVXJsID0gZ2V0UHJvY2Vzc0VudigpWydOT0RFX0VOViddID09PSAnZGV2ZWxvcG1lbnQnICYmIGRldlZlck9yVXJsO1xuICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9uID0gJyonO1xuICAgIGNvbnN0IGlzRW50cnkgPSAocyk9PnMuc3RhcnRzV2l0aCgnaHR0cCcpIHx8IHMuaW5jbHVkZXMoTUFOSUZFU1RfRVhUKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgdHlwZVxuICAgIGlmIChzdHJTcGxpdC5sZW5ndGggPj0gMikge1xuICAgICAgICBsZXQgW25hbWUsIC4uLnZlcnNpb25PckVudHJ5QXJyXSA9IHN0clNwbGl0O1xuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgdmVyc2lvbk9yRW50cnlBcnIgPSBbXG4gICAgICAgICAgICAgICAgZGV2VmVyc2lvbk9yVXJsIHx8IHN0clNwbGl0LnNsaWNlKC0xKVswXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG5hbWUgPSBzdHJTcGxpdC5zbGljZSgwLCAtMSkuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2ZXJzaW9uT3JFbnRyeSA9IGRldlZlcnNpb25PclVybCB8fCB2ZXJzaW9uT3JFbnRyeUFyci5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpc0VudHJ5KHZlcnNpb25PckVudHJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGVudHJ5OiB2ZXJzaW9uT3JFbnRyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IHZlcnNpb24gcnVsZVxuICAgICAgICAgICAgLy8gZGV2VmVyc2lvbk9yVXJsID0+IGlucHV0VmVyc2lvbiA9PiBkZWZhdWx0VmVyc2lvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25PckVudHJ5IHx8IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJTcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgW25hbWVdID0gc3RyU3BsaXQ7XG4gICAgICAgIGlmIChkZXZWZXJzaW9uT3JVcmwgJiYgaXNFbnRyeShkZXZWZXJzaW9uT3JVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZW50cnk6IGRldlZlcnNpb25PclVybFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZlcnNpb246IGRldlZlcnNpb25PclVybCB8fCBkZWZhdWx0VmVyc2lvblxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGBJbnZhbGlkIGVudHJ5IHZhbHVlOiAke3N0cn1gO1xuICAgIH1cbn07XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5jb25zdCBjb21wb3NlS2V5V2l0aFNlcGFyYXRvciA9ICBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBhcmdzLnJlZHVjZSgoc3VtLCBjdXIpPT57XG4gICAgICAgIGlmICghY3VyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VtKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtzdW19JHtTRVBBUkFUT1J9JHtjdXJ9YDtcbiAgICB9LCAnJyk7XG59O1xuY29uc3QgZW5jb2RlTmFtZSA9ICBmdW5jdGlvbihuYW1lLCBwcmVmaXggPSAnJywgd2l0aEV4dCA9IGZhbHNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0ID0gd2l0aEV4dCA/ICcuanMnIDogJyc7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUfWAsICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF0pLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTn1gLCAnZycpLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXSkucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0h9YCwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSl9JHtleHR9YDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVOYW1lID0gIGZ1bmN0aW9uKG5hbWUsIHByZWZpeCwgd2l0aEV4dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBkZWNvZGVkTmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICghZGVjb2RlZE5hbWUuc3RhcnRzV2l0aChwcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAocHJlZml4LCAnZycpLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7TmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXX1gLCAnZycpLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdXSkucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF19YCwgJ2cnKSwgRW5jb2RlZE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXV0pLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXX1gLCAnZycpLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXV0pO1xuICAgICAgICBpZiAod2l0aEV4dCkge1xuICAgICAgICAgICAgZGVjb2RlZE5hbWUgPSBkZWNvZGVkTmFtZS5yZXBsYWNlKCcuanMnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWROYW1lO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcbmNvbnN0IGdlbmVyYXRlRXhwb3NlRmlsZW5hbWUgPSAgKGV4cG9zZU5hbWUsIHdpdGhFeHQpPT57XG4gICAgaWYgKCFleHBvc2VOYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IGV4cG9zZSA9IGV4cG9zZU5hbWU7XG4gICAgaWYgKGV4cG9zZSA9PT0gJy4nKSB7XG4gICAgICAgIGV4cG9zZSA9ICdkZWZhdWx0X2V4cG9ydCc7XG4gICAgfVxuICAgIGlmIChleHBvc2Uuc3RhcnRzV2l0aCgnLi8nKSkge1xuICAgICAgICBleHBvc2UgPSBleHBvc2UucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKGV4cG9zZSwgJ19fZmVkZXJhdGlvbl9leHBvc2VfJywgd2l0aEV4dCk7XG59O1xuY29uc3QgZ2VuZXJhdGVTaGFyZUZpbGVuYW1lID0gIChwa2dOYW1lLCB3aXRoRXh0KT0+e1xuICAgIGlmICghcGtnTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKHBrZ05hbWUsICdfX2ZlZGVyYXRpb25fc2hhcmVkXycsIHdpdGhFeHQpO1xufTtcbmNvbnN0IGdldFJlc291cmNlVXJsID0gKG1vZHVsZSwgc291cmNlVXJsKT0+e1xuICAgIGlmICgnZ2V0UHVibGljUGF0aCcgaW4gbW9kdWxlKSB7XG4gICAgICAgIGxldCBwdWJsaWNQYXRoO1xuICAgICAgICBpZiAoIW1vZHVsZS5nZXRQdWJsaWNQYXRoLnN0YXJ0c1dpdGgoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHB1YmxpY1BhdGggPSBuZXcgRnVuY3Rpb24obW9kdWxlLmdldFB1YmxpY1BhdGgpKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdWJsaWNQYXRoID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIG1vZHVsZS5nZXRQdWJsaWNQYXRoKSgpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3B1YmxpY1BhdGh9JHtzb3VyY2VVcmx9YDtcbiAgICB9IGVsc2UgaWYgKCdwdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIGAke21vZHVsZS5wdWJsaWNQYXRofSR7c291cmNlVXJsfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgZ2V0IHJlc291cmNlIFVSTC4gSWYgaW4gZGVidWcgbW9kZSwgcGxlYXNlIGlnbm9yZS4nLCBtb2R1bGUsIHNvdXJjZVVybCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmNvbnN0IGFzc2VydCA9IChjb25kaXRpb24sIG1zZyk9PntcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBlcnJvcihtc2cpO1xuICAgIH1cbn07XG5jb25zdCBlcnJvciA9IChtc2cpPT57XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke0xPR19DQVRFR09SWX06ICR7bXNnfWApO1xufTtcbmNvbnN0IHdhcm4gPSAobXNnKT0+e1xuICAgIGNvbnNvbGUud2FybihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHNvdXJjZSlpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmNvbnN0IHNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IChyUGF0aCwgck5hbWUpPT57XG4gICAgaWYgKCFyUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVBhdGggPSAoc3RyKT0+e1xuICAgICAgICBpZiAoc3RyID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cldpdGhvdXRTbGFzaCA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChzdHJXaXRob3V0U2xhc2guZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2guc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRTbGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNmb3JtZWRQYXRoID0gdHJhbnNmb3JtUGF0aChyUGF0aCk7XG4gICAgaWYgKCF0cmFuc2Zvcm1lZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJOYW1lO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3RyYW5zZm9ybWVkUGF0aH0ke3JOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHt0cmFuc2Zvcm1lZFBhdGh9LyR7ck5hbWV9YDtcbn07XG5mdW5jdGlvbiBpbmZlckF1dG9QdWJsaWNQYXRoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvIy4qJC8sICcnKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnLycpO1xufVxuLy8gUHJpb3JpdHk6IG92ZXJyaWRlcyA+IHJlbW90ZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG5mdW5jdGlvbiBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhLCBfbWFuaWZlc3RfbWV0YURhdGExO1xuICAgIGNvbnN0IHsgcmVtb3RlcyA9IHt9LCBvdmVycmlkZXMgPSB7fSwgdmVyc2lvbiB9ID0gb3B0aW9ucztcbiAgICBsZXQgcmVtb3RlU25hcHNob3Q7XG4gICAgY29uc3QgZ2V0UHVibGljUGF0aCA9ICgpPT57XG4gICAgICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdC5tZXRhRGF0YS5wdWJsaWNQYXRoID09PSAnYXV0bycgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHB1YmxpY1BhdGggYXV0byBydW50aW1lIG1vZHVsZSBpbXBsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZmVyQXV0b1B1YmxpY1BhdGgodmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5tZXRhRGF0YS5nZXRQdWJsaWNQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvdmVycmlkZXNLZXlzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKTtcbiAgICBsZXQgcmVtb3Rlc0luZm8gPSB7fTtcbiAgICAvLyBJZiByZW1vdGVzIGFyZSBub3QgcHJvdmlkZWQsIG9ubHkgdGhlIHJlbW90ZXMgaW4gdGhlIG1hbmlmZXN0IHdpbGwgYmUgcmVhZFxuICAgIGlmICghT2JqZWN0LmtleXMocmVtb3RlcykubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfbWFuaWZlc3RfcmVtb3RlcztcbiAgICAgICAgcmVtb3Rlc0luZm8gPSAoKF9tYW5pZmVzdF9yZW1vdGVzID0gbWFuaWZlc3QucmVtb3RlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9yZW1vdGVzLnJlZHVjZSgocmVzLCBuZXh0KT0+e1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRWZXJzaW9uO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5leHQuZmVkZXJhdGlvbkNvbnRhaW5lck5hbWU7XG4gICAgICAgICAgICAvLyBvdmVycmlkZXMgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXNLZXlzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgndmVyc2lvbicgaW4gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQuZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwge30pKSB8fCB7fTtcbiAgICB9XG4gICAgLy8gSWYgcmVtb3RlcyAoZGVwbG95IHNjZW5hcmlvKSBhcmUgc3BlY2lmaWVkLCB0aGV5IG5lZWQgdG8gYmUgdHJhdmVyc2VkIGFnYWluXG4gICAgT2JqZWN0LmtleXMocmVtb3RlcykuZm9yRWFjaCgoa2V5KT0+cmVtb3Rlc0luZm9ba2V5XSA9IHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlcyB3aWxsIG92ZXJyaWRlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246IG92ZXJyaWRlc0tleXMuaW5jbHVkZXMoa2V5KSA/IG92ZXJyaWRlc1trZXldIDogcmVtb3Rlc1trZXldXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHsgcmVtb3RlRW50cnk6IHsgcGF0aDogcmVtb3RlRW50cnlQYXRoLCBuYW1lOiByZW1vdGVFbnRyeU5hbWUsIHR5cGU6IHJlbW90ZUVudHJ5VHlwZSB9LCB0eXBlczogcmVtb3RlVHlwZXMsIGJ1aWxkSW5mbzogeyBidWlsZFZlcnNpb24gfSwgZ2xvYmFsTmFtZSwgc3NyUmVtb3RlRW50cnkgfSA9IG1hbmlmZXN0Lm1ldGFEYXRhO1xuICAgIGNvbnN0IHsgZXhwb3NlcyB9ID0gbWFuaWZlc3Q7XG4gICAgbGV0IGJhc2ljUmVtb3RlU25hcHNob3QgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24gPyB2ZXJzaW9uIDogJycsXG4gICAgICAgIGJ1aWxkVmVyc2lvbixcbiAgICAgICAgZ2xvYmFsTmFtZSxcbiAgICAgICAgcmVtb3RlRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVFbnRyeVBhdGgsIHJlbW90ZUVudHJ5TmFtZSksXG4gICAgICAgIHJlbW90ZUVudHJ5VHlwZSxcbiAgICAgICAgcmVtb3RlVHlwZXM6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVUeXBlcy5wYXRoLCByZW1vdGVUeXBlcy5uYW1lKSxcbiAgICAgICAgcmVtb3RlVHlwZXNaaXA6IHJlbW90ZVR5cGVzLnppcCB8fCAnJyxcbiAgICAgICAgcmVtb3RlVHlwZXNBUEk6IHJlbW90ZVR5cGVzLmFwaSB8fCAnJyxcbiAgICAgICAgcmVtb3Rlc0luZm8sXG4gICAgICAgIHNoYXJlZDogbWFuaWZlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IG1hbmlmZXN0LnNoYXJlZC5tYXAoKGl0ZW0pPT4oe1xuICAgICAgICAgICAgICAgIGFzc2V0czogaXRlbS5hc3NldHMsXG4gICAgICAgICAgICAgICAgc2hhcmVkTmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGl0ZW0udmVyc2lvblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBtb2R1bGVzOiBleHBvc2VzID09IG51bGwgPyB2b2lkIDAgOiBleHBvc2VzLm1hcCgoZXhwb3NlKT0+KHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBleHBvc2UubmFtZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVQYXRoOiBleHBvc2UucGF0aCxcbiAgICAgICAgICAgICAgICBhc3NldHM6IGV4cG9zZS5hc3NldHNcbiAgICAgICAgICAgIH0pKVxuICAgIH07XG4gICAgaWYgKChfbWFuaWZlc3RfbWV0YURhdGEgPSBtYW5pZmVzdC5tZXRhRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZSkge1xuICAgICAgICBjb25zdCBwcmVmZXRjaEludGVyZmFjZSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gX2V4dGVuZHMoe30sIGJhc2ljUmVtb3RlU25hcHNob3QsIHtcbiAgICAgICAgICAgIHByZWZldGNoSW50ZXJmYWNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoKF9tYW5pZmVzdF9tZXRhRGF0YTEgPSBtYW5pZmVzdC5tZXRhRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YTEucHJlZmV0Y2hFbnRyeSkge1xuICAgICAgICBjb25zdCB7IHBhdGgsIG5hbWUsIHR5cGUgfSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoRW50cnk7XG4gICAgICAgIGJhc2ljUmVtb3RlU25hcHNob3QgPSBfZXh0ZW5kcyh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCwge1xuICAgICAgICAgICAgcHJlZmV0Y2hFbnRyeTogc2ltcGxlSm9pblJlbW90ZUVudHJ5KHBhdGgsIG5hbWUpLFxuICAgICAgICAgICAgcHJlZmV0Y2hFbnRyeVR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgcmVtb3RlU25hcHNob3QgPSBfZXh0ZW5kcyh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCwge1xuICAgICAgICAgICAgcHVibGljUGF0aDogZ2V0UHVibGljUGF0aCgpXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90ID0gX2V4dGVuZHMoe30sIGJhc2ljUmVtb3RlU25hcHNob3QsIHtcbiAgICAgICAgICAgIGdldFB1YmxpY1BhdGg6IGdldFB1YmxpY1BhdGgoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNzclJlbW90ZUVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGZ1bGxTU1JSZW1vdGVFbnRyeSA9IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShzc3JSZW1vdGVFbnRyeS5wYXRoLCBzc3JSZW1vdGVFbnRyeS5uYW1lKTtcbiAgICAgICAgcmVtb3RlU25hcHNob3Quc3NyUmVtb3RlRW50cnkgPSBmdWxsU1NSUmVtb3RlRW50cnk7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90LnNzclJlbW90ZUVudHJ5VHlwZSA9ICdjb21tb25qcy1tb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlU25hcHNob3Q7XG59XG5mdW5jdGlvbiBpc01hbmlmZXN0UHJvdmlkZXIobW9kdWxlSW5mbykge1xuICAgIGlmICgncmVtb3RlRW50cnknIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mby5yZW1vdGVFbnRyeS5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5hc3luYyBmdW5jdGlvbiBzYWZlV3JhcHBlcihjYWxsYmFjaywgZGlzYWJsZVdhcm4pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgIWRpc2FibGVXYXJuICYmIHdhcm4oZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKHVybDEsIHVybDIpIHtcbiAgICBjb25zdCBSRUdfRVhQID0gL14oaHR0cHM/Oik/XFwvXFwvL2k7XG4gICAgLy8gVHJhbnNmb3JtIHVybDEgYW5kIHVybDIgaW50byByZWxhdGl2ZSBwYXRoc1xuICAgIGNvbnN0IHJlbGF0aXZlVXJsMSA9IHVybDEucmVwbGFjZShSRUdfRVhQLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICBjb25zdCByZWxhdGl2ZVVybDIgPSB1cmwyLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbGF0aXZlIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICByZXR1cm4gcmVsYXRpdmVVcmwxID09PSByZWxhdGl2ZVVybDI7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHQoaW5mbykge1xuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIGxldCBzY3JpcHQgPSBudWxsO1xuICAgIGxldCBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICBsZXQgdGltZW91dCA9IDIwMDAwO1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3Qgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHMgPSBzY3JpcHRzW2ldO1xuICAgICAgICBjb25zdCBzY3JpcHRTcmMgPSBzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIGlmIChzY3JpcHRTcmMgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChzY3JpcHRTcmMsIGluZm8udXJsKSkge1xuICAgICAgICAgICAgc2NyaXB0ID0gcztcbiAgICAgICAgICAgIG5lZWRBdHRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuc3JjID0gaW5mby51cmw7XG4gICAgICAgIGxldCBjcmVhdGVTY3JpcHRSZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpbmZvLmNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgICAgIGNyZWF0ZVNjcmlwdFJlcyA9IGluZm8uY3JlYXRlU2NyaXB0SG9vayhpbmZvLnVybCwgaW5mby5hdHRycyk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlU2NyaXB0UmVzIGluc3RhbmNlb2YgSFRNTFNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjcmVhdGVTY3JpcHRSZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzY3JpcHQnIGluIGNyZWF0ZVNjcmlwdFJlcyAmJiBjcmVhdGVTY3JpcHRSZXMuc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdCA9IGNyZWF0ZVNjcmlwdFJlcy5zY3JpcHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgndGltZW91dCcgaW4gY3JlYXRlU2NyaXB0UmVzICYmIGNyZWF0ZVNjcmlwdFJlcy50aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBjcmVhdGVTY3JpcHRSZXMudGltZW91dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cnMgPSBpbmZvLmF0dHJzO1xuICAgICAgICBpZiAoYXR0cnMgJiYgIWNyZWF0ZVNjcmlwdFJlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKG5hbWUpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2FzeW5jJyB8fCBuYW1lID09PSAnZGVmZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRbbmFtZV0gPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0cmlidXRlcyB0aGF0IGRvIG5vdCBleGlzdCBhcmUgY29uc2lkZXJlZCBvdmVycmlkZGVuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNjcmlwdC5nZXRBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb25TY3JpcHRDb21wbGV0ZSA9IChwcmV2LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGV2ZW50KT0+e1xuICAgICAgICB2YXIgX2luZm9fY2I7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRS5cbiAgICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBzYWZlV3JhcHBlcigoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmVlZERlbGV0ZVNjcmlwdCA9IHRydWUgfSA9IGluZm87XG4gICAgICAgICAgICAgICAgaWYgKG5lZWREZWxldGVTY3JpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKHNjcmlwdCA9PSBudWxsID8gdm9pZCAwIDogc2NyaXB0LnBhcmVudE5vZGUpICYmIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIHZhciBfaW5mb19jYjE7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX2luZm9fY2IxID0gaW5mby5jYikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbmZvX2NiMS5jYWxsKGluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5mbyA9PSBudWxsID8gdm9pZCAwIDogKF9pbmZvX2NiID0gaW5mby5jYikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbmZvX2NiLmNhbGwoaW5mbyk7XG4gICAgfTtcbiAgICBzY3JpcHQub25lcnJvciA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25lcnJvcik7XG4gICAgc2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25sb2FkKTtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgIG9uU2NyaXB0Q29tcGxldGUobnVsbCwgbmV3IEVycm9yKGBSZW1vdGUgc2NyaXB0IFwiJHtpbmZvLnVybH1cIiB0aW1lLW91dGVkLmApKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY3JpcHQsXG4gICAgICAgIG5lZWRBdHRhY2hcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTGluayhpbmZvKSB7XG4gICAgLy8gPGxpbmsgcmVsPVwicHJlbG9hZFwiIGhyZWY9XCJzY3JpcHQuanNcIiBhcz1cInNjcmlwdFwiPlxuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIGxldCBsaW5rID0gbnVsbDtcbiAgICBsZXQgbmVlZEF0dGFjaCA9IHRydWU7XG4gICAgY29uc3QgbGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGwgPSBsaW5rc1tpXTtcbiAgICAgICAgY29uc3QgbGlua0hyZWYgPSBsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICBjb25zdCBsaW5rUmVmID0gbC5nZXRBdHRyaWJ1dGUoJ3JlZicpO1xuICAgICAgICBpZiAobGlua0hyZWYgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChsaW5rSHJlZiwgaW5mby51cmwpICYmIGxpbmtSZWYgPT09IGluZm8uYXR0cnNbJ3JlZiddKSB7XG4gICAgICAgICAgICBsaW5rID0gbDtcbiAgICAgICAgICAgIG5lZWRBdHRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIGluZm8udXJsKTtcbiAgICAgICAgbGV0IGNyZWF0ZUxpbmtSZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gaW5mby5hdHRycztcbiAgICAgICAgaWYgKGluZm8uY3JlYXRlTGlua0hvb2spIHtcbiAgICAgICAgICAgIGNyZWF0ZUxpbmtSZXMgPSBpbmZvLmNyZWF0ZUxpbmtIb29rKGluZm8udXJsLCBhdHRycyk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlTGlua1JlcyBpbnN0YW5jZW9mIEhUTUxMaW5rRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGxpbmsgPSBjcmVhdGVMaW5rUmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyAmJiAhY3JlYXRlTGlua1Jlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goKG5hbWUpPT57XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgJiYgIWxpbmsuZ2V0QXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvbkxpbmtDb21wbGV0ZSA9IChwcmV2LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGV2ZW50KT0+e1xuICAgICAgICAvLyBQcmV2ZW50IG1lbW9yeSBsZWFrcyBpbiBJRS5cbiAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgIGxpbmsub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsaW5rLm9ubG9hZCA9IG51bGw7XG4gICAgICAgICAgICBzYWZlV3JhcHBlcigoKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmVlZERlbGV0ZUxpbmsgPSB0cnVlIH0gPSBpbmZvO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkRGVsZXRlTGluaykge1xuICAgICAgICAgICAgICAgICAgICAobGluayA9PSBudWxsID8gdm9pZCAwIDogbGluay5wYXJlbnROb2RlKSAmJiBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gcHJldihldmVudCk7XG4gICAgICAgICAgICAgICAgaW5mby5jYigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5jYigpO1xuICAgIH07XG4gICAgbGluay5vbmVycm9yID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9uZXJyb3IpO1xuICAgIGxpbmsub25sb2FkID0gb25MaW5rQ29tcGxldGUuYmluZChudWxsLCBsaW5rLm9ubG9hZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluayxcbiAgICAgICAgbmVlZEF0dGFjaFxuICAgIH07XG59XG5mdW5jdGlvbiBsb2FkU2NyaXB0KHVybCwgaW5mbykge1xuICAgIGNvbnN0IHsgYXR0cnMgPSB7fSwgY3JlYXRlU2NyaXB0SG9vayB9ID0gaW5mbztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHsgc2NyaXB0LCBuZWVkQXR0YWNoIH0gPSBjcmVhdGVTY3JpcHQoe1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgY2I6IHJlc29sdmUsXG4gICAgICAgICAgICBhdHRyczogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGZldGNocHJpb3JpdHk6ICdoaWdoJ1xuICAgICAgICAgICAgfSwgYXR0cnMpLFxuICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vayxcbiAgICAgICAgICAgIG5lZWREZWxldGVTY3JpcHQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG5lZWRBdHRhY2ggJiYgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbXBvcnROb2RlTW9kdWxlKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbXBvcnQgc3BlY2lmaWVyIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGltcG9ydE1vZHVsZSA9IG5ldyBGdW5jdGlvbignbmFtZScsIGByZXR1cm4gaW1wb3J0KG5hbWUpYCk7XG4gICAgcmV0dXJuIGltcG9ydE1vZHVsZShuYW1lKS50aGVuKChyZXMpPT5yZXMpLmNhdGNoKChlcnJvcik9PntcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW1wb3J0aW5nIG1vZHVsZSAke25hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5jb25zdCBsb2FkTm9kZUZldGNoID0gYXN5bmMgKCk9PntcbiAgICBjb25zdCBmZXRjaE1vZHVsZSA9IGF3YWl0IGltcG9ydE5vZGVNb2R1bGUoJ25vZGUtZmV0Y2gnKTtcbiAgICByZXR1cm4gZmV0Y2hNb2R1bGUuZGVmYXVsdCB8fCBmZXRjaE1vZHVsZTtcbn07XG5jb25zdCBsYXp5TG9hZGVySG9va0ZldGNoID0gYXN5bmMgKGlucHV0LCBpbml0KT0+e1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBsb2FkZXJIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18uZmVkZXJhdGlvbi5pbnN0YW5jZS5sb2FkZXJIb29rO1xuICAgIGNvbnN0IGhvb2sgPSAodXJsLCBpbml0KT0+e1xuICAgICAgICByZXR1cm4gbG9hZGVySG9va3MubGlmZWN5Y2xlLmZldGNoLmVtaXQodXJsLCBpbml0KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGhvb2soaW5wdXQsIGluaXQgfHwge30pO1xuICAgIGlmICghcmVzIHx8ICEocmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgIGNvbnN0IGZldGNoRnVuY3Rpb24gPSB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnID8gYXdhaXQgbG9hZE5vZGVGZXRjaCgpIDogZmV0Y2g7XG4gICAgICAgIHJldHVybiBmZXRjaEZ1bmN0aW9uKGlucHV0LCBpbml0IHx8IHt9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHROb2RlKHVybCwgY2IsIGF0dHJzLCBjcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgaWYgKGNyZWF0ZVNjcmlwdEhvb2spIHtcbiAgICAgICAgY29uc3QgaG9va1Jlc3VsdCA9IGNyZWF0ZVNjcmlwdEhvb2sodXJsKTtcbiAgICAgICAgaWYgKGhvb2tSZXN1bHQgJiYgdHlwZW9mIGhvb2tSZXN1bHQgPT09ICdvYmplY3QnICYmICd1cmwnIGluIGhvb2tSZXN1bHQpIHtcbiAgICAgICAgICAgIHVybCA9IGhvb2tSZXN1bHQudXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB1cmxPYmo7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29uc3RydWN0aW5nIFVSTDonLCBlKTtcbiAgICAgICAgY2IobmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHtlfWApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnZXRGZXRjaCA9IGFzeW5jICgpPT57XG4gICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICBpZiAodHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlckhvb2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXy5mZWRlcmF0aW9uLmluc3RhbmNlLmxvYWRlckhvb2s7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlckhvb2tzLmxpZmVjeWNsZS5mZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGF6eUxvYWRlckhvb2tGZXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdmZWRlcmF0aW9uLmluc3RhbmNlLmxvYWRlckhvb2subGlmZWN5Y2xlLmZldGNoIGZhaWxlZDonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJyA/IGxvYWROb2RlRmV0Y2goKSA6IGZldGNoO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU2NyaXB0RmV0Y2ggPSBhc3luYyAoZiwgdXJsT2JqKT0+e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF92bV9jb25zdGFudHM7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmKHVybE9iai5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgY29uc3QgW3BhdGgsIHZtXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCdwYXRoJyksXG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgndm0nKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHRDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgIG1vZHVsZToge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cmxEaXJuYW1lID0gdXJsT2JqLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh1cmxPYmoucGF0aG5hbWUpO1xuICAgICAgICAgICAgdmFyIF92bV9jb25zdGFudHNfVVNFX01BSU5fQ09OVEVYVF9ERUZBVUxUX0xPQURFUjtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IG5ldyB2bS5TY3JpcHQoYChmdW5jdGlvbihleHBvcnRzLCBtb2R1bGUsIHJlcXVpcmUsIF9fZGlybmFtZSwgX19maWxlbmFtZSkgeyR7ZGF0YX1cXG59KWAsIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBpbXBvcnRNb2R1bGVEeW5hbWljYWxseTogKF92bV9jb25zdGFudHNfVVNFX01BSU5fQ09OVEVYVF9ERUZBVUxUX0xPQURFUiA9IChfdm1fY29uc3RhbnRzID0gdm0uY29uc3RhbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX3ZtX2NvbnN0YW50cy5VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSKSAhPSBudWxsID8gX3ZtX2NvbnN0YW50c19VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSIDogaW1wb3J0Tm9kZU1vZHVsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY3JpcHQucnVuSW5UaGlzQ29udGV4dCgpKHNjcmlwdENvbnRleHQuZXhwb3J0cywgc2NyaXB0Q29udGV4dC5tb2R1bGUsIGV2YWwoJ3JlcXVpcmUnKSwgdXJsRGlybmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRJbnRlcmZhY2UgPSBzY3JpcHRDb250ZXh0Lm1vZHVsZS5leHBvcnRzIHx8IHNjcmlwdENvbnRleHQuZXhwb3J0cztcbiAgICAgICAgICAgIGlmIChhdHRycyAmJiBleHBvcnRlZEludGVyZmFjZSAmJiBhdHRyc1snZ2xvYmFsTmFtZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZXhwb3J0ZWRJbnRlcmZhY2VbYXR0cnNbJ2dsb2JhbE5hbWUnXV0gfHwgZXhwb3J0ZWRJbnRlcmZhY2U7XG4gICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHVuZGVmaW5lZCwgZXhwb3J0ZWRJbnRlcmZhY2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYihlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKGBTY3JpcHQgZXhlY3V0aW9uIGVycm9yOiAke2V9YCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBnZXRGZXRjaCgpLnRoZW4oKGYpPT5oYW5kbGVTY3JpcHRGZXRjaChmLCB1cmxPYmopKS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBjYihlcnIpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdE5vZGUodXJsLCBpbmZvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNyZWF0ZVNjcmlwdE5vZGUodXJsLCAoZXJyb3IsIHNjcmlwdENvbnRleHQpPT57XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luZm9fYXR0cnMsIF9pbmZvX2F0dHJzMTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeUtleSA9IChpbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnNbJ2dsb2JhbE5hbWUnXSkgfHwgYF9fRkVERVJBVElPTl8ke2luZm8gPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5mb19hdHRyczEgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnMxWyduYW1lJ119OmN1c3RvbV9fYDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeUV4cG9ydHMgPSBnbG9iYWxUaGlzW3JlbW90ZUVudHJ5S2V5XSA9IHNjcmlwdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbmZvLmF0dHJzLCBpbmZvLmNyZWF0ZVNjcmlwdEhvb2spO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGVuYWJsZURlZmF1bHQsIGRlZmF1bHRPcHRpb25zLCBrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgLCBleHBlY3QgYm9vbGVhbi91bmRlZmluZWQvb2JqZWN0LCBnb3Q6ICR7dHlwZW9mIG9wdGlvbnN9YCk7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgQlJPV1NFUl9MT0dfS0VZLCBCUk9XU0VSX0xPR19WQUxVRSwgRU5DT0RFX05BTUVfUFJFRklYLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcCwgRmVkZXJhdGlvbk1vZHVsZU1hbmlmZXN0LCBMb2dnZXIsIE1BTklGRVNUX0VYVCwgTUZNb2R1bGVUeXBlLCBNT0RVTEVfREVWVE9PTF9JREVOVElGSUVSLCBNYW5pZmVzdEZpbGVOYW1lLCBOYW1lVHJhbnNmb3JtTWFwLCBOYW1lVHJhbnNmb3JtU3ltYm9sLCBTRVBBUkFUT1IsIFN0YXRzRmlsZU5hbWUsIFRFTVBfRElSLCBhc3NlcnQsIGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yLCBDb250YWluZXJQbHVnaW4gYXMgY29udGFpbmVyUGx1Z2luLCBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gYXMgY29udGFpbmVyUmVmZXJlbmNlUGx1Z2luLCBjcmVhdGVMaW5rLCBjcmVhdGVTY3JpcHQsIGNyZWF0ZVNjcmlwdE5vZGUsIGRlY29kZU5hbWUsIGVuY29kZU5hbWUsIGVycm9yLCBnZW5lcmF0ZUV4cG9zZUZpbGVuYW1lLCBnZW5lcmF0ZVNoYXJlRmlsZW5hbWUsIGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3QsIGdldFByb2Nlc3NFbnYsIGdldFJlc291cmNlVXJsLCBpbmZlckF1dG9QdWJsaWNQYXRoLCBpc0Jyb3dzZXJFbnYsIGlzRGVidWdNb2RlLCBpc01hbmlmZXN0UHJvdmlkZXIsIGlzU3RhdGljUmVzb3VyY2VzRXF1YWwsIGxvYWRTY3JpcHQsIGxvYWRTY3JpcHROb2RlLCBsb2dnZXIsIE1vZHVsZUZlZGVyYXRpb25QbHVnaW4gYXMgbW9kdWxlRmVkZXJhdGlvblBsdWdpbiwgbm9ybWFsaXplT3B0aW9ucywgcGFyc2VFbnRyeSwgc2FmZVdyYXBwZXIsIFNoYXJlUGx1Z2luIGFzIHNoYXJlUGx1Z2luLCBzaW1wbGVKb2luUmVtb3RlRW50cnksIHdhcm4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/sdk/dist/index.esm.js\n"));

/***/ }),

/***/ "./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar sdk = __webpack_require__(/*! @module-federation/sdk */ \"./node_modules/@module-federation/sdk/dist/index.cjs.js\");\n\nvar FEDERATION_SUPPORTED_TYPES = [\n    'script'\n];\n\nObject.defineProperty(exports, \"ENCODE_NAME_PREFIX\", ({\n\tenumerable: true,\n\tget: function () { return sdk.ENCODE_NAME_PREFIX; }\n}));\nexports.FEDERATION_SUPPORTED_TYPES = FEDERATION_SUPPORTED_TYPES;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvY29uc3RhbnQuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsVUFBVSxtQkFBTyxDQUFDLHVGQUF3Qjs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLHNEQUFxRDtBQUNyRDtBQUNBLG9CQUFvQjtBQUNwQixDQUFDLEVBQUM7QUFDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGUvLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvY29uc3RhbnQuY2pzLmpzPzA0OTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgc2RrID0gcmVxdWlyZSgnQG1vZHVsZS1mZWRlcmF0aW9uL3NkaycpO1xuXG52YXIgRkVERVJBVElPTl9TVVBQT1JURURfVFlQRVMgPSBbXG4gICAgJ3NjcmlwdCdcbl07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRU5DT0RFX05BTUVfUFJFRklYJywge1xuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNkay5FTkNPREVfTkFNRV9QUkVGSVg7IH1cbn0pO1xuZXhwb3J0cy5GRURFUkFUSU9OX1NVUFBPUlRFRF9UWVBFUyA9IEZFREVSQVRJT05fU1VQUE9SVEVEX1RZUEVTO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js\n"));

/***/ }),

/***/ "./node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js ***!
  \***********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar runtime = __webpack_require__(/*! @module-federation/runtime */ \"./node_modules/@module-federation/runtime/dist/index.esm.js\");\nvar constant = __webpack_require__(/*! ./constant.cjs.js */ \"./node_modules/@module-federation/webpack-bundler-runtime/dist/constant.cjs.js\");\nvar sdk = __webpack_require__(/*! @module-federation/sdk */ \"./node_modules/@module-federation/sdk/dist/index.cjs.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar runtime__namespace = /*#__PURE__*/_interopNamespace(runtime);\n\nfunction attachShareScopeMap(webpackRequire) {\n    if (!webpackRequire.S || webpackRequire.federation.hasAttachShareScopeMap || !webpackRequire.federation.instance || !webpackRequire.federation.instance.shareScopeMap) {\n        return;\n    }\n    webpackRequire.S = webpackRequire.federation.instance.shareScopeMap;\n    webpackRequire.federation.hasAttachShareScopeMap = true;\n}\n\nfunction remotes(options) {\n    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, idToExternalAndNameMapping = options.idToExternalAndNameMapping, webpackRequire = options.webpackRequire, idToRemoteMap = options.idToRemoteMap;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach(function(id) {\n            var getScope = webpackRequire.R;\n            if (!getScope) {\n                getScope = [];\n            }\n            var data = idToExternalAndNameMapping[id];\n            var remoteInfos = idToRemoteMap[id];\n            // @ts-ignore seems not work\n            if (getScope.indexOf(data) >= 0) {\n                return;\n            }\n            // @ts-ignore seems not work\n            getScope.push(data);\n            if (data.p) {\n                return promises.push(data.p);\n            }\n            var onError = function(error) {\n                if (!error) {\n                    error = new Error('Container missing');\n                }\n                if (typeof error.message === 'string') {\n                    error.message += '\\nwhile loading \"'.concat(data[1], '\" from ').concat(data[2]);\n                }\n                webpackRequire.m[id] = function() {\n                    throw error;\n                };\n                data.p = 0;\n            };\n            var handleFunction = function(fn, arg1, arg2, d, next, first) {\n                try {\n                    var promise = fn(arg1, arg2);\n                    if (promise && promise.then) {\n                        var p = promise.then(function(result) {\n                            return next(result, d);\n                        }, onError);\n                        if (first) {\n                            promises.push(data.p = p);\n                        } else {\n                            return p;\n                        }\n                    } else {\n                        return next(promise, d, first);\n                    }\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            var onExternal = function(external, _, first) {\n                return external ? handleFunction(webpackRequire.I, data[0], 0, external, onInitialized, first) : onError();\n            };\n            // eslint-disable-next-line no-var\n            var onInitialized = function(_, external, first) {\n                return handleFunction(external.get, data[1], getScope, 0, onFactory, first);\n            };\n            // eslint-disable-next-line no-var\n            var onFactory = function(factory) {\n                data.p = 1;\n                webpackRequire.m[id] = function(module) {\n                    module.exports = factory();\n                };\n            };\n            var onRemoteLoaded = function() {\n                try {\n                    var remoteName = sdk.decodeName(remoteInfos[0].name, sdk.ENCODE_NAME_PREFIX);\n                    var remoteModuleName = remoteName + data[1].slice(1);\n                    return webpackRequire.federation.instance.loadRemote(remoteModuleName, {\n                        loadFactory: false,\n                        from: 'build'\n                    });\n                } catch (error) {\n                    onError(error);\n                }\n            };\n            var useRuntimeLoad = remoteInfos.length === 1 && constant.FEDERATION_SUPPORTED_TYPES.includes(remoteInfos[0].externalType) && remoteInfos[0].name;\n            if (useRuntimeLoad) {\n                handleFunction(onRemoteLoaded, data[2], 0, 0, onFactory, 1);\n            } else {\n                handleFunction(webpackRequire, data[2], 0, 0, onExternal, 1);\n            }\n        });\n    }\n}\n\nfunction consumes(options) {\n    var chunkId = options.chunkId, promises = options.promises, chunkMapping = options.chunkMapping, installedModules = options.installedModules, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;\n    attachShareScopeMap(webpackRequire);\n    if (webpackRequire.o(chunkMapping, chunkId)) {\n        chunkMapping[chunkId].forEach(function(id) {\n            if (webpackRequire.o(installedModules, id)) {\n                return promises.push(installedModules[id]);\n            }\n            var onFactory = function(factory) {\n                installedModules[id] = 0;\n                webpackRequire.m[id] = function(module) {\n                    delete webpackRequire.c[id];\n                    module.exports = factory();\n                };\n            };\n            var onError = function(error) {\n                delete installedModules[id];\n                webpackRequire.m[id] = function(module) {\n                    delete webpackRequire.c[id];\n                    throw error;\n                };\n            };\n            try {\n                var federationInstance = webpackRequire.federation.instance;\n                if (!federationInstance) {\n                    throw new Error('Federation instance not found!');\n                }\n                var _moduleToHandlerMapping_id = moduleToHandlerMapping[id], shareKey = _moduleToHandlerMapping_id.shareKey, getter = _moduleToHandlerMapping_id.getter, shareInfo = _moduleToHandlerMapping_id.shareInfo;\n                var promise = federationInstance.loadShare(shareKey, {\n                    customShareInfo: shareInfo\n                }).then(function(factory) {\n                    if (factory === false) {\n                        return getter();\n                    }\n                    return factory;\n                });\n                if (promise.then) {\n                    promises.push(installedModules[id] = promise.then(onFactory).catch(onError));\n                } else {\n                    // @ts-ignore maintain previous logic\n                    onFactory(promise);\n                }\n            } catch (e) {\n                onError(e);\n            }\n        });\n    }\n}\n\nfunction initializeSharing(param) {\n    var shareScopeName = param.shareScopeName, webpackRequire = param.webpackRequire, initPromises = param.initPromises, initTokens = param.initTokens, initScope = param.initScope;\n    if (!initScope) initScope = [];\n    var mfInstance = webpackRequire.federation.instance;\n    // handling circular init calls\n    var initToken = initTokens[shareScopeName];\n    if (!initToken) initToken = initTokens[shareScopeName] = {\n        from: mfInstance.name\n    };\n    if (initScope.indexOf(initToken) >= 0) return;\n    initScope.push(initToken);\n    var promise = initPromises[shareScopeName];\n    if (promise) return promise;\n    var warn = function(msg) {\n        return typeof console !== 'undefined' && console.warn && console.warn(msg);\n    };\n    var initExternal = function(id) {\n        var handleError = function(err) {\n            return warn('Initialization of sharing external failed: ' + err);\n        };\n        try {\n            var module = webpackRequire(id);\n            if (!module) return;\n            var initFn = function(module) {\n                return module && module.init && // @ts-ignore compat legacy mf shared behavior\n                module.init(webpackRequire.S[shareScopeName], initScope);\n            };\n            if (module.then) return promises.push(module.then(initFn, handleError));\n            var initResult = initFn(module);\n            // @ts-ignore\n            if (initResult && typeof initResult !== 'boolean' && initResult.then) // @ts-ignore\n            return promises.push(initResult['catch'](handleError));\n        } catch (err) {\n            handleError(err);\n        }\n    };\n    var promises = mfInstance.initializeSharing(shareScopeName, {\n        strategy: mfInstance.options.shareStrategy,\n        initScope: initScope,\n        from: 'build'\n    });\n    attachShareScopeMap(webpackRequire);\n    var bundlerRuntimeRemotesOptions = webpackRequire.federation.bundlerRuntimeOptions.remotes;\n    if (bundlerRuntimeRemotesOptions) {\n        Object.keys(bundlerRuntimeRemotesOptions.idToRemoteMap).forEach(function(moduleId) {\n            var info = bundlerRuntimeRemotesOptions.idToRemoteMap[moduleId];\n            var externalModuleId = bundlerRuntimeRemotesOptions.idToExternalAndNameMapping[moduleId][2];\n            if (info.length > 1) {\n                initExternal(externalModuleId);\n            } else if (info.length === 1) {\n                var remoteInfo = info[0];\n                if (!constant.FEDERATION_SUPPORTED_TYPES.includes(remoteInfo.externalType)) {\n                    initExternal(externalModuleId);\n                }\n            }\n        });\n    }\n    if (!promises.length) {\n        return initPromises[shareScopeName] = true;\n    }\n    return initPromises[shareScopeName] = Promise.all(promises).then(function() {\n        return initPromises[shareScopeName] = true;\n    });\n}\n\nfunction handleInitialConsumes(options) {\n    var moduleId = options.moduleId, moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire;\n    var federationInstance = webpackRequire.federation.instance;\n    if (!federationInstance) {\n        throw new Error('Federation instance not found!');\n    }\n    var _moduleToHandlerMapping_moduleId = moduleToHandlerMapping[moduleId], shareKey = _moduleToHandlerMapping_moduleId.shareKey, shareInfo = _moduleToHandlerMapping_moduleId.shareInfo;\n    try {\n        return federationInstance.loadShareSync(shareKey, {\n            customShareInfo: shareInfo\n        });\n    } catch (err) {\n        console.error('loadShareSync failed! The function should not be called unless you set \"eager:true\". If you do not set it, and encounter this issue, you can check whether an async boundary is implemented.');\n        console.error('The original error message is as follows: ');\n        throw err;\n    }\n}\nfunction installInitialConsumes(options) {\n    var moduleToHandlerMapping = options.moduleToHandlerMapping, webpackRequire = options.webpackRequire, installedModules = options.installedModules, initialConsumes = options.initialConsumes;\n    initialConsumes.forEach(function(id) {\n        webpackRequire.m[id] = function(module) {\n            // Handle scenario when module is used synchronously\n            installedModules[id] = 0;\n            delete webpackRequire.c[id];\n            var factory = handleInitialConsumes({\n                moduleId: id,\n                moduleToHandlerMapping: moduleToHandlerMapping,\n                webpackRequire: webpackRequire\n            });\n            if (typeof factory !== 'function') {\n                throw new Error(\"Shared module is not available for eager consumption: \".concat(id));\n            }\n            module.exports = factory();\n        };\n    });\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction initContainerEntry(options) {\n    var webpackRequire = options.webpackRequire, shareScope = options.shareScope, initScope = options.initScope, shareScopeKey = options.shareScopeKey, remoteEntryInitOptions = options.remoteEntryInitOptions;\n    if (!webpackRequire.S) return;\n    if (!webpackRequire.federation || !webpackRequire.federation.instance || !webpackRequire.federation.initOptions) return;\n    var federationInstance = webpackRequire.federation.instance;\n    var name = shareScopeKey || 'default';\n    federationInstance.initOptions(_object_spread({\n        name: webpackRequire.federation.initOptions.name,\n        remotes: []\n    }, remoteEntryInitOptions));\n    federationInstance.initShareScopeMap(name, shareScope, {\n        hostShareScopeMap: (remoteEntryInitOptions === null || remoteEntryInitOptions === void 0 ? void 0 : remoteEntryInitOptions.shareScopeMap) || {}\n    });\n    if (webpackRequire.federation.attachShareScopeMap) {\n        webpackRequire.federation.attachShareScopeMap(webpackRequire);\n    }\n    // @ts-ignore\n    return webpackRequire.I(name, initScope);\n}\n\nvar federation = {\n    runtime: runtime__namespace,\n    instance: undefined,\n    initOptions: undefined,\n    bundlerRuntime: {\n        remotes: remotes,\n        consumes: consumes,\n        I: initializeSharing,\n        S: {},\n        installInitialConsumes: installInitialConsumes,\n        initContainerEntry: initContainerEntry\n    },\n    attachShareScopeMap: attachShareScopeMap,\n    bundlerRuntimeOptions: {}\n};\n\nmodule.exports = federation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL3dlYnBhY2stYnVuZGxlci1ydW50aW1lL2Rpc3QvaW5kZXguY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQywrRkFBNEI7QUFDbEQsZUFBZSxtQkFBTyxDQUFDLHlHQUFtQjtBQUMxQyxVQUFVLG1CQUFPLENBQUMsdUZBQXdCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlbW90ZS8uL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vd2VicGFjay1idW5kbGVyLXJ1bnRpbWUvZGlzdC9pbmRleC5janMuanM/NzA1YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBydW50aW1lID0gcmVxdWlyZSgnQG1vZHVsZS1mZWRlcmF0aW9uL3J1bnRpbWUnKTtcbnZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQuY2pzLmpzJyk7XG52YXIgc2RrID0gcmVxdWlyZSgnQG1vZHVsZS1mZWRlcmF0aW9uL3NkaycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgcnVudGltZV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlKHJ1bnRpbWUpO1xuXG5mdW5jdGlvbiBhdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKSB7XG4gICAgaWYgKCF3ZWJwYWNrUmVxdWlyZS5TIHx8IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaGFzQXR0YWNoU2hhcmVTY29wZU1hcCB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZSB8fCAhd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZS5zaGFyZVNjb3BlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2VicGFja1JlcXVpcmUuUyA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2Uuc2hhcmVTY29wZU1hcDtcbiAgICB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmhhc0F0dGFjaFNoYXJlU2NvcGVNYXAgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW1vdGVzKG9wdGlvbnMpIHtcbiAgICB2YXIgY2h1bmtJZCA9IG9wdGlvbnMuY2h1bmtJZCwgcHJvbWlzZXMgPSBvcHRpb25zLnByb21pc2VzLCBjaHVua01hcHBpbmcgPSBvcHRpb25zLmNodW5rTWFwcGluZywgaWRUb0V4dGVybmFsQW5kTmFtZU1hcHBpbmcgPSBvcHRpb25zLmlkVG9FeHRlcm5hbEFuZE5hbWVNYXBwaW5nLCB3ZWJwYWNrUmVxdWlyZSA9IG9wdGlvbnMud2VicGFja1JlcXVpcmUsIGlkVG9SZW1vdGVNYXAgPSBvcHRpb25zLmlkVG9SZW1vdGVNYXA7XG4gICAgYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgaWYgKHdlYnBhY2tSZXF1aXJlLm8oY2h1bmtNYXBwaW5nLCBjaHVua0lkKSkge1xuICAgICAgICBjaHVua01hcHBpbmdbY2h1bmtJZF0uZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIGdldFNjb3BlID0gd2VicGFja1JlcXVpcmUuUjtcbiAgICAgICAgICAgIGlmICghZ2V0U2NvcGUpIHtcbiAgICAgICAgICAgICAgICBnZXRTY29wZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSBpZFRvRXh0ZXJuYWxBbmROYW1lTWFwcGluZ1tpZF07XG4gICAgICAgICAgICB2YXIgcmVtb3RlSW5mb3MgPSBpZFRvUmVtb3RlTWFwW2lkXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc2VlbXMgbm90IHdvcmtcbiAgICAgICAgICAgIGlmIChnZXRTY29wZS5pbmRleE9mKGRhdGEpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHNlZW1zIG5vdCB3b3JrXG4gICAgICAgICAgICBnZXRTY29wZS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEucCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlcy5wdXNoKGRhdGEucCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQ29udGFpbmVyIG1pc3NpbmcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9ICdcXG53aGlsZSBsb2FkaW5nIFwiJy5jb25jYXQoZGF0YVsxXSwgJ1wiIGZyb20gJykuY29uY2F0KGRhdGFbMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRhdGEucCA9IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGhhbmRsZUZ1bmN0aW9uID0gZnVuY3Rpb24oZm4sIGFyZzEsIGFyZzIsIGQsIG5leHQsIGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmbihhcmcxLCBhcmcyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UgJiYgcHJvbWlzZS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChyZXN1bHQsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGRhdGEucCA9IHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KHByb21pc2UsIGQsIGZpcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25FeHRlcm5hbCA9IGZ1bmN0aW9uKGV4dGVybmFsLCBfLCBmaXJzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHRlcm5hbCA/IGhhbmRsZUZ1bmN0aW9uKHdlYnBhY2tSZXF1aXJlLkksIGRhdGFbMF0sIDAsIGV4dGVybmFsLCBvbkluaXRpYWxpemVkLCBmaXJzdCkgOiBvbkVycm9yKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICAgICAgICAgICAgdmFyIG9uSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbihfLCBleHRlcm5hbCwgZmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlRnVuY3Rpb24oZXh0ZXJuYWwuZ2V0LCBkYXRhWzFdLCBnZXRTY29wZSwgMCwgb25GYWN0b3J5LCBmaXJzdCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxuICAgICAgICAgICAgdmFyIG9uRmFjdG9yeSA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnAgPSAxO1xuICAgICAgICAgICAgICAgIHdlYnBhY2tSZXF1aXJlLm1baWRdID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uUmVtb3RlTG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZU5hbWUgPSBzZGsuZGVjb2RlTmFtZShyZW1vdGVJbmZvc1swXS5uYW1lLCBzZGsuRU5DT0RFX05BTUVfUFJFRklYKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW90ZU1vZHVsZU5hbWUgPSByZW1vdGVOYW1lICsgZGF0YVsxXS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2UubG9hZFJlbW90ZShyZW1vdGVNb2R1bGVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkRmFjdG9yeTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAnYnVpbGQnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdXNlUnVudGltZUxvYWQgPSByZW1vdGVJbmZvcy5sZW5ndGggPT09IDEgJiYgY29uc3RhbnQuRkVERVJBVElPTl9TVVBQT1JURURfVFlQRVMuaW5jbHVkZXMocmVtb3RlSW5mb3NbMF0uZXh0ZXJuYWxUeXBlKSAmJiByZW1vdGVJbmZvc1swXS5uYW1lO1xuICAgICAgICAgICAgaWYgKHVzZVJ1bnRpbWVMb2FkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRnVuY3Rpb24ob25SZW1vdGVMb2FkZWQsIGRhdGFbMl0sIDAsIDAsIG9uRmFjdG9yeSwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZUZ1bmN0aW9uKHdlYnBhY2tSZXF1aXJlLCBkYXRhWzJdLCAwLCAwLCBvbkV4dGVybmFsLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb25zdW1lcyhvcHRpb25zKSB7XG4gICAgdmFyIGNodW5rSWQgPSBvcHRpb25zLmNodW5rSWQsIHByb21pc2VzID0gb3B0aW9ucy5wcm9taXNlcywgY2h1bmtNYXBwaW5nID0gb3B0aW9ucy5jaHVua01hcHBpbmcsIGluc3RhbGxlZE1vZHVsZXMgPSBvcHRpb25zLmluc3RhbGxlZE1vZHVsZXMsIG1vZHVsZVRvSGFuZGxlck1hcHBpbmcgPSBvcHRpb25zLm1vZHVsZVRvSGFuZGxlck1hcHBpbmcsIHdlYnBhY2tSZXF1aXJlID0gb3B0aW9ucy53ZWJwYWNrUmVxdWlyZTtcbiAgICBhdHRhY2hTaGFyZVNjb3BlTWFwKHdlYnBhY2tSZXF1aXJlKTtcbiAgICBpZiAod2VicGFja1JlcXVpcmUubyhjaHVua01hcHBpbmcsIGNodW5rSWQpKSB7XG4gICAgICAgIGNodW5rTWFwcGluZ1tjaHVua0lkXS5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBpZiAod2VicGFja1JlcXVpcmUubyhpbnN0YWxsZWRNb2R1bGVzLCBpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMucHVzaChpbnN0YWxsZWRNb2R1bGVzW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25GYWN0b3J5ID0gZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIGluc3RhbGxlZE1vZHVsZXNbaWRdID0gMDtcbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2VicGFja1JlcXVpcmUuY1tpZF07XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnN0YWxsZWRNb2R1bGVzW2lkXTtcbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZS5tW2lkXSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2VicGFja1JlcXVpcmUuY1tpZF07XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZmVkZXJhdGlvbkluc3RhbmNlID0gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoIWZlZGVyYXRpb25JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZGVyYXRpb24gaW5zdGFuY2Ugbm90IGZvdW5kIScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfaWQgPSBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nW2lkXSwgc2hhcmVLZXkgPSBfbW9kdWxlVG9IYW5kbGVyTWFwcGluZ19pZC5zaGFyZUtleSwgZ2V0dGVyID0gX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfaWQuZ2V0dGVyLCBzaGFyZUluZm8gPSBfbW9kdWxlVG9IYW5kbGVyTWFwcGluZ19pZC5zaGFyZUluZm87XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmZWRlcmF0aW9uSW5zdGFuY2UubG9hZFNoYXJlKHNoYXJlS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbVNoYXJlSW5mbzogc2hhcmVJbmZvXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWN0b3J5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChpbnN0YWxsZWRNb2R1bGVzW2lkXSA9IHByb21pc2UudGhlbihvbkZhY3RvcnkpLmNhdGNoKG9uRXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIG1haW50YWluIHByZXZpb3VzIGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgIG9uRmFjdG9yeShwcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplU2hhcmluZyhwYXJhbSkge1xuICAgIHZhciBzaGFyZVNjb3BlTmFtZSA9IHBhcmFtLnNoYXJlU2NvcGVOYW1lLCB3ZWJwYWNrUmVxdWlyZSA9IHBhcmFtLndlYnBhY2tSZXF1aXJlLCBpbml0UHJvbWlzZXMgPSBwYXJhbS5pbml0UHJvbWlzZXMsIGluaXRUb2tlbnMgPSBwYXJhbS5pbml0VG9rZW5zLCBpbml0U2NvcGUgPSBwYXJhbS5pbml0U2NvcGU7XG4gICAgaWYgKCFpbml0U2NvcGUpIGluaXRTY29wZSA9IFtdO1xuICAgIHZhciBtZkluc3RhbmNlID0gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZTtcbiAgICAvLyBoYW5kbGluZyBjaXJjdWxhciBpbml0IGNhbGxzXG4gICAgdmFyIGluaXRUb2tlbiA9IGluaXRUb2tlbnNbc2hhcmVTY29wZU5hbWVdO1xuICAgIGlmICghaW5pdFRva2VuKSBpbml0VG9rZW4gPSBpbml0VG9rZW5zW3NoYXJlU2NvcGVOYW1lXSA9IHtcbiAgICAgICAgZnJvbTogbWZJbnN0YW5jZS5uYW1lXG4gICAgfTtcbiAgICBpZiAoaW5pdFNjb3BlLmluZGV4T2YoaW5pdFRva2VuKSA+PSAwKSByZXR1cm47XG4gICAgaW5pdFNjb3BlLnB1c2goaW5pdFRva2VuKTtcbiAgICB2YXIgcHJvbWlzZSA9IGluaXRQcm9taXNlc1tzaGFyZVNjb3BlTmFtZV07XG4gICAgaWYgKHByb21pc2UpIHJldHVybiBwcm9taXNlO1xuICAgIHZhciB3YXJuID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIH07XG4gICAgdmFyIGluaXRFeHRlcm5hbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBoYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHdhcm4oJ0luaXRpYWxpemF0aW9uIG9mIHNoYXJpbmcgZXh0ZXJuYWwgZmFpbGVkOiAnICsgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtb2R1bGUgPSB3ZWJwYWNrUmVxdWlyZShpZCk7XG4gICAgICAgICAgICBpZiAoIW1vZHVsZSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluaXRGbiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUgJiYgbW9kdWxlLmluaXQgJiYgLy8gQHRzLWlnbm9yZSBjb21wYXQgbGVnYWN5IG1mIHNoYXJlZCBiZWhhdmlvclxuICAgICAgICAgICAgICAgIG1vZHVsZS5pbml0KHdlYnBhY2tSZXF1aXJlLlNbc2hhcmVTY29wZU5hbWVdLCBpbml0U2NvcGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtb2R1bGUudGhlbikgcmV0dXJuIHByb21pc2VzLnB1c2gobW9kdWxlLnRoZW4oaW5pdEZuLCBoYW5kbGVFcnJvcikpO1xuICAgICAgICAgICAgdmFyIGluaXRSZXN1bHQgPSBpbml0Rm4obW9kdWxlKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmIChpbml0UmVzdWx0ICYmIHR5cGVvZiBpbml0UmVzdWx0ICE9PSAnYm9vbGVhbicgJiYgaW5pdFJlc3VsdC50aGVuKSAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXMucHVzaChpbml0UmVzdWx0WydjYXRjaCddKGhhbmRsZUVycm9yKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHByb21pc2VzID0gbWZJbnN0YW5jZS5pbml0aWFsaXplU2hhcmluZyhzaGFyZVNjb3BlTmFtZSwge1xuICAgICAgICBzdHJhdGVneTogbWZJbnN0YW5jZS5vcHRpb25zLnNoYXJlU3RyYXRlZ3ksXG4gICAgICAgIGluaXRTY29wZTogaW5pdFNjb3BlLFxuICAgICAgICBmcm9tOiAnYnVpbGQnXG4gICAgfSk7XG4gICAgYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgdmFyIGJ1bmRsZXJSdW50aW1lUmVtb3Rlc09wdGlvbnMgPSB3ZWJwYWNrUmVxdWlyZS5mZWRlcmF0aW9uLmJ1bmRsZXJSdW50aW1lT3B0aW9ucy5yZW1vdGVzO1xuICAgIGlmIChidW5kbGVyUnVudGltZVJlbW90ZXNPcHRpb25zKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGJ1bmRsZXJSdW50aW1lUmVtb3Rlc09wdGlvbnMuaWRUb1JlbW90ZU1hcCkuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVJZCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBidW5kbGVyUnVudGltZVJlbW90ZXNPcHRpb25zLmlkVG9SZW1vdGVNYXBbbW9kdWxlSWRdO1xuICAgICAgICAgICAgdmFyIGV4dGVybmFsTW9kdWxlSWQgPSBidW5kbGVyUnVudGltZVJlbW90ZXNPcHRpb25zLmlkVG9FeHRlcm5hbEFuZE5hbWVNYXBwaW5nW21vZHVsZUlkXVsyXTtcbiAgICAgICAgICAgIGlmIChpbmZvLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpbml0RXh0ZXJuYWwoZXh0ZXJuYWxNb2R1bGVJZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZm8ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW90ZUluZm8gPSBpbmZvWzBdO1xuICAgICAgICAgICAgICAgIGlmICghY29uc3RhbnQuRkVERVJBVElPTl9TVVBQT1JURURfVFlQRVMuaW5jbHVkZXMocmVtb3RlSW5mby5leHRlcm5hbFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRFeHRlcm5hbChleHRlcm5hbE1vZHVsZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXByb21pc2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW5pdFByb21pc2VzW3NoYXJlU2NvcGVOYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpbml0UHJvbWlzZXNbc2hhcmVTY29wZU5hbWVdID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpbml0UHJvbWlzZXNbc2hhcmVTY29wZU5hbWVdID0gdHJ1ZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlSW5pdGlhbENvbnN1bWVzKG9wdGlvbnMpIHtcbiAgICB2YXIgbW9kdWxlSWQgPSBvcHRpb25zLm1vZHVsZUlkLCBtb2R1bGVUb0hhbmRsZXJNYXBwaW5nID0gb3B0aW9ucy5tb2R1bGVUb0hhbmRsZXJNYXBwaW5nLCB3ZWJwYWNrUmVxdWlyZSA9IG9wdGlvbnMud2VicGFja1JlcXVpcmU7XG4gICAgdmFyIGZlZGVyYXRpb25JbnN0YW5jZSA9IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2U7XG4gICAgaWYgKCFmZWRlcmF0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGZWRlcmF0aW9uIGluc3RhbmNlIG5vdCBmb3VuZCEnKTtcbiAgICB9XG4gICAgdmFyIF9tb2R1bGVUb0hhbmRsZXJNYXBwaW5nX21vZHVsZUlkID0gbW9kdWxlVG9IYW5kbGVyTWFwcGluZ1ttb2R1bGVJZF0sIHNoYXJlS2V5ID0gX21vZHVsZVRvSGFuZGxlck1hcHBpbmdfbW9kdWxlSWQuc2hhcmVLZXksIHNoYXJlSW5mbyA9IF9tb2R1bGVUb0hhbmRsZXJNYXBwaW5nX21vZHVsZUlkLnNoYXJlSW5mbztcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZmVkZXJhdGlvbkluc3RhbmNlLmxvYWRTaGFyZVN5bmMoc2hhcmVLZXksIHtcbiAgICAgICAgICAgIGN1c3RvbVNoYXJlSW5mbzogc2hhcmVJbmZvXG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdsb2FkU2hhcmVTeW5jIGZhaWxlZCEgVGhlIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIHVubGVzcyB5b3Ugc2V0IFwiZWFnZXI6dHJ1ZVwiLiBJZiB5b3UgZG8gbm90IHNldCBpdCwgYW5kIGVuY291bnRlciB0aGlzIGlzc3VlLCB5b3UgY2FuIGNoZWNrIHdoZXRoZXIgYW4gYXN5bmMgYm91bmRhcnkgaXMgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGlzIGFzIGZvbGxvd3M6ICcpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zdGFsbEluaXRpYWxDb25zdW1lcyhvcHRpb25zKSB7XG4gICAgdmFyIG1vZHVsZVRvSGFuZGxlck1hcHBpbmcgPSBvcHRpb25zLm1vZHVsZVRvSGFuZGxlck1hcHBpbmcsIHdlYnBhY2tSZXF1aXJlID0gb3B0aW9ucy53ZWJwYWNrUmVxdWlyZSwgaW5zdGFsbGVkTW9kdWxlcyA9IG9wdGlvbnMuaW5zdGFsbGVkTW9kdWxlcywgaW5pdGlhbENvbnN1bWVzID0gb3B0aW9ucy5pbml0aWFsQ29uc3VtZXM7XG4gICAgaW5pdGlhbENvbnN1bWVzLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgd2VicGFja1JlcXVpcmUubVtpZF0gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzY2VuYXJpbyB3aGVuIG1vZHVsZSBpcyB1c2VkIHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgIGluc3RhbGxlZE1vZHVsZXNbaWRdID0gMDtcbiAgICAgICAgICAgIGRlbGV0ZSB3ZWJwYWNrUmVxdWlyZS5jW2lkXTtcbiAgICAgICAgICAgIHZhciBmYWN0b3J5ID0gaGFuZGxlSW5pdGlhbENvbnN1bWVzKHtcbiAgICAgICAgICAgICAgICBtb2R1bGVJZDogaWQsXG4gICAgICAgICAgICAgICAgbW9kdWxlVG9IYW5kbGVyTWFwcGluZzogbW9kdWxlVG9IYW5kbGVyTWFwcGluZyxcbiAgICAgICAgICAgICAgICB3ZWJwYWNrUmVxdWlyZTogd2VicGFja1JlcXVpcmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcmVkIG1vZHVsZSBpcyBub3QgYXZhaWxhYmxlIGZvciBlYWdlciBjb25zdW1wdGlvbjogXCIuY29uY2F0KGlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gX29iamVjdF9zcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gaW5pdENvbnRhaW5lckVudHJ5KG9wdGlvbnMpIHtcbiAgICB2YXIgd2VicGFja1JlcXVpcmUgPSBvcHRpb25zLndlYnBhY2tSZXF1aXJlLCBzaGFyZVNjb3BlID0gb3B0aW9ucy5zaGFyZVNjb3BlLCBpbml0U2NvcGUgPSBvcHRpb25zLmluaXRTY29wZSwgc2hhcmVTY29wZUtleSA9IG9wdGlvbnMuc2hhcmVTY29wZUtleSwgcmVtb3RlRW50cnlJbml0T3B0aW9ucyA9IG9wdGlvbnMucmVtb3RlRW50cnlJbml0T3B0aW9ucztcbiAgICBpZiAoIXdlYnBhY2tSZXF1aXJlLlMpIHJldHVybjtcbiAgICBpZiAoIXdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24gfHwgIXdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5zdGFuY2UgfHwgIXdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMpIHJldHVybjtcbiAgICB2YXIgZmVkZXJhdGlvbkluc3RhbmNlID0gd2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5pbnN0YW5jZTtcbiAgICB2YXIgbmFtZSA9IHNoYXJlU2NvcGVLZXkgfHwgJ2RlZmF1bHQnO1xuICAgIGZlZGVyYXRpb25JbnN0YW5jZS5pbml0T3B0aW9ucyhfb2JqZWN0X3NwcmVhZCh7XG4gICAgICAgIG5hbWU6IHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uaW5pdE9wdGlvbnMubmFtZSxcbiAgICAgICAgcmVtb3RlczogW11cbiAgICB9LCByZW1vdGVFbnRyeUluaXRPcHRpb25zKSk7XG4gICAgZmVkZXJhdGlvbkluc3RhbmNlLmluaXRTaGFyZVNjb3BlTWFwKG5hbWUsIHNoYXJlU2NvcGUsIHtcbiAgICAgICAgaG9zdFNoYXJlU2NvcGVNYXA6IChyZW1vdGVFbnRyeUluaXRPcHRpb25zID09PSBudWxsIHx8IHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbW90ZUVudHJ5SW5pdE9wdGlvbnMuc2hhcmVTY29wZU1hcCkgfHwge31cbiAgICB9KTtcbiAgICBpZiAod2VicGFja1JlcXVpcmUuZmVkZXJhdGlvbi5hdHRhY2hTaGFyZVNjb3BlTWFwKSB7XG4gICAgICAgIHdlYnBhY2tSZXF1aXJlLmZlZGVyYXRpb24uYXR0YWNoU2hhcmVTY29wZU1hcCh3ZWJwYWNrUmVxdWlyZSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gd2VicGFja1JlcXVpcmUuSShuYW1lLCBpbml0U2NvcGUpO1xufVxuXG52YXIgZmVkZXJhdGlvbiA9IHtcbiAgICBydW50aW1lOiBydW50aW1lX19uYW1lc3BhY2UsXG4gICAgaW5zdGFuY2U6IHVuZGVmaW5lZCxcbiAgICBpbml0T3B0aW9uczogdW5kZWZpbmVkLFxuICAgIGJ1bmRsZXJSdW50aW1lOiB7XG4gICAgICAgIHJlbW90ZXM6IHJlbW90ZXMsXG4gICAgICAgIGNvbnN1bWVzOiBjb25zdW1lcyxcbiAgICAgICAgSTogaW5pdGlhbGl6ZVNoYXJpbmcsXG4gICAgICAgIFM6IHt9LFxuICAgICAgICBpbnN0YWxsSW5pdGlhbENvbnN1bWVzOiBpbnN0YWxsSW5pdGlhbENvbnN1bWVzLFxuICAgICAgICBpbml0Q29udGFpbmVyRW50cnk6IGluaXRDb250YWluZXJFbnRyeVxuICAgIH0sXG4gICAgYXR0YWNoU2hhcmVTY29wZU1hcDogYXR0YWNoU2hhcmVTY29wZU1hcCxcbiAgICBidW5kbGVyUnVudGltZU9wdGlvbnM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZlZGVyYXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/webpack-bundler-runtime/dist/index.cjs.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsd0ZBQTRCOztBQUV6UCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlbW90ZS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGUvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz8xYjFkIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "webpack/container/entry/remote":
/*!***********************!*\
  !*** container entry ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
var moduleMap = {
	"./noop": function() {
		return __webpack_require__.e(/*! __federation_expose_noop */ "__federation_expose_noop").then(function() { return function() { return (__webpack_require__(/*! ./node_modules/@module-federation/nextjs-mf/dist/src/federation-noop.js */ "./node_modules/@module-federation/nextjs-mf/dist/src/federation-noop.js")); }; });
	},
	"./react": function() {
		return __webpack_require__.e(/*! __federation_expose_react */ "__federation_expose_react").then(function() { return function() { return (__webpack_require__(/*! ./node_modules/react/index.js */ "./node_modules/react/index.js")); }; });
	},
	"./react-dom": function() {
		return __webpack_require__.e(/*! __federation_expose_react_dom */ "__federation_expose_react_dom").then(function() { return function() { return (__webpack_require__(/*! ./node_modules/react-dom/index.js */ "./node_modules/react-dom/index.js")); }; });
	},
	"./next/router": function() {
		return __webpack_require__.e(/*! __federation_expose_next__router */ "__federation_expose_next__router").then(function() { return function() { return (__webpack_require__(/*! ./node_modules/next/router.js */ "./node_modules/next/router.js")); }; });
	},
	"./remoteComp": function() {
		return __webpack_require__.e(/*! __federation_expose_remoteComp */ "__federation_expose_remoteComp").then(function() { return function() { return (__webpack_require__(/*! ./components/fedcomp/module.tsx */ "./components/fedcomp/module.tsx")); }; });
	}
};
var get = function(module, getScope) {
	__webpack_require__.R = getScope;
	getScope = (
		__webpack_require__.o(moduleMap, module)
			? moduleMap[module]()
			: Promise.resolve().then(function() {
				throw new Error('Module "' + module + '" does not exist in container.');
			})
	);
	__webpack_require__.R = undefined;
	return getScope;
};
var init = function(shareScope, initScope, remoteEntryInitOptions) {
	return __webpack_require__.federation.bundlerRuntime.initContainerEntry({	webpackRequire: __webpack_require__,
		shareScope: shareScope,
		initScope: initScope,
		remoteEntryInitOptions: remoteEntryInitOptions,
		shareScopeKey: "default"
	})
};
__webpack_require__(/*! ./node_modules/.federation/entry.2d88cb90db7ff84f05925b07a55b0f71.js */ "./node_modules/.federation/entry.2d88cb90db7ff84f05925b07a55b0f71.js")

// This exports getters to disallow modifications
__webpack_require__.d(exports, {
	get: function() { return get; },
	init: function() { return init; }
});

/***/ }),

/***/ "./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = default_1;\nfunction default_1() {\n    return {\n        name: 'next-internal-plugin',\n        //@ts-ignore\n        createScript({ url, attrs }) {\n            if (typeof window !== 'undefined') {\n                const script = document.createElement('script');\n                script.src = url;\n                script.async = true;\n                //@ts-ignore\n                delete attrs.crossorigin;\n                return { script, timeout: 8000 };\n            }\n            return undefined;\n        },\n        errorLoadRemote({ id, error, from, origin }) {\n            console.error(id, 'offline');\n            const pg = function () {\n                console.error(id, 'offline', error);\n                return null;\n            };\n            pg.getInitialProps = function (ctx) {\n                return {};\n            };\n            let mod;\n            if (from === 'build') {\n                mod = () => ({\n                    __esModule: true,\n                    default: pg,\n                    getServerSideProps: () => ({ props: {} }),\n                });\n            }\n            else {\n                mod = {\n                    default: pg,\n                    getServerSideProps: () => ({ props: {} }),\n                };\n            }\n            return mod;\n        },\n        beforeInit(args) {\n            if (!globalThis.usedChunks)\n                globalThis.usedChunks = new Set();\n            if (typeof __webpack_require__.j === 'string' &&\n                !__webpack_require__.j.startsWith('webpack')) {\n                return args;\n            }\n            // if (__webpack_runtime_id__ && !__webpack_runtime_id__.startsWith('webpack')) return args;\n            const { moduleCache, name } = args.origin;\n            const gs = new Function('return globalThis')();\n            const attachedRemote = gs[name];\n            if (attachedRemote) {\n                moduleCache.set(name, attachedRemote);\n            }\n            return args;\n        },\n        init(args) {\n            return args;\n        },\n        beforeRequest: (args) => {\n            const { options, id } = args;\n            const remoteName = id.split('/').shift();\n            const remote = options.remotes.find((remote) => remote.name === remoteName);\n            if (!remote)\n                return args;\n            //@ts-ignore\n            if (remote?.entry?.includes('?t=')) {\n                return args;\n            }\n            //@ts-ignore\n            remote.entry = `${remote?.entry}?t=${Date.now()}`;\n            return args;\n        },\n        afterResolve(args) {\n            return args;\n        },\n        onLoad(args) {\n            const { exposeModuleFactory, exposeModule, id } = args;\n            const moduleOrFactory = exposeModuleFactory || exposeModule;\n            if (!moduleOrFactory)\n                return args; // Ensure moduleOrFactory is defined\n            if (typeof window === 'undefined') {\n                let exposedModuleExports;\n                try {\n                    exposedModuleExports = moduleOrFactory();\n                }\n                catch (e) {\n                    exposedModuleExports = moduleOrFactory;\n                }\n                const handler = {\n                    get(target, prop, receiver) {\n                        // Check if accessing a static property of the function itself\n                        if (target === exposedModuleExports &&\n                            typeof exposedModuleExports[prop] === 'function') {\n                            return function (...args) {\n                                globalThis.usedChunks.add(id);\n                                return exposedModuleExports[prop].apply(this, args);\n                            };\n                        }\n                        const originalMethod = target[prop];\n                        if (typeof originalMethod === 'function') {\n                            const proxiedFunction = function (...args) {\n                                globalThis.usedChunks.add(id);\n                                return originalMethod.apply(this, args);\n                            };\n                            // Copy all enumerable properties from the original method to the proxied function\n                            Object.keys(originalMethod).forEach((prop) => {\n                                Object.defineProperty(proxiedFunction, prop, {\n                                    value: originalMethod[prop],\n                                    writable: true,\n                                    enumerable: true,\n                                    configurable: true,\n                                });\n                            });\n                            return proxiedFunction;\n                        }\n                        return Reflect.get(target, prop, receiver);\n                    },\n                };\n                if (typeof exposedModuleExports === 'function') {\n                    // If the module export is a function, we create a proxy that can handle both its\n                    // call (as a function) and access to its properties (including static methods).\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                    // Proxy static properties specifically\n                    const staticProps = Object.getOwnPropertyNames(exposedModuleExports);\n                    staticProps.forEach((prop) => {\n                        if (typeof exposedModuleExports[prop] === 'function') {\n                            exposedModuleExports[prop] = new Proxy(exposedModuleExports[prop], handler);\n                        }\n                    });\n                    return () => exposedModuleExports;\n                }\n                else {\n                    // For objects, just wrap the exported object itself\n                    exposedModuleExports = new Proxy(exposedModuleExports, handler);\n                }\n                return exposedModuleExports;\n            }\n            return args;\n        },\n        resolveShare(args) {\n            if (args.pkgName !== 'react' &&\n                args.pkgName !== 'react-dom' &&\n                !args.pkgName.startsWith('next/')) {\n                return args;\n            }\n            const { shareScopeMap, scope, pkgName, version, GlobalFederation } = args;\n            const host = GlobalFederation['__INSTANCES__'][0];\n            if (!host) {\n                return args;\n            }\n            if (!host.options.shared[pkgName]) {\n                return args;\n            }\n            args.resolver = function () {\n                shareScopeMap[scope][pkgName][version] =\n                    host.options.shared[pkgName][0]; // replace local share scope manually with desired module\n                return shareScopeMap[scope][pkgName][version];\n            };\n            return args;\n        },\n        async beforeLoadShare(args) {\n            return args;\n        },\n    };\n}\n//# sourceMappingURL=runtimePlugin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVCwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBc0I7QUFDN0MsaUJBQWlCLHFCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWMsS0FBSyxXQUFXO0FBQzVEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQTJEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW1vdGUvLi9ub2RlX21vZHVsZXMvQG1vZHVsZS1mZWRlcmF0aW9uL25leHRqcy1tZi9kaXN0L3NyYy9wbHVnaW5zL2NvbnRhaW5lci9ydW50aW1lUGx1Z2luLmpzP2U0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG5mdW5jdGlvbiBkZWZhdWx0XzEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ25leHQtaW50ZXJuYWwtcGx1Z2luJyxcbiAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgIGNyZWF0ZVNjcmlwdCh7IHVybCwgYXR0cnMgfSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRycy5jcm9zc29yaWdpbjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzY3JpcHQsIHRpbWVvdXQ6IDgwMDAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yTG9hZFJlbW90ZSh7IGlkLCBlcnJvciwgZnJvbSwgb3JpZ2luIH0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoaWQsICdvZmZsaW5lJyk7XG4gICAgICAgICAgICBjb25zdCBwZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGlkLCAnb2ZmbGluZScsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwZy5nZXRJbml0aWFsUHJvcHMgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBtb2Q7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gJ2J1aWxkJykge1xuICAgICAgICAgICAgICAgIG1vZCA9ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIF9fZXNNb2R1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHBnLFxuICAgICAgICAgICAgICAgICAgICBnZXRTZXJ2ZXJTaWRlUHJvcHM6ICgpID0+ICh7IHByb3BzOiB7fSB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogcGcsXG4gICAgICAgICAgICAgICAgICAgIGdldFNlcnZlclNpZGVQcm9wczogKCkgPT4gKHsgcHJvcHM6IHt9IH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVJbml0KGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghZ2xvYmFsVGhpcy51c2VkQ2h1bmtzKVxuICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMudXNlZENodW5rcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX3J1bnRpbWVfaWRfXyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAhX193ZWJwYWNrX3J1bnRpbWVfaWRfXy5zdGFydHNXaXRoKCd3ZWJwYWNrJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIChfX3dlYnBhY2tfcnVudGltZV9pZF9fICYmICFfX3dlYnBhY2tfcnVudGltZV9pZF9fLnN0YXJ0c1dpdGgoJ3dlYnBhY2snKSkgcmV0dXJuIGFyZ3M7XG4gICAgICAgICAgICBjb25zdCB7IG1vZHVsZUNhY2hlLCBuYW1lIH0gPSBhcmdzLm9yaWdpbjtcbiAgICAgICAgICAgIGNvbnN0IGdzID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gZ2xvYmFsVGhpcycpKCk7XG4gICAgICAgICAgICBjb25zdCBhdHRhY2hlZFJlbW90ZSA9IGdzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dGFjaGVkUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlQ2FjaGUuc2V0KG5hbWUsIGF0dGFjaGVkUmVtb3RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBpbml0KGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVSZXF1ZXN0OiAoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zLCBpZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZU5hbWUgPSBpZC5zcGxpdCgnLycpLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZW1vdGUgPSBvcHRpb25zLnJlbW90ZXMuZmluZCgocmVtb3RlKSA9PiByZW1vdGUubmFtZSA9PT0gcmVtb3RlTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlbW90ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKHJlbW90ZT8uZW50cnk/LmluY2x1ZGVzKCc/dD0nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICByZW1vdGUuZW50cnkgPSBgJHtyZW1vdGU/LmVudHJ5fT90PSR7RGF0ZS5ub3coKX1gO1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGFmdGVyUmVzb2x2ZShhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgb25Mb2FkKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXhwb3NlTW9kdWxlRmFjdG9yeSwgZXhwb3NlTW9kdWxlLCBpZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZU9yRmFjdG9yeSA9IGV4cG9zZU1vZHVsZUZhY3RvcnkgfHwgZXhwb3NlTW9kdWxlO1xuICAgICAgICAgICAgaWYgKCFtb2R1bGVPckZhY3RvcnkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3M7IC8vIEVuc3VyZSBtb2R1bGVPckZhY3RvcnkgaXMgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV4cG9zZWRNb2R1bGVFeHBvcnRzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbW9kdWxlT3JGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbW9kdWxlT3JGYWN0b3J5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYWNjZXNzaW5nIGEgc3RhdGljIHByb3BlcnR5IG9mIHRoZSBmdW5jdGlvbiBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IGV4cG9zZWRNb2R1bGVFeHBvcnRzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGV4cG9zZWRNb2R1bGVFeHBvcnRzW3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMudXNlZENodW5rcy5hZGQoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbE1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3hpZWRGdW5jdGlvbiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMudXNlZENodW5rcy5hZGQoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGFsbCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWV0aG9kIHRvIHRoZSBwcm94aWVkIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob3JpZ2luYWxNZXRob2QpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3hpZWRGdW5jdGlvbiwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsTWV0aG9kW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveGllZEZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHBvc2VkTW9kdWxlRXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbW9kdWxlIGV4cG9ydCBpcyBhIGZ1bmN0aW9uLCB3ZSBjcmVhdGUgYSBwcm94eSB0aGF0IGNhbiBoYW5kbGUgYm90aCBpdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCAoYXMgYSBmdW5jdGlvbikgYW5kIGFjY2VzcyB0byBpdHMgcHJvcGVydGllcyAoaW5jbHVkaW5nIHN0YXRpYyBtZXRob2RzKS5cbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlZE1vZHVsZUV4cG9ydHMgPSBuZXcgUHJveHkoZXhwb3NlZE1vZHVsZUV4cG9ydHMsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm94eSBzdGF0aWMgcHJvcGVydGllcyBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljUHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhleHBvc2VkTW9kdWxlRXhwb3J0cyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY1Byb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3NlZE1vZHVsZUV4cG9ydHNbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvc2VkTW9kdWxlRXhwb3J0c1twcm9wXSA9IG5ldyBQcm94eShleHBvc2VkTW9kdWxlRXhwb3J0c1twcm9wXSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZXhwb3NlZE1vZHVsZUV4cG9ydHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igb2JqZWN0cywganVzdCB3cmFwIHRoZSBleHBvcnRlZCBvYmplY3QgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRNb2R1bGVFeHBvcnRzID0gbmV3IFByb3h5KGV4cG9zZWRNb2R1bGVFeHBvcnRzLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9zZWRNb2R1bGVFeHBvcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmVTaGFyZShhcmdzKSB7XG4gICAgICAgICAgICBpZiAoYXJncy5wa2dOYW1lICE9PSAncmVhY3QnICYmXG4gICAgICAgICAgICAgICAgYXJncy5wa2dOYW1lICE9PSAncmVhY3QtZG9tJyAmJlxuICAgICAgICAgICAgICAgICFhcmdzLnBrZ05hbWUuc3RhcnRzV2l0aCgnbmV4dC8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzaGFyZVNjb3BlTWFwLCBzY29wZSwgcGtnTmFtZSwgdmVyc2lvbiwgR2xvYmFsRmVkZXJhdGlvbiB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBHbG9iYWxGZWRlcmF0aW9uWydfX0lOU1RBTkNFU19fJ11bMF07XG4gICAgICAgICAgICBpZiAoIWhvc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdC5vcHRpb25zLnNoYXJlZFtwa2dOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5yZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaGFyZVNjb3BlTWFwW3Njb3BlXVtwa2dOYW1lXVt2ZXJzaW9uXSA9XG4gICAgICAgICAgICAgICAgICAgIGhvc3Qub3B0aW9ucy5zaGFyZWRbcGtnTmFtZV1bMF07IC8vIHJlcGxhY2UgbG9jYWwgc2hhcmUgc2NvcGUgbWFudWFsbHkgd2l0aCBkZXNpcmVkIG1vZHVsZVxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFyZVNjb3BlTWFwW3Njb3BlXVtwa2dOYW1lXVt2ZXJzaW9uXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgYmVmb3JlTG9hZFNoYXJlKGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ydW50aW1lUGx1Z2luLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@module-federation/nextjs-mf/dist/src/plugins/container/runtimePlugin.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/federation runtime */
/******/ 	!function() {
/******/ 		if(!__webpack_require__.federation){
/******/ 			__webpack_require__.federation = {
/******/ 				initOptions: {"name":"remote","remotes":[],"shareStrategy":"loaded-first"},
/******/ 				chunkMatcher: function(chunkId) {return true},
/******/ 				rootOutputDir: "../../",
/******/ 				initialConsumes: undefined,
/******/ 				bundlerRuntimeOptions: {}
/******/ 			};
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	!function() {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = function(result, chunkIds, fn, priority) {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	!function() {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = function(chunkId) {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "static/chunks/" + chunkId + ".js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	!function() {
/******/ 		__webpack_require__.hmrF = function() { return "static/webpack/" + __webpack_require__.h() + ".webpack.hot-update.json"; };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	!function() {
/******/ 		__webpack_require__.h = function() { return "4cb33454690f1b40"; }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	!function() {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "remote:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = function(url, done, key, chunkId) {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = __webpack_require__.tu(url);
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = function(prev, event) {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach(function(fn) { return fn(event); });
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/runtimeId */
/******/ 	!function() {
/******/ 		__webpack_require__.j = "webpack";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/sharing */
/******/ 	!function() {
/******/ 		__webpack_require__.S = {};
/******/ 		var initPromises = {};
/******/ 		var initTokens = {};
/******/ 		__webpack_require__.I = function(name, initScope) {
/******/ 			if(!initScope) initScope = [];
/******/ 			// handling circular init calls
/******/ 			var initToken = initTokens[name];
/******/ 			if(!initToken) initToken = initTokens[name] = {};
/******/ 			if(initScope.indexOf(initToken) >= 0) return;
/******/ 			initScope.push(initToken);
/******/ 			// only runs once
/******/ 			if(initPromises[name]) return initPromises[name];
/******/ 			// creates a new share scope if needed
/******/ 			if(!__webpack_require__.o(__webpack_require__.S, name)) __webpack_require__.S[name] = {};
/******/ 			// runs all init snippets from all modules reachable
/******/ 			var scope = __webpack_require__.S[name];
/******/ 			var warn = function(msg) {
/******/ 				if (typeof console !== "undefined" && console.warn) console.warn(msg);
/******/ 			};
/******/ 			var uniqueName = "remote";
/******/ 			var register = function(name, version, factory, eager) {
/******/ 				var versions = scope[name] = scope[name] || {};
/******/ 				var activeVersion = versions[version];
/******/ 				if(!activeVersion || (!activeVersion.loaded && (!eager != !activeVersion.eager ? eager : uniqueName > activeVersion.from))) versions[version] = { get: factory, from: uniqueName, eager: !!eager };
/******/ 			};
/******/ 			var initExternal = function(id) {
/******/ 				var handleError = function(err) { warn("Initialization of sharing external failed: " + err); };
/******/ 				try {
/******/ 					var module = __webpack_require__(id);
/******/ 					if(!module) return;
/******/ 					var initFn = function(module) { return module && module.init && module.init(__webpack_require__.S[name], initScope); }
/******/ 					if(module.then) return promises.push(module.then(initFn, handleError));
/******/ 					var initResult = initFn(module);
/******/ 					if(initResult && initResult.then) return promises.push(initResult['catch'](handleError));
/******/ 				} catch(err) { handleError(err); }
/******/ 			}
/******/ 			var promises = [];
/******/ 			switch(name) {
/******/ 				case "default": {
/******/ 					register("next/dynamic", "14.2.6", function() { return __webpack_require__.e("node_modules_next_dynamic_js-_73d40").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/dynamic.js */ "./node_modules/next/dynamic.js"); }; }); });
/******/ 					register("next/head", "14.2.6", function() { return __webpack_require__.e("node_modules_next_head_js-_88490").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/head.js */ "./node_modules/next/head.js"); }; }); });
/******/ 					register("next/image", "14.2.6", function() { return __webpack_require__.e("node_modules_next_image_js-_05350").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/image.js */ "./node_modules/next/image.js"); }; }); });
/******/ 					register("next/link", "14.2.6", function() { return __webpack_require__.e("node_modules_next_link_js-_75b30").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/link.js */ "./node_modules/next/link.js"); }; }); });
/******/ 					register("next/router", "14.2.6", function() { return __webpack_require__.e("__federation_expose_next__router").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/router.js */ "./node_modules/next/router.js"); }; }); });
/******/ 					register("next/script", "14.2.6", function() { return __webpack_require__.e("node_modules_next_script_js-_e4ba0").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/script.js */ "./node_modules/next/script.js"); }; }); });
/******/ 					register("react-dom/client", "18.3.1", function() { return __webpack_require__.e("node_modules_react-dom_client_js-_af810").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react-dom/client.js */ "./node_modules/react-dom/client.js"); }; }); });
/******/ 					register("react-dom", "18.3.1", function() { return __webpack_require__.e("__federation_expose_react_dom").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react-dom/index.js */ "./node_modules/react-dom/index.js"); }; }); });
/******/ 					register("react/jsx-dev-runtime", "18.3.1", function() { return __webpack_require__.e("node_modules_react_jsx-dev-runtime_js-_57771").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react/jsx-dev-runtime.js */ "./node_modules/react/jsx-dev-runtime.js"); }; }); });
/******/ 					register("react/jsx-runtime", "18.3.1", function() { return __webpack_require__.e("node_modules_react_jsx-runtime_js-_34d01").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react/jsx-runtime.js */ "./node_modules/react/jsx-runtime.js"); }; }); });
/******/ 					register("react", "18.3.1", function() { return __webpack_require__.e("__federation_expose_react").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react/index.js */ "./node_modules/react/index.js"); }; }); });
/******/ 					register("styled-jsx/style", "5.1.1", function() { return __webpack_require__.e("node_modules_styled-jsx_style_js-_a31c1").then(function() { return function() { return __webpack_require__(/*! ./node_modules/styled-jsx/style.js */ "./node_modules/styled-jsx/style.js"); }; }); });
/******/ 					register("styled-jsx", "5.1.1", function() { return __webpack_require__.e("node_modules_styled-jsx_index_js-_0a491").then(function() { return function() { return __webpack_require__(/*! ./node_modules/styled-jsx/index.js */ "./node_modules/styled-jsx/index.js"); }; }); });
/******/ 				}
/******/ 				break;
/******/ 			}
/******/ 			if(!promises.length) return initPromises[name] = 1;
/******/ 			return initPromises[name] = Promise.all(promises).then(function() { return initPromises[name] = 1; });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; },
/******/ 					createScriptURL: function(url) { return url; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	!function() {
/******/ 		__webpack_require__.tu = function(url) { return __webpack_require__.tt().createScriptURL(url); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/sharing */
/******/ 	!function() {
/******/ 		__webpack_require__.federation.initOptions.shared = {	"next/dynamic": [{	version: "14.2.6",
/******/ 				get: function() { return __webpack_require__.e("node_modules_next_dynamic_js-_73d40").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/dynamic.js */ "./node_modules/next/dynamic.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/head": [{	version: "14.2.6",
/******/ 				get: function() { return __webpack_require__.e("node_modules_next_head_js-_88490").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/head.js */ "./node_modules/next/head.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/image": [{	version: "14.2.6",
/******/ 				get: function() { return __webpack_require__.e("node_modules_next_image_js-_05350").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/image.js */ "./node_modules/next/image.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/link": [{	version: "14.2.6",
/******/ 				get: function() { return __webpack_require__.e("node_modules_next_link_js-_75b30").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/link.js */ "./node_modules/next/link.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/router": [{	version: "14.2.6",
/******/ 				get: function() { return __webpack_require__.e("__federation_expose_next__router").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/router.js */ "./node_modules/next/router.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"next/script": [{	version: "14.2.6",
/******/ 				get: function() { return __webpack_require__.e("node_modules_next_script_js-_e4ba0").then(function() { return function() { return __webpack_require__(/*! ./node_modules/next/script.js */ "./node_modules/next/script.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"react-dom/client": [{	version: "18.3.1",
/******/ 				get: function() { return __webpack_require__.e("node_modules_react-dom_client_js-_af810").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react-dom/client.js */ "./node_modules/react-dom/client.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"react-dom": [{	version: "18.3.1",
/******/ 				get: function() { return __webpack_require__.e("__federation_expose_react_dom").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react-dom/index.js */ "./node_modules/react-dom/index.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"react/jsx-dev-runtime": [{	version: "18.3.1",
/******/ 				get: function() { return __webpack_require__.e("node_modules_react_jsx-dev-runtime_js-_57771").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react/jsx-dev-runtime.js */ "./node_modules/react/jsx-dev-runtime.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"react/jsx-runtime": [{	version: "18.3.1",
/******/ 				get: function() { return __webpack_require__.e("node_modules_react_jsx-runtime_js-_34d01").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react/jsx-runtime.js */ "./node_modules/react/jsx-runtime.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"react": [{	version: "18.3.1",
/******/ 				get: function() { return __webpack_require__.e("__federation_expose_react").then(function() { return function() { return __webpack_require__(/*! ./node_modules/react/index.js */ "./node_modules/react/index.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":false,"strictVersion":false,"singleton":true}},],	"styled-jsx/style": [{	version: "5.1.1",
/******/ 				get: function() { return __webpack_require__.e("node_modules_styled-jsx_style_js-_a31c1").then(function() { return function() { return __webpack_require__(/*! ./node_modules/styled-jsx/style.js */ "./node_modules/styled-jsx/style.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":"^5.1.1","strictVersion":false,"singleton":true}},],	"styled-jsx": [{	version: "5.1.1",
/******/ 				get: function() { return __webpack_require__.e("node_modules_styled-jsx_index_js-_0a491").then(function() { return function() { return __webpack_require__(/*! ./node_modules/styled-jsx/index.js */ "./node_modules/styled-jsx/index.js"); }; }); },
/******/ 				scope: ["default"],
/******/ 				shareConfig: {"eager":false,"requiredVersion":"^5.1.1","strictVersion":false,"singleton":true}},],}
/******/ 		__webpack_require__.S = {};
/******/ 		var initPromises = {};
/******/ 		var initTokens = {};
/******/ 		__webpack_require__.I = function(name, initScope) {
/******/ 			return __webpack_require__.federation.bundlerRuntime.I({	shareScopeName: name,
/******/ 				webpackRequire: __webpack_require__,
/******/ 				initPromises: initPromises,
/******/ 				initTokens: initTokens,
/******/ 				initScope: initScope,
/******/ 			})
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	!function() {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../../";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/consumes */
/******/ 	!function() {
/******/ 		var installedModules = {};
/******/ 		var moduleToHandlerMapping = {
/******/ 			"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_react_jsx-runtime_js-_34d00").then(function() { return function() { return __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react/jsx-runtime",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/react": {
/******/ 				getter: function() { return __webpack_require__.e("__federation_expose_react").then(function() { return function() { return __webpack_require__(/*! react */ "./node_modules/react/index.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react-dom/client/react-dom/client": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_react-dom_client_js-_af811").then(function() { return function() { return __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react-dom/client",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react-dom/react-dom": {
/******/ 				getter: function() { return __webpack_require__.e("__federation_expose_react_dom").then(function() { return function() { return __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react-dom",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_react_jsx-dev-runtime_js-_57770").then(function() { return function() { return __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "react/jsx-dev-runtime",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/head/next/head": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_next_head_js-_88491").then(function() { return function() { return __webpack_require__(/*! next/head */ "./node_modules/next/head.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/head",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/router/next/router": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_next_router_js").then(function() { return function() { return __webpack_require__(/*! next/router */ "./node_modules/next/router.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": false,
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/router",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/link/next/link": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_next_link_js-_75b31").then(function() { return function() { return __webpack_require__(/*! next/link */ "./node_modules/next/link.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/link",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/script/next/script": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_next_script_js-_e4ba1").then(function() { return function() { return __webpack_require__(/*! next/script */ "./node_modules/next/script.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/script",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/image/next/image": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_next_image_js-_05351").then(function() { return function() { return __webpack_require__(/*! next/image */ "./node_modules/next/image.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/image",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/next/dynamic/next/dynamic": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_next_dynamic_js-_73d41").then(function() { return function() { return __webpack_require__(/*! next/dynamic */ "./node_modules/next/dynamic.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^12 || ^13 || ^14",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "next/dynamic",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/styled-jsx/styled-jsx": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_styled-jsx_index_js-_0a490").then(function() { return function() { return __webpack_require__(/*! styled-jsx */ "./node_modules/styled-jsx/index.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^5.1.1",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "styled-jsx",
/******/ 			},
/******/ 			"webpack/sharing/consume/default/styled-jsx/style/styled-jsx/style": {
/******/ 				getter: function() { return __webpack_require__.e("node_modules_styled-jsx_style_js-_a31c0").then(function() { return function() { return __webpack_require__(/*! styled-jsx/style */ "./node_modules/styled-jsx/style.js"); }; }); },
/******/ 				shareInfo: {
/******/ 					shareConfig: {
/******/ 					  "fixedDependencies": false,
/******/ 					  "requiredVersion": "^5.1.1",
/******/ 					  "strictVersion": false,
/******/ 					  "singleton": true,
/******/ 					  "eager": false
/******/ 					},
/******/ 					scope: ["default"],
/******/ 				},
/******/ 				shareKey: "styled-jsx/style",
/******/ 			}
/******/ 		};
/******/ 		var initialConsumes = ["webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime","webpack/sharing/consume/default/react/react","webpack/sharing/consume/default/react-dom/client/react-dom/client","webpack/sharing/consume/default/react-dom/react-dom","webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime"];
/******/ 		__webpack_require__.federation.installInitialConsumes = function() { return __webpack_require__.federation.bundlerRuntime.installInitialConsumes({
/******/ 			initialConsumes: initialConsumes,
/******/ 			installedModules:installedModules,
/******/ 			moduleToHandlerMapping:moduleToHandlerMapping,
/******/ 			webpackRequire: __webpack_require__
/******/ 		}); }
/******/ 		var chunkMapping = {
/******/ 			"main": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react",
/******/ 				"webpack/sharing/consume/default/react-dom/client/react-dom/client",
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom"
/******/ 			],
/******/ 			"node_modules_next_dynamic_js-_73d40": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_next_head_js-_88490": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_next_image_js-_05350": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_next_link_js-_75b30": [
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"__federation_expose_next__router": [
/******/ 				"webpack/sharing/consume/default/react/react",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom"
/******/ 			],
/******/ 			"node_modules_next_script_js-_e4ba0": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_react-dom_client_js-_af810": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom"
/******/ 			],
/******/ 			"__federation_expose_react_dom": [
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_react_jsx-dev-runtime_js-_57771": [
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_react_jsx-runtime_js-_34d01": [
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_styled-jsx_style_js-_a31c1": [
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_styled-jsx_index_js-_0a491": [
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"pages/_app": [
/******/ 				"webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime"
/******/ 			],
/******/ 			"__federation_expose_noop": [
/******/ 				"webpack/sharing/consume/default/next/head/next/head",
/******/ 				"webpack/sharing/consume/default/next/router/next/router",
/******/ 				"webpack/sharing/consume/default/next/link/next/link",
/******/ 				"webpack/sharing/consume/default/next/script/next/script",
/******/ 				"webpack/sharing/consume/default/next/image/next/image",
/******/ 				"webpack/sharing/consume/default/next/dynamic/next/dynamic",
/******/ 				"webpack/sharing/consume/default/react/jsx-runtime/react/jsx-runtime",
/******/ 				"webpack/sharing/consume/default/react/react",
/******/ 				"webpack/sharing/consume/default/styled-jsx/styled-jsx",
/******/ 				"webpack/sharing/consume/default/styled-jsx/style/styled-jsx/style"
/******/ 			],
/******/ 			"__federation_expose_remoteComp": [
/******/ 				"webpack/sharing/consume/default/react/jsx-dev-runtime/react/jsx-dev-runtime",
/******/ 				"webpack/sharing/consume/default/react/react"
/******/ 			],
/******/ 			"node_modules_next_router_js": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom"
/******/ 			],
/******/ 			"node_modules_next_script_js-_e4ba1": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom"
/******/ 			],
/******/ 			"node_modules_next_image_js-_05351": [
/******/ 				"webpack/sharing/consume/default/react-dom/react-dom"
/******/ 			]
/******/ 		};
/******/ 		__webpack_require__.f.consumes = function(chunkId, promises) {
/******/ 			__webpack_require__.federation.bundlerRuntime.consumes({
/******/ 			chunkMapping: chunkMapping,
/******/ 			installedModules: installedModules,
/******/ 			chunkId: chunkId,
/******/ 			moduleToHandlerMapping: moduleToHandlerMapping,
/******/ 			promises: promises,
/******/ 			webpackRequire:__webpack_require__
/******/ 			});
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"webpack": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = function(chunkId, promises) {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise(function(resolve, reject) { installedChunkData = installedChunks[chunkId] = [resolve, reject]; });
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = function(event) {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise(function(resolve, reject) {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = function(event) {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdateremote"] = function(chunkId, moreModules, runtime) {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = function() {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then(function(response) {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkremote"] = self["webpackChunkremote"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	!function() {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/inverted container startup */
/******/ 	!function() {
/******/ 		var innerRemote;
/******/ 		function attachRemote (resolve) {
/******/ 			if(__webpack_require__.m["webpack/container/entry/remote"]) {
/******/ 				innerRemote = __webpack_require__("webpack/container/entry/remote");
/******/ 			}
/******/ 			var gs = __webpack_require__.g || globalThis
/******/ 			gs["remote"] = innerRemote
/******/ 			if(resolve) resolve(innerRemote);
/******/ 			return innerRemote;
/******/ 		};
/******/ 		__webpack_require__.federation.attachRemote = attachRemote;
/******/ 		attachRemote();
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	
/******/ })()
;